diff --git a/include/shellcore/shell_sql.h b/include/shellcore/shell_sql.h
index 17b1b0e2b003c6be234571d96b09a7d6cdb556a4..8f5845760baff042e9534619698e01a7c955b6cc 100644
--- a/include/shellcore/shell_sql.h
+++ b/include/shellcore/shell_sql.h
@@ -40,6 +40,7 @@ public:
   virtual std::string prompt();
 
   virtual bool print_help(const std::string& topic);
+  void print_exception(const shcore::Exception &e);
 
 private:
   std::string _sql_cache;
diff --git a/modules/base_database_object.cc b/modules/base_database_object.cc
new file mode 100644
index 0000000000000000000000000000000000000000..ba639a41af0d34209f395c92addc50cfe3a8eabe
--- /dev/null
+++ b/modules/base_database_object.cc
@@ -0,0 +1,124 @@
+/*
+ * Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#include "base_database_object.h"
+
+#include "shellcore/object_factory.h"
+#include "shellcore/shell_core.h"
+#include "shellcore/lang_base.h"
+
+#include "shellcore/proxy_object.h"
+#include "base_session.h"
+
+#include <boost/bind.hpp>
+#include <boost/lexical_cast.hpp>
+#include <boost/format.hpp>
+#include <boost/pointer_cast.hpp>
+
+using namespace mysh;
+using namespace shcore;
+
+#include <iostream>
+
+DatabaseObject::DatabaseObject(boost::shared_ptr<BaseSession> session, boost::shared_ptr<DatabaseObject> schema, const std::string &name)
+: _session(session), _schema(schema), _name(name)
+{
+  add_method("getName", boost::bind(&DatabaseObject::get_member_method, this, _1, "getName", "name"), NULL);
+  add_method("getSession", boost::bind(&DatabaseObject::get_member_method, this, _1, "getSession", "session"), NULL);
+  add_method("getSchema", boost::bind(&DatabaseObject::get_member_method, this, _1, "getSchema", "schema"), NULL);
+}
+
+DatabaseObject::~DatabaseObject()
+{
+}
+
+std::string &DatabaseObject::append_descr(std::string &s_out, int indent, int quote_strings) const
+{
+  s_out.append("<" + class_name() + ":" + _name + ">");
+  return s_out;
+}
+
+std::string &DatabaseObject::append_repr(std::string &s_out) const
+{
+  return append_descr(s_out, false);
+}
+
+std::vector<std::string> DatabaseObject::get_members() const
+{
+  std::vector<std::string> members(Cpp_object_bridge::get_members());
+  members.push_back("name");
+  members.push_back("session");
+  members.push_back("schema");
+
+  return members;
+}
+
+shcore::Value DatabaseObject::get_member_method(const shcore::Argument_list &args, const std::string& method, const std::string& prop)
+{
+  std::string function = class_name() + "::" + method;
+  args.ensure_count(0, function.c_str());
+
+  return get_member(prop);
+}
+
+bool DatabaseObject::operator == (const Object_bridge &other) const
+{
+  if (class_name() == other.class_name())
+  {
+    return _session.lock() == ((DatabaseObject*)&other)->_session.lock() &&
+           _schema.lock() == ((DatabaseObject*)&other)->_schema.lock() &&
+           _name == ((DatabaseObject*)&other)->_name &&
+           class_name() == other.class_name();
+  }
+  return false;
+}
+
+bool DatabaseObject::has_member(const std::string &prop) const
+{
+  return Cpp_object_bridge::has_member(prop) ||
+    prop == "name" ||
+    prop == "session" ||
+    prop == "schema";
+}
+
+Value DatabaseObject::get_member(const std::string &prop) const
+{
+  Value ret_val;
+
+  if (prop == "name")
+    ret_val = Value(_name);
+  else if (prop == "session")
+  {
+    if (_session._empty())
+      ret_val = Value::Null();
+    else
+      ret_val = Value(boost::static_pointer_cast<Object_bridge>(_session.lock()));
+  }
+  else if (prop == "schema")
+  {
+    if (_schema._empty())
+      ret_val = Value::Null();
+    else
+    ret_val = Value(boost::static_pointer_cast<Object_bridge>(_schema.lock()));
+  }
+  else
+    ret_val = Cpp_object_bridge::get_member(prop);
+
+  return ret_val;
+}
\ No newline at end of file
diff --git a/modules/base_database_object.h b/modules/base_database_object.h
new file mode 100644
index 0000000000000000000000000000000000000000..2b95b8e9a0a5b81700592fb226ca5024821f2cca
--- /dev/null
+++ b/modules/base_database_object.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+// Interactive DB access module
+// (the one exposed as the db variable in the shell)
+
+#ifndef _MOD_DB_OBJECT_H_
+#define _MOD_DB_OBJECT_H_
+
+#include "mod_common.h"
+#include "shellcore/types.h"
+#include "shellcore/types_cpp.h"
+
+#include <boost/enable_shared_from_this.hpp>
+#include <boost/weak_ptr.hpp>
+
+namespace shcore
+{
+  class Proxy_object;
+};
+
+namespace mysh
+{
+  class BaseSession;
+  class CoreSchema;
+
+  class MOD_PUBLIC DatabaseObject : public shcore::Cpp_object_bridge
+  {
+  public:
+    DatabaseObject(boost::shared_ptr<BaseSession> session, boost::shared_ptr<DatabaseObject> schema, const std::string &name);
+    ~DatabaseObject();
+
+    virtual std::string &append_descr(std::string &s_out, int indent = -1, int quote_strings = 0) const;
+    virtual std::string &append_repr(std::string &s_out) const;
+
+    virtual bool has_member(const std::string &prop) const;
+    virtual std::vector<std::string> get_members() const;
+    virtual shcore::Value get_member(const std::string &prop) const;
+
+    virtual bool operator == (const Object_bridge &other) const;
+
+    shcore::Value get_member_method(const shcore::Argument_list &args, const std::string& method, const std::string& prop);
+
+  protected:
+    boost::weak_ptr<BaseSession> _session;
+    boost::weak_ptr<DatabaseObject> _schema;
+    std::string _name;
+  };
+};
+
+#endif
diff --git a/modules/base_resultset.cc b/modules/base_resultset.cc
new file mode 100644
index 0000000000000000000000000000000000000000..b39fae7c2e3614ab726f36c0f25e9a98cbc8f231
--- /dev/null
+++ b/modules/base_resultset.cc
@@ -0,0 +1,369 @@
+/*
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#include "base_resultset.h"
+
+#include "shellcore/object_factory.h"
+#include "shellcore/shell_core.h"
+#include "shellcore/lang_base.h"
+
+#include <boost/bind.hpp>
+#include <boost/lexical_cast.hpp>
+#include <boost/format.hpp>
+#include <boost/pointer_cast.hpp>
+
+using namespace mysh;
+using namespace shcore;
+
+#define MAX_COLUMN_LENGTH 1024
+#define MIN_COLUMN_LENGTH 4
+
+#include <iostream>
+
+BaseResultset::BaseResultset()
+{
+  add_method("nextResult", boost::bind(&BaseResultset::next_result, this, _1), NULL);
+  add_method("next", boost::bind(&BaseResultset::next, this, _1), NULL);
+  add_method("all", boost::bind(&BaseResultset::all, this, _1), NULL);
+  add_method("__paged_output__", boost::bind(&BaseResultset::print, this, _1), NULL);
+
+  add_method("getColumnMetadata", boost::bind(&BaseResultset::get_member_method, this, _1, "getColumnMetadata", "columnMetadata"), NULL);
+  add_method("getAffectedRows", boost::bind(&BaseResultset::get_member_method, this, _1, "getAffectedRows", "affectedRows"), NULL);
+  add_method("getFetchedRowCount", boost::bind(&BaseResultset::get_member_method, this, _1, "getFetchedRowCount", "fetchedRowCount"), NULL);
+  add_method("getWarningCount", boost::bind(&BaseResultset::get_member_method, this, _1, "getWarningCount", "warningCount"), NULL);
+  add_method("getExecutionTime", boost::bind(&BaseResultset::get_member_method, this, _1, "getExecutionTime", "executionTime"), NULL);
+  add_method("getLastInsertId", boost::bind(&BaseResultset::get_member_method, this, _1, "getLastInsertId", "lastInsertId"), NULL);
+  add_method("getInfo", boost::bind(&BaseResultset::get_member_method, this, _1, "getInfo", "info"), NULL);
+  add_method("getHasData", boost::bind(&BaseResultset::get_member_method, this, _1, "getHasData", "hasData"), NULL);
+}
+
+std::vector<std::string> BaseResultset::get_members() const
+{
+  std::vector<std::string> members(shcore::Cpp_object_bridge::get_members());
+  members.push_back("columnMetadata");
+  members.push_back("fetchedRowCount");
+  members.push_back("affectedRows");
+  members.push_back("warningCount");
+  members.push_back("executionTime");
+  members.push_back("lastInsertId");
+  members.push_back("info");
+  members.push_back("hasData");
+  return members;
+}
+
+bool BaseResultset::operator == (const Object_bridge &other) const
+{
+  return this == &other;
+}
+
+shcore::Value BaseResultset::get_member_method(const shcore::Argument_list &args, const std::string& method, const std::string& prop)
+{
+  std::string function = class_name() + "::" + method;
+  args.ensure_count(0, function.c_str());
+
+  return get_member(prop);
+}
+
+shcore::Value BaseResultset::print(const shcore::Argument_list &args)
+{
+  std::string function = class_name() + "::print";
+
+  args.ensure_count(0, 1, function.c_str());
+
+  std::string format;
+  if (args.size() > 0)
+  format = args.string_at(0);
+
+  if (format == "json")
+  print_json();
+  else
+  print_normal();
+
+  return shcore::Value();
+}
+
+void BaseResultset::print_json()
+{
+  shcore::Value::Map_type_ref data(new shcore::Value::Map_type);
+
+  if (get_member("hasData").as_bool())
+  {
+    shcore::Argument_list args;
+    args.push_back(shcore::Value::False());
+    shcore::Value records = all(args);
+
+    (*data)["row_count"] = get_member("fetchedRowCount");
+    (*data)["rows"] = records;
+  }
+  else
+  {
+    (*data)["affected_rows"] = get_member("affectedRows");
+  }
+
+  (*data)["duration"] = get_member("executionTime");
+  (*data)["warning_count"] = get_member("warningCount");
+  (*data)["info"] = get_member("info");
+
+  if ((*data)["warning_count"].as_int())
+  (*data)["warnings"] = get_member("warnings");
+
+  shcore::Value map(data);
+
+  shcore::print(map.repr() + "\n");
+}
+
+void BaseResultset::print_normal()
+{
+  std::string output;
+
+  do
+  {
+    if (get_member("hasData").as_bool())
+    {
+      shcore::Argument_list args;
+      shcore::Value records = all(args);
+      shcore::Value::Array_type_ref array_records = records.as_array();
+
+      // Gets the first row to determine there is data to print
+      // Base_row * row = next_row();
+
+      if (array_records->size())
+      {
+        // print rows from result, with stats etc
+        print_table(array_records);
+
+        int row_count = int(array_records->size());
+        output = (boost::format("%lld %s in set") % row_count % (row_count == 1 ? "row" : "rows")).str();
+      }
+      else
+        output = "Empty set";
+    }
+    else
+    {
+      // Some queries return -1 since affected rows do not apply to them
+      int affected_rows = get_member("affectedRows").as_int();
+      if (affected_rows == ~(unsigned long)0)
+        output = "Query OK";
+      else
+        // In case of Query OK, prints the actual number of affected rows.
+        output = (boost::format("Query OK, %lld %s affected") % affected_rows % (affected_rows == 1 ? "row" : "rows")).str();
+    }
+
+    int warning_count = get_member("warningCount").as_int();
+    if (warning_count)
+      output.append((boost::format(", %d warning%s") % warning_count % (warning_count == 1 ? "" : "s")).str());
+
+    output.append(" ");
+    output.append((boost::format("(%s)") % get_member("executionTime").as_string()).str());
+    output.append("\n\n");
+
+    shcore::print(output);
+
+    std::string info = get_member("info").as_string();
+    if (!info.empty())
+    {
+      shcore::print(info + "\n\n");
+    }
+
+    // Prints the warnings if there were any
+    if (warning_count)
+      print_warnings();
+  } while (next_result(shcore::Argument_list()).as_bool());
+}
+
+void BaseResultset::print_table(shcore::Value::Array_type_ref records)
+{
+  boost::shared_ptr<shcore::Value::Array_type> metadata = get_member("columnMetadata").as_array();
+
+  // Updates the metadata max_length field with the maximum length of the field values
+  size_t row_index;
+  for (row_index = 0; row_index < records->size(); row_index++)
+  {
+    boost::shared_ptr<Row> row = (*records)[row_index].as_object<Row>();
+    for (int field_index = 0; field_index < metadata->size(); field_index++)
+    {
+      int field_length = row->values[field_index].repr().length();
+
+      if (field_length >(*(*metadata)[field_index].as_map())["max_length"].as_int())
+        (*(*metadata)[field_index].as_map())["max_length"] = Value(field_length);
+    }
+  }
+  //-----------
+
+  unsigned int index = 0;
+  unsigned int field_count = metadata->size();
+  std::vector<std::string> formats(field_count, "%-");
+
+  // Calculates the max column widths and constructs the separator line.
+  std::string separator("+");
+  for (index = 0; index < field_count; index++)
+  {
+    int max_field_length = 0;
+    max_field_length = std::max<unsigned int>((*(*metadata)[index].as_map())["max_length"].as_int(), (*(*metadata)[index].as_map())["name_length"].as_int());
+    max_field_length = std::max<unsigned int>(max_field_length, MIN_COLUMN_LENGTH);
+    (*(*metadata)[index].as_map())["max_length"] = Value(max_field_length);
+    //_metadata[index].max_length(max_field_length);
+
+    // Creates the format string to print each field
+    formats[index].append(boost::lexical_cast<std::string>(max_field_length));
+    if (index == field_count - 1)
+      formats[index].append("s |");
+    else
+      formats[index].append("s | ");
+
+    std::string field_separator(max_field_length + 2, '-');
+    field_separator.append("+");
+    separator.append(field_separator);
+  }
+  separator.append("\n");
+
+  // Prints the initial separator line and the column headers
+  // TODO: Consider the charset information on the length calculations
+  shcore::print(separator + "| ");
+  for (index = 0; index < field_count; index++)
+  {
+    std::string data = (boost::format(formats[index]) % (*(*metadata)[index].as_map())["name"].as_string()).str();
+    shcore::print(data);
+
+    // Once the header is printed, updates the numeric fields formats
+    // so they are right aligned
+    if ((*(*metadata)[index].as_map())["is_numeric"].as_bool())
+      formats[index] = formats[index].replace(1, 1, "");
+  }
+
+  shcore::print("\n" + separator);
+
+  // Now prints the records
+  for (row_index = 0; row_index < records->size(); row_index++)
+  {
+    shcore::print("| ");
+
+    boost::shared_ptr<Row> row = (*records)[row_index].as_object<Row>();
+
+    for (size_t field_index = 0; field_index < metadata->size(); field_index++)
+    {
+      std::string raw_value = row->values[field_index].descr();
+      std::string data = (boost::format(formats[field_index]) % (raw_value)).str();
+
+      shcore::print(data);
+    }
+    shcore::print("\n");
+  }
+
+  shcore::print(separator);
+}
+
+void BaseResultset::print_warnings()
+{
+  Value warnings = get_member("warnings");
+
+  if (warnings)
+  {
+    Value::Array_type_ref warning_list = warnings.as_array();
+    size_t index = 0, size = warning_list->size();
+
+    while (index < size)
+    {
+      Value record = warning_list->at(index);
+      boost::shared_ptr<Value::Map_type> row = record.as_map();
+
+      unsigned long error = ((*row)["1"].as_int());
+
+      std::string type = (*row)["0"].as_string();
+      std::string msg = (*row)["2"].as_string();
+      shcore::print((boost::format("%s (Code %ld): %s\n") % type % error % msg).str());
+
+      index++;
+    }
+  }
+}
+
+Row::Row()
+{
+  add_method("getLength", boost::bind(&Row::get_member_method, this, _1, "getLength", "__length__"), NULL);
+}
+
+std::string &Row::append_descr(std::string &s_out, int indent, int quote_strings) const
+{
+  s_out.append((boost::format("<MapArray>")).str());
+  return s_out;
+}
+
+std::string &Row::append_repr(std::string &s_out) const
+{
+  return append_descr(s_out);
+}
+
+shcore::Value Row::get_member_method(const shcore::Argument_list &args, const std::string& method, const std::string& prop)
+{
+  std::string function = class_name() + "::" + method;
+  args.ensure_count(0, function.c_str());
+
+  return get_member(prop);
+}
+
+//! Returns the list of members that this object has
+std::vector<std::string> Row::get_members() const
+{
+  std::vector<std::string> l = shcore::Cpp_object_bridge::get_members();
+  l.push_back("__length__");
+
+  for (std::map<std::string, int>::const_iterator i = keys.begin(); i != keys.end(); ++i)
+    l.push_back(i->first);
+
+  return l;
+}
+
+//! Implements equality operator
+bool Row::operator == (const Object_bridge &other) const
+{
+  return false;
+}
+
+//! Returns the value of a member
+shcore::Value Row::get_member(const std::string &prop) const
+{
+  if (prop == "__length__")
+    return shcore::Value((int)values.size());
+  else
+  {
+    unsigned int index = 0;
+    if (sscanf(prop.c_str(), "%u", &index) == 1)
+    {
+      if (index > values.size() - 1)
+        return shcore::Value();
+
+      return values[index];
+    }
+    else
+    {
+      std::map<std::string, int>::const_iterator it;
+      if ((it = keys.find(prop)) != keys.end())
+        return values[it->second];
+    }
+  }
+
+  return shcore::Cpp_object_bridge::get_member(prop);
+}
+
+void Row::add_item(const std::string &key, shcore::Value value)
+{
+  values.push_back(value);
+  keys[key] = values.size() - 1;
+}
\ No newline at end of file
diff --git a/modules/base_resultset.h b/modules/base_resultset.h
new file mode 100644
index 0000000000000000000000000000000000000000..138672b6978c6d21c7f40af89406dbef81c8aba7
--- /dev/null
+++ b/modules/base_resultset.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+// Interactive session access module
+// Exposed as "session" in the shell
+
+#ifndef _MOD_CORE_RESULT_SET_H_
+#define _MOD_CORE_RESULT_SET_H_
+
+#include "shellcore/types.h"
+#include "shellcore/types_cpp.h"
+
+namespace mysh
+{
+  class BaseResultset : public shcore::Cpp_object_bridge
+  {
+  public:
+    BaseResultset();
+
+    // Methods from Cpp_object_bridge will be defined here
+    // Since all the connections will expose the same members
+    virtual std::vector<std::string> get_members() const;
+    virtual bool operator == (const Object_bridge &other) const;
+
+    virtual shcore::Value next(const shcore::Argument_list &args) = 0;
+    virtual shcore::Value all(const shcore::Argument_list &args) = 0;
+    virtual shcore::Value next_result(const shcore::Argument_list &args) = 0;
+
+    // Helper method to retrieve properties using a method
+    shcore::Value get_member_method(const shcore::Argument_list &args, const std::string& method, const std::string& prop);
+
+    // Printing functions
+    shcore::Value print(const shcore::Argument_list &args);
+    void print_json();
+    void print_normal();
+    void print_table(shcore::Value::Array_type_ref records);
+    void print_warnings();
+  };
+
+  class Row : public shcore::Cpp_object_bridge
+  {
+  public:
+    Row();
+    virtual std::string class_name() const { return "Row"; }
+    shcore::Value get_member_method(const shcore::Argument_list &args, const std::string& method, const std::string& prop);
+
+  public:
+    shcore::Value::Array_type values;
+    std::map<std::string, int> keys;
+
+    virtual std::string &append_descr(std::string &s_out, int indent = -1, int quote_strings = 0) const;
+    virtual std::string &append_repr(std::string &s_out) const;
+
+    //! Returns the list of members that this object has
+    virtual std::vector<std::string> get_members() const;
+    //! Implements equality operator
+    virtual bool operator == (const Object_bridge &other) const;
+
+    //! Returns the value of a member
+    virtual shcore::Value get_member(const std::string &prop) const;
+
+    void add_item(const std::string &key, shcore::Value value);
+  };
+};
+
+#endif
diff --git a/modules/base_session.cc b/modules/base_session.cc
new file mode 100644
index 0000000000000000000000000000000000000000..f96bfc5b6832919ef37bdc8ac3f7ccf9de922253
--- /dev/null
+++ b/modules/base_session.cc
@@ -0,0 +1,243 @@
+/*
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#include "base_session.h"
+
+#include "shellcore/object_factory.h"
+#include "shellcore/shell_core.h"
+#include "shellcore/lang_base.h"
+
+#include "shellcore/proxy_object.h"
+
+#include <boost/bind.hpp>
+#include <boost/lexical_cast.hpp>
+#include <boost/format.hpp>
+#include <boost/pointer_cast.hpp>
+
+#include "mod_mysql_session.h"
+#include "mod_mysqlx_session.h"
+
+#define MAX_COLUMN_LENGTH 1024
+#define MIN_COLUMN_LENGTH 4
+
+using namespace mysh;
+using namespace shcore;
+
+#include <iostream>
+
+bool mysh::parse_mysql_connstring(const std::string &connstring,
+                            std::string &protocol, std::string &user, std::string &password,
+                            std::string &host, int &port, std::string &sock,
+                            std::string &db, int &pwd_found)
+{
+  // format is [protocol://][user[:pass]]@host[:port][/db] or user[:pass]@::socket[/db], like what cmdline utilities use
+  pwd_found = 0;
+  std::string remaining = connstring;
+
+  std::string::size_type p;
+  p = remaining.find("://");
+  if (p != std::string::npos)
+  {
+    protocol = connstring.substr(0, p);
+    remaining = remaining.substr(p + 3);
+  }
+
+  std::string s = remaining;
+  p = remaining.find('/');
+  if (p != std::string::npos)
+  {
+    db = remaining.substr(p + 1);
+    s = remaining.substr(0, p);
+  }
+  p = s.rfind('@');
+  std::string user_part;
+  std::string server_part = (p == std::string::npos) ? s : s.substr(p + 1);
+
+  if (p == std::string::npos)
+  {
+    // by default, connect using the current OS username
+#ifdef _WIN32
+    //XXX find out current username here
+#else
+    const char *tmp = getenv("USER");
+    user_part = tmp ? tmp : "";
+#endif
+  }
+  else
+    user_part = s.substr(0, p);
+
+  if ((p = user_part.find(':')) != std::string::npos)
+  {
+    user = user_part.substr(0, p);
+    password = user_part.substr(p + 1);
+    pwd_found = 1;
+  }
+  else
+    user = user_part;
+
+  p = server_part.find(':');
+  if (p != std::string::npos)
+  {
+    host = server_part.substr(0, p);
+    server_part = server_part.substr(p + 1);
+    p = server_part.find(':');
+    if (p != std::string::npos)
+      sock = server_part.substr(p + 1);
+    else
+    if (!sscanf(server_part.substr(0, p).c_str(), "%i", &port))
+      return false;
+  }
+  else
+    host = server_part;
+  return true;
+}
+
+std::string mysh::strip_password(const std::string &connstring)
+{
+  std::string remaining = connstring;
+  std::string password;
+
+  std::string::size_type p;
+  p = remaining.find("://");
+  if (p != std::string::npos)
+  {
+    remaining = remaining.substr(p + 3);
+  }
+
+  std::string s = remaining;
+  p = remaining.find('/');
+  if (p != std::string::npos)
+  {
+    s = remaining.substr(0, p);
+  }
+  p = s.rfind('@');
+  std::string user_part;
+
+  if (p == std::string::npos)
+  {
+    // by default, connect using the current OS username
+#ifdef _WIN32
+    //XXX find out current username here
+#else
+    const char *tmp = getenv("USER");
+    user_part = tmp ? tmp : "";
+#endif
+  }
+  else
+    user_part = s.substr(0, p);
+
+  if ((p = user_part.find(':')) != std::string::npos)
+  {
+    password = user_part.substr(p + 1);
+    if (!password.empty())
+    {
+      std::string uri_stripped = connstring;
+      std::string::size_type i = uri_stripped.find(":" + password);
+      if (i != std::string::npos)
+        uri_stripped.erase(i, password.length() + 1);
+
+      return uri_stripped;
+    }
+  }
+
+  // no password to strip, return original one
+  return connstring;
+}
+
+boost::shared_ptr<mysh::BaseSession> mysh::connect_session(const shcore::Argument_list &args)
+{
+  std::string protocol;
+  std::string user;
+  std::string pass;
+  const char *pwd_override = NULL;
+  std::string host;
+  std::string sock;
+  std::string db;
+  std::string uri_stripped;
+
+  int pwd_found;
+  int port = 0;
+
+  std::string uri = args.string_at(0);
+
+  boost::shared_ptr<BaseSession> ret_val;
+
+  if (!parse_mysql_connstring(uri, protocol, user, pass, host, port, sock, db, pwd_found))
+    throw shcore::Exception::argument_error("Could not parse URI for MySQL connection");
+
+  if (protocol.empty() || protocol == "mysql")
+  {
+    ret_val.reset(new mysql::Session());
+  }
+  else if (protocol == "mysqlx")
+  {
+    ret_val.reset(new mysh::mysqlx::NodeSession());
+  }
+  else
+    throw shcore::Exception::argument_error("Invalid protocol specified for MySQL connection.");
+
+  ret_val->connect(args);
+
+  return ret_val;
+}
+
+BaseSession::BaseSession()
+{
+  add_method("getDefaultSchema", boost::bind(&BaseSession::get_member_method, this, _1, "getDefaultSchema", "defaultSchema"), NULL);
+  add_method("getSchema", boost::bind(&BaseSession::get_schema, this, _1), "name", shcore::String, NULL);
+  add_method("getSchemas", boost::bind(&BaseSession::get_member_method, this, _1, "getSchemas", "schemas"), NULL);
+  add_method("getUri", boost::bind(&BaseSession::get_member_method, this, _1, "getUri", "uri"), NULL);
+  add_method("setDefaultSchema", boost::bind(&BaseSession::set_default_schema, this, _1), "name", shcore::String, NULL);
+}
+
+std::string &BaseSession::append_descr(std::string &s_out, int indent, int quote_strings) const
+{
+  if (!is_connected())
+    s_out.append("<" + class_name() + ":disconnected>");
+  else
+    s_out.append("<" + class_name() + ":" + uri() + ">");
+  return s_out;
+}
+
+std::string &BaseSession::append_repr(std::string &s_out) const
+{
+  return append_descr(s_out, false);
+}
+
+std::vector<std::string> BaseSession::get_members() const
+{
+  std::vector<std::string> members(Cpp_object_bridge::get_members());
+  members.push_back("defaultSchema");
+  members.push_back("schemas");
+  members.push_back("uri");
+  return members;
+}
+
+shcore::Value BaseSession::get_member_method(const shcore::Argument_list &args, const std::string& method, const std::string& prop)
+{
+  std::string function = class_name() + "::" + method;
+  args.ensure_count(0, function.c_str());
+
+  return get_member(prop);
+}
+
+bool BaseSession::operator == (const Object_bridge &other) const
+{
+  return class_name() == other.class_name() && this == &other;
+}
\ No newline at end of file
diff --git a/modules/base_session.h b/modules/base_session.h
new file mode 100644
index 0000000000000000000000000000000000000000..ce42d7e8dcbdc2c28071a9f94a3350003db5321c
--- /dev/null
+++ b/modules/base_session.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+// Interactive session access module
+// Exposed as "session" in the shell
+
+#ifndef _MOD_CORE_SESSION_H_
+#define _MOD_CORE_SESSION_H_
+
+#include "shellcore/types.h"
+#include "shellcore/types_cpp.h"
+#include "shellcore/ishell_core.h"
+
+namespace mysh
+{
+  bool parse_mysql_connstring(const std::string &connstring,
+                              std::string &protocol, std::string &user, std::string &password,
+                              std::string &host, int &port, std::string &sock,
+                              std::string &db, int &pwd_found);
+
+  std::string strip_password(const std::string &connstring);
+
+  class BaseSession : public shcore::Cpp_object_bridge
+  {
+  public:
+    BaseSession();
+    virtual ~BaseSession() {};
+
+    // Virtual methods from object bridge
+    virtual std::string &append_descr(std::string &s_out, int indent = -1, int quote_strings = 0) const;
+    virtual std::string &append_repr(std::string &s_out) const;
+
+    virtual bool operator == (const Object_bridge &other) const;
+
+    virtual std::vector<std::string> BaseSession::get_members() const;
+
+    // Virtual methods from ISession
+    virtual shcore::Value connect(const shcore::Argument_list &args) = 0;
+    virtual void disconnect() = 0;
+    virtual shcore::Value executeSql(const shcore::Argument_list &args) = 0;
+    virtual bool is_connected() const = 0;
+    virtual std::string uri() const = 0;
+
+    virtual shcore::Value get_schema(const shcore::Argument_list &args) const = 0;
+    virtual shcore::Value set_default_schema(const shcore::Argument_list &args) = 0;
+
+    // Helper method to retrieve properties using a method
+    shcore::Value get_member_method(const shcore::Argument_list &args, const std::string& method, const std::string& prop);
+  };
+
+  boost::shared_ptr<mysh::BaseSession> connect_session(const shcore::Argument_list &args);
+};
+
+#endif
diff --git a/modules/crud_definition.cc b/modules/crud_definition.cc
index 6a7eaf859392c5247a35eb8ebaa76b4cbff59cb4..cdd5fbeaa90c6d41f9318379c1e0d57a7684a756 100644
--- a/modules/crud_definition.cc
+++ b/modules/crud_definition.cc
@@ -17,7 +17,6 @@
  * 02110-1301  USA
  */
 
-#include "expr_parser.h"
 #include "proj_parser.h"
 #include <boost/bind.hpp>
 #include <boost/algorithm/string.hpp>
@@ -25,17 +24,13 @@
 #include "crud_definition.h"
 
 using namespace mysh;
+using namespace mysh::mysqlx;
 using namespace shcore;
 
-Crud_definition::Crud_definition(const shcore::Argument_list &args)
+Crud_definition::Crud_definition()
 {
-  args.ensure_at_least(1, "Crud_definition");
-
   try
   {
-    boost::shared_ptr<mysh::X_connection> connection = args[0].as_object<mysh::X_connection>();
-    _conn = boost::weak_ptr<X_connection>(connection);
-
     add_method("execute", boost::bind(&Crud_definition::execute, this, _1), "data");
   }
   catch (shcore::Exception &e)
@@ -122,69 +117,69 @@ shcore::Value Crud_definition::execute(const shcore::Argument_list &args)
 {
   // TODO: Callback handling logic
   shcore::Value ret_val;
-  boost::shared_ptr<mysh::X_connection> connection(_conn.lock());
+  /*boost::shared_ptr<mysh::X_connection> connection(_conn.lock());
 
   if (connection)
-    ret_val = connection->crud_execute(class_name(), _data);
+  ret_val = connection->crud_execute(class_name(), _data);*/
 
   return ret_val;
 }
 
 void Crud_definition::set_filter(const std::string &source, const std::string &field, shcore::Value value, bool collection)
 {
-  // First validates that the received value is a string
+  /*// First validates that the received value is a string
   if (value.type != shcore::String)
-    throw shcore::Exception::argument_error(source + ": string parameter required.");
+  throw shcore::Exception::argument_error(source + ": string parameter required.");
 
   // Now validates that it is a valid expression
   try
   {
-    // This basically validates the expression is correct, if an error is found
-    // a runtime exception will be generated by the parser
-    mysqlx::Expr_parser parser(value.as_string(), collection);
-    parser.expr();
+  // This basically validates the expression is correct, if an error is found
+  // a runtime exception will be generated by the parser
+  mysqlx::Expr_parser parser(value.as_string(), collection);
+  parser.expr();
 
-    (*_data)[field] = value;
+  (*_data)[field] = value;
   }
   catch (mysqlx::Parser_error &e)
   {
-    std::string error = source;
-    error.append(": ");
-    error.append(e.what());
-    throw shcore::Exception::argument_error(error);
-  }
+  std::string error = source;
+  error.append(": ");
+  error.append(e.what());
+  throw shcore::Exception::argument_error(error);
+  }*/
 }
 
 void Crud_definition::set_columns(const std::string &source, const std::string &field, shcore::Value value, bool collection, bool with_alias)
 {
-  // First validates that the received value is a string
+  /*// First validates that the received value is a string
   if (value.type != shcore::String)
-    throw shcore::Exception::argument_error(source + ": string parameter required.");
+  throw shcore::Exception::argument_error(source + ": string parameter required.");
 
   // Now validates that it is a valid expression
   try
   {
-    // We use the parser directly for simplicity
-    mysqlx::Proj_parser parser(value.as_string(), collection, with_alias);
-    //parser.parse();
-    //parser.projection();
+  // We use the parser directly for simplicity
+  mysqlx::Proj_parser parser(value.as_string(), collection, with_alias);
+  //parser.parse();
+  //parser.projection();
 
-    (*_data)[field] = value;
+  (*_data)[field] = value;
   }
   catch (std::runtime_error &e)
   {
-    std::string error = source;
-    error.append(": ");
-    error.append(e.what());
-    throw shcore::Exception::argument_error(error);
-  }
+  std::string error = source;
+  error.append(": ");
+  error.append(e.what());
+  throw shcore::Exception::argument_error(error);
+  }*/
 }
 
 void Crud_definition::set_order(const std::string &source, const std::string &field, shcore::Value value)
 {
-  // First validates that the received value is a string
+  /*// First validates that the received value is a string
   if (value.type != shcore::String)
-    throw shcore::Exception::argument_error(source + ": string parameter required.");
+  throw shcore::Exception::argument_error(source + ": string parameter required.");
 
   // TODO: remove this exception when the Order_parser is implemented
   throw shcore::Exception::logic_error(source + ": not yet implemented.");
@@ -192,16 +187,16 @@ void Crud_definition::set_order(const std::string &source, const std::string &fi
   // Now validates that it is a valid expression
   try
   {
-    // TODO: The projection parser should be called just to ensure the received data is correct
-    //Order_parser order(value.as_string());
+  // TODO: The projection parser should be called just to ensure the received data is correct
+  //Order_parser order(value.as_string());
 
-    (*_data)[field] = value;
+  //(*_data)[field] = value;
   }
   catch (std::runtime_error &e)
   {
-    std::string error = source;
-    error.append(": ");
-    error.append(e.what());
-    throw shcore::Exception::argument_error(error);
-  }
+  std::string error = source;
+  error.append(": ");
+  error.append(e.what());
+  throw shcore::Exception::argument_error(error);
+  }*/
 }
\ No newline at end of file
diff --git a/modules/crud_definition.h b/modules/crud_definition.h
index 6cc9bcd3e8014cfc168d71589828d4b200f980b7..d241523701cab6a32bd6148e5f8a44968295ce90 100644
--- a/modules/crud_definition.h
+++ b/modules/crud_definition.h
@@ -24,17 +24,17 @@
 #define _MOD_CRUD_DEFINITION_H_
 
 #include "shellcore/types_cpp.h"
-#include "mod_mysqlx.h"
 
 #include <set>
 
 namespace mysh
 {
-  class X_connection;
+namespace mysqlx
+{
   class Crud_definition : public shcore::Cpp_object_bridge
   {
   public:
-    Crud_definition(const shcore::Argument_list &args);
+    Crud_definition();
     // T the moment will put these since we don't really care about them
     virtual bool operator == (const Object_bridge &other) const { return false; }
 
@@ -45,11 +45,8 @@ namespace mysh
     virtual shcore::Value call(const std::string &name, const shcore::Argument_list &args);
 
     // The last step on CRUD operations
-    shcore::Value execute(const shcore::Argument_list &args);
+    virtual shcore::Value execute(const shcore::Argument_list &args) = 0;
   protected:
-    boost::weak_ptr<X_connection> _conn;
-    shcore::Value::Map_type_ref _data;
-
     // The CRUD operations will use "dynamic" functions to control the method chaining.
     // A dynamic function is one that will be enabled/disabled based on the method
     // chain sequence.
@@ -71,6 +68,7 @@ namespace mysh
     void set_columns(const std::string &source, const std::string &field, shcore::Value value, bool collection, bool with_alias);
     void set_order(const std::string &source, const std::string &field, shcore::Value value);
   };
-};
+}
+}
 
 #endif
diff --git a/modules/mod_common.h b/modules/mod_common.h
index 71b6417b0e1ebce1de5b6143006491007e53a18d..e3bd4b3139f60a68664fab2da3b973fd3573ea3b 100644
--- a/modules/mod_common.h
+++ b/modules/mod_common.h
@@ -17,7 +17,6 @@
 * 02110-1301  USA
 */
 
-
 #ifndef _MOD_COMMON_H_
 #define _MOD_COMMON_H_
 
diff --git a/modules/mod_connection.cc b/modules/mod_connection.cc
deleted file mode 100644
index 356ee6e1a59deaa22caa911976efc7c7a4077651..0000000000000000000000000000000000000000
--- a/modules/mod_connection.cc
+++ /dev/null
@@ -1,710 +0,0 @@
-/*
- * Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; version 2 of the
- * License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#include "shellcore/object_factory.h"
-#include "shellcore/shell_core.h"
-#include "shellcore/lang_base.h"
-
-#include "shellcore/proxy_object.h"
-
-#include <boost/bind.hpp>
-#include <boost/lexical_cast.hpp>
-#include <boost/format.hpp>
-#include <boost/pointer_cast.hpp>
-#include "shellcore/obj_date.h"
-
-#if WIN32
-#  include <winsock2.h>
-#endif
-
-#include <mysql.h>
-#include "mod_connection.h"
-
-#define MAX_COLUMN_LENGTH 1024
-#define MIN_COLUMN_LENGTH 4
-
-using namespace mysh;
-using namespace shcore;
-
-#include <iostream>
-
-namespace mysh {
-  bool parse_mysql_connstring(const std::string &connstring,
-                                     std::string &protocol, std::string &user, std::string &password,
-                                     std::string &host, int &port, std::string &sock,
-                                     std::string &db, int &pwd_found)
-  {
-    // format is [protocol://][user[:pass]]@host[:port][/db] or user[:pass]@::socket[/db], like what cmdline utilities use
-    pwd_found = 0;
-    std::string remaining = connstring;
-
-    std::string::size_type p;
-    p = remaining.find("://");
-    if (p != std::string::npos)
-    {
-      protocol = connstring.substr(0, p);
-      remaining = remaining.substr(p + 3);
-    }
-
-    std::string s = remaining;
-    p = remaining.find('/');
-    if (p != std::string::npos)
-    {
-      db = remaining.substr(p + 1);
-      s = remaining.substr(0, p);
-    }
-    p = s.rfind('@');
-    std::string user_part;
-    std::string server_part = (p == std::string::npos) ? s : s.substr(p + 1);
-
-    if (p == std::string::npos)
-    {
-      // by default, connect using the current OS username
-#ifdef _WIN32
-      //XXX find out current username here
-#else
-      const char *tmp = getenv("USER");
-      user_part = tmp ? tmp : "";
-#endif
-    }
-    else
-      user_part = s.substr(0, p);
-
-    if ((p = user_part.find(':')) != std::string::npos)
-    {
-      user = user_part.substr(0, p);
-      password = user_part.substr(p + 1);
-      pwd_found = 1;
-    }
-    else
-      user = user_part;
-
-    p = server_part.find(':');
-    if (p != std::string::npos)
-    {
-      host = server_part.substr(0, p);
-      server_part = server_part.substr(p + 1);
-      p = server_part.find(':');
-      if (p != std::string::npos)
-        sock = server_part.substr(p + 1);
-      else
-      if (!sscanf(server_part.substr(0, p).c_str(), "%i", &port))
-        return false;
-    }
-    else
-      host = server_part;
-    return true;
-  }
-
-  std::string strip_password(const std::string &connstring)
-  {
-    std::string remaining = connstring;
-    std::string password;
-
-    std::string::size_type p;
-    p = remaining.find("://");
-    if (p != std::string::npos)
-    {
-      remaining = remaining.substr(p + 3);
-    }
-
-    std::string s = remaining;
-    p = remaining.find('/');
-    if (p != std::string::npos)
-    {
-      s = remaining.substr(0, p);
-    }
-    p = s.rfind('@');
-    std::string user_part;
-
-    if (p == std::string::npos)
-    {
-      // by default, connect using the current OS username
-#ifdef _WIN32
-      //XXX find out current username here
-#else
-      const char *tmp = getenv("USER");
-      user_part = tmp ? tmp : "";
-#endif
-    }
-    else
-      user_part = s.substr(0, p);
-
-    if ((p = user_part.find(':')) != std::string::npos)
-    {
-      password = user_part.substr(p + 1);
-      if (!password.empty())
-      {
-        std::string uri_stripped = connstring;
-        std::string::size_type i = uri_stripped.find(":" + password);
-        if (i != std::string::npos)
-          uri_stripped.erase(i, password.length() + 1);
-
-        return uri_stripped;
-      }
-    }
-
-    // no password to strip, return original one
-    return connstring;
-  }
-}
-
-//----------------------------- Base_connection ----------------------------------------
-Base_connection::Base_connection(const std::string &uri, const char *password)
-{
-  add_method("close", boost::bind(&Base_connection::close, this, _1), NULL);
-  add_method("sql", boost::bind(&Base_connection::sql_, this, _1),
-             "stmt", shcore::String,
-             "*args", shcore::Map,
-             NULL);
-  add_method("sql_one", boost::bind(&Base_connection::sql_one_, this, _1),
-             "stmt", shcore::String,
-             NULL);
-
-  std::string protocol;
-  std::string user;
-  std::string pass;
-  std::string host;
-  int port = 0;
-  std::string sock;
-  std::string db;
-  int pwd_found;
-
-  if (!parse_mysql_connstring(uri, protocol, user, _pwd, host, port, sock, db, pwd_found))
-    throw shcore::Exception::argument_error("Could not parse URI for MySQL connection");
-
-  _uri = uri;
-}
-
-std::string &Base_connection::append_descr(std::string &s_out, int indent, int quote_strings) const
-{
-  s_out.append("<" + class_name() + ":" + _uri + ">");
-  return s_out;
-}
-
-std::string &Base_connection::append_repr(std::string &s_out) const
-{
-  return append_descr(s_out, false);
-}
-
-std::vector<std::string> Base_connection::get_members() const
-{
-  std::vector<std::string> members(Cpp_object_bridge::get_members());
-  members.push_back("uri");
-  return members;
-}
-
-shcore::Value Base_connection::get_member(const std::string &prop) const
-{
-  if (prop == "uri")
-    return shcore::Value(_uri);
-  return Cpp_object_bridge::get_member(prop);
-}
-
-bool Base_connection::operator == (const Object_bridge &other) const
-{
-  return this == &other;
-}
-
-shcore::Value Base_connection::sql_(const shcore::Argument_list &args)
-{
-  std::string function = class_name() + "::sql";
-
-  args.ensure_count(1, 2, function.c_str());
-
-  std::string query = args.string_at(0);
-
-  return sql(query, shcore::Value());
-}
-
-shcore::Value Base_connection::sql_one_(const shcore::Argument_list &args)
-{
-  std::string function = class_name() + "::sql_one";
-
-  args.ensure_count(1, function.c_str());
-
-  std::string query = args.string_at(0);
-
-  return sql_one(query);
-}
-
-Field::Field(const std::string& catalog, const std::string& db, const std::string& table, const std::string& otable, const std::string& name, const std::string& oname, int length, int type, int flags, int decimals, int charset) :
-_catalog(catalog),
-_db(db),
-_table(table),
-_org_table(otable),
-_name(name),
-_org_name(oname),
-_length(length),
-_type(type),
-_flags(flags),
-_decimals(decimals),
-_charset(charset),
-_max_length(0),
-_name_length(name.length())
-{
-}
-
-//----------------------------- Base_resultset ----------------------------------------
-
-Base_resultset::Base_resultset(boost::shared_ptr<Base_connection> owner, uint64_t affected_rows, uint64_t last_insert_id, int warning_count, const char* info, boost::shared_ptr<shcore::Value::Map_type> options)
-: _key_by_index(false), _has_resultset(false), _fetched_row_count(0), _affected_rows(affected_rows), _last_insert_id(last_insert_id), _warning_count(warning_count), _owner(owner)
-{
-  if (options && options->get_bool("key_by_index", false))
-    _key_by_index = true;
-
-  // Info may be NULL so validation is needed
-  if (info)
-    _info.assign(info);
-
-  add_method("nextResult", boost::bind(&Base_resultset::next_result, this, _1), NULL);
-  add_method("next", boost::bind(&Base_resultset::next, this, _1), NULL);
-  add_method("all", boost::bind(&Base_resultset::fetch_all, this, _1), NULL);
-  add_method("getColumnMetadata", boost::bind(&Base_resultset::get_metadata, this, _1), NULL);
-  add_method("__paged_output__", boost::bind(&Base_resultset::print, this, _1), NULL);
-  add_method("affectedRows", boost::bind(&Base_resultset::affected_rows, this, _1), NULL);
-  add_method("fetchedRowCount", boost::bind(&Base_resultset::fetched_row_count, this, _1), NULL);
-  add_method("warningCount", boost::bind(&Base_resultset::warning_count, this, _1), NULL);
-  add_method("executionTime", boost::bind(&Base_resultset::execution_time, this, _1), NULL);
-}
-
-shcore::Value Base_resultset::next(const shcore::Argument_list &args)
-{
-  std::string function = class_name() + "::next";
-  bool raw = false;
-
-  args.ensure_count(0, 1, function.c_str());
-
-  if (args.size() == 1)
-    raw = args.bool_at(0);
-
-  std::auto_ptr<Base_row> row(next_row());
-
-  // Returns either the row as data_array, document or NULL
-  return row.get() ? raw ? row->as_data_array() : row->as_document() : shcore::Value::Null();
-}
-
-shcore::Value Base_resultset::next_result(const shcore::Argument_list &args)
-{
-  return shcore::Value(next_result());
-}
-
-bool Base_resultset::next_result()
-{
-  boost::shared_ptr<Base_connection> owner = _owner.lock();
-  if (owner)
-    return owner->next_result(this);
-  else
-    return false;
-}
-
-shcore::Value Base_resultset::get_metadata(const shcore::Argument_list &args)
-{
-  std::string function = class_name() + "::get_metadata";
-
-  args.ensure_count(0, function.c_str());
-
-  boost::shared_ptr<shcore::Value::Array_type> array(new shcore::Value::Array_type);
-  int num_fields = _metadata.size();
-
-  for (int i = 0; i < num_fields; i++)
-  {
-    boost::shared_ptr<shcore::Value::Map_type> map(new shcore::Value::Map_type);
-
-    (*map)["catalog"] = shcore::Value(_metadata[i].catalog());
-    (*map)["db"] = shcore::Value(_metadata[i].db());
-    (*map)["table"] = shcore::Value(_metadata[i].table());
-    (*map)["org_table"] = shcore::Value(_metadata[i].org_table());
-    (*map)["name"] = shcore::Value(_metadata[i].name());
-    (*map)["org_name"] = shcore::Value(_metadata[i].org_name());
-    (*map)["charset"] = shcore::Value(int(_metadata[i].charset()));
-    (*map)["length"] = shcore::Value(int(_metadata[i].length()));
-    (*map)["type"] = shcore::Value(int(_metadata[i].type()));
-    (*map)["flags"] = shcore::Value(int(_metadata[i].flags()));
-    (*map)["decimal"] = shcore::Value(int(_metadata[i].decimals()));
-
-    array->push_back(shcore::Value(map));
-  }
-
-  return shcore::Value(array);
-}
-
-shcore::Value Base_resultset::fetch_all(const shcore::Argument_list &args)
-{
-  std::string function = class_name() + "::all";
-
-  args.ensure_count(0, 1, function.c_str());
-
-  bool raw = false;
-
-  if (args.size() == 1)
-    raw = args.bool_at(0);
-
-  Base_row* row = NULL;
-
-  boost::shared_ptr<shcore::Value::Array_type> array(new shcore::Value::Array_type);
-
-  while ((row = next_row()))
-  {
-    array->push_back(raw ? row->as_data_array() : row->as_document());
-    delete row;
-  }
-
-  return shcore::Value(array);
-}
-
-Base_row::Base_row(std::vector<Field>* metadata) :_fields(metadata)
-{
-  _key_by_index = false;
-}
-
-shcore::Value Base_row::as_document()
-{
-  boost::shared_ptr<shcore::Value::Map_type> map;
-  if (_fields)
-  {
-    map.reset(new shcore::Value::Map_type);
-
-    int num_fields = _fields->size();
-
-    for (int i = 0; i < num_fields; i++)
-    {
-      std::string key = _key_by_index ? (boost::format("%i") % i).str() : (*_fields)[i].name();
-
-      (*map)[key] = get_value(i);
-    }
-  }
-  else
-    throw shcore::Exception::logic_error("Metadata is required to create row document.");
-
-  return shcore::Value(map);
-}
-
-shcore::Value Base_row::as_data_array()
-{
-  boost::shared_ptr<shcore::Value::Array_type> array;
-  if (_fields)
-  {
-    array.reset(new shcore::Value::Array_type);
-
-    int num_fields = _fields->size();
-
-    for (int i = 0; i < num_fields; i++)
-    {
-      array->push_back(get_value(i));
-    }
-  }
-  else
-    throw shcore::Exception::logic_error("Metadata is required to create row data array.");
-
-  return shcore::Value(array);
-}
-
-std::vector<std::string> Base_resultset::get_members() const
-{
-  std::vector<std::string> members(shcore::Cpp_object_bridge::get_members());
-  members.push_back("fetched_row_count");
-  members.push_back("affected_rows");
-  members.push_back("warning_count");
-  members.push_back("info");
-  members.push_back("execution_time");
-  return members;
-}
-
-bool Base_resultset::operator == (const Object_bridge &other) const
-{
-  return this == &other;
-}
-
-shcore::Value Base_resultset::fetched_row_count(const shcore::Argument_list &args)
-{
-  return get_member("fetched_row_count");
-}
-
-shcore::Value Base_resultset::affected_rows(const shcore::Argument_list &args)
-{
-  return get_member("affected_rows");
-}
-
-shcore::Value Base_resultset::warning_count(const shcore::Argument_list &args)
-{
-  return get_member("warning_count");
-}
-
-shcore::Value Base_resultset::execution_time(const shcore::Argument_list &args)
-{
-  return get_member("execution_time");
-}
-
-shcore::Value Base_resultset::get_member(const std::string &prop) const
-{
-  if (prop == "fetched_row_count")
-  {
-    return shcore::Value((int64_t)_fetched_row_count);
-  }
-  if (prop == "affected_rows")
-  {
-    return shcore::Value((int64_t)((_affected_rows == ~(my_ulonglong)0) ? 0 : _affected_rows));
-  }
-  if (prop == "warning_count")
-  {
-    return shcore::Value(_warning_count);
-  }
-  if (prop == "info")
-  {
-    return shcore::Value(_info);
-  }
-  if (prop == "execution_time")
-  {
-    return shcore::Value(MySQL_timer::format_legacy(_raw_duration, true));
-  }
-
-  return shcore::Cpp_object_bridge::get_member(prop);
-}
-
-shcore::Value Base_resultset::print(const shcore::Argument_list &args)
-{
-  std::string function = class_name() + "::print";
-
-  args.ensure_count(0, 1, function.c_str());
-
-  std::string format;
-  if (args.size() > 0)
-    format = args.string_at(0);
-
-  if (format == "json")
-    print_json();
-  else
-    print_normal();
-
-  return shcore::Value();
-}
-
-void Base_resultset::print_json()
-{
-  shcore::Value::Map_type_ref data(new shcore::Value::Map_type);
-
-  if (has_resultset())
-  {
-    shcore::Argument_list args;
-    args.push_back(shcore::Value::False());
-    shcore::Value records = fetch_all(args);
-
-    (*data)["row_count"] = Value(int64_t(_fetched_row_count));
-    (*data)["rows"] = records;
-  }
-  else
-  {
-    (*data)["affected_rows"] = Value(int64_t(_affected_rows));
-  }
-
-  (*data)["duration"] = Value(MySQL_timer::format_legacy(_raw_duration, true));
-  (*data)["warning_count"] = Value(_warning_count);
-  (*data)["info"] = Value(_info);
-
-  if (_warning_count)
-    (*data)["warnings"] = get_warnings(false);
-
-  shcore::Value map(data);
-
-  shcore::print(map.repr() + "\n");
-}
-
-void Base_resultset::print_normal()
-{
-  std::string output;
-
-  do
-  {
-    if (has_resultset())
-    {
-      shcore::Argument_list args;
-      args.push_back(shcore::Value::True());
-      shcore::Value records = fetch_all(args);
-      shcore::Value::Array_type_ref array_records = records.as_array();
-
-      // Gets the first row to determine there is data to print
-      // Base_row * row = next_row();
-
-      if (array_records->size())
-      {
-        // print rows from result, with stats etc
-        print_table(array_records);
-
-        output = (boost::format("%lld %s in set") % _fetched_row_count % (_fetched_row_count == 1 ? "row" : "rows")).str();
-      }
-      else
-        output = "Empty set";
-    }
-    else
-    {
-      // Some queries return -1 since affected rows do not apply to them
-      if (_affected_rows == ~(my_ulonglong)0)
-        output = "Query OK";
-      else
-        // In case of Query OK, prints the actual number of affected rows.
-        output = (boost::format("Query OK, %lld %s affected") % _affected_rows % (_affected_rows == 1 ? "row" : "rows")).str();
-    }
-
-    if (_warning_count)
-      output.append((boost::format(", %d warning%s") % _warning_count % (_warning_count == 1 ? "" : "s")).str());
-
-    output.append(" ");
-    output.append((boost::format("(%s)") % MySQL_timer::format_legacy(_raw_duration, true)).str());
-    output.append("\n\n");
-
-    shcore::print(output);
-
-    if (!_info.empty())
-    {
-      shcore::print(_info + "\n\n");
-    }
-
-    // Prints the warnings if there were any
-    if (_warning_count)
-      print_warnings();
-  } while (next_result());
-}
-
-void Base_resultset::print_table(shcore::Value::Array_type_ref records)
-{
-  //---------
-  // Calculates the real field lengths
-  size_t row_index;
-  for (row_index = 0; row_index < records->size(); row_index++)
-  {
-    shcore::Value::Array_type_ref record = (*records)[row_index].as_array();
-
-    for (int field_index = 0; field_index < _metadata.size(); field_index++)
-    {
-      int field_length = (*record)[field_index].repr().length();
-      if (field_length > _metadata[field_index].max_length())
-        _metadata[field_index].max_length(field_length);
-    }
-  }
-  //-----------
-
-  unsigned int index = 0;
-  unsigned int field_count = _metadata.size();
-  std::vector<std::string> formats(field_count, "%-");
-
-  // Calculates the max column widths and constructs the separator line.
-  std::string separator("+");
-  for (index = 0; index < field_count; index++)
-  {
-    unsigned int max_field_length = 0;
-    max_field_length = std::max<unsigned int>(_metadata[index].max_length(), _metadata[index].name_length());
-    max_field_length = std::max<unsigned int>(max_field_length, MIN_COLUMN_LENGTH);
-    _metadata[index].max_length(max_field_length);
-
-    // Creates the format string to print each field
-    formats[index].append(boost::lexical_cast<std::string>(max_field_length));
-    if (index == field_count - 1)
-      formats[index].append("s |");
-    else
-      formats[index].append("s | ");
-    std::string field_separator(max_field_length + 2, '-');
-    field_separator.append("+");
-    separator.append(field_separator);
-  }
-  separator.append("\n");
-
-  // Prints the initial separator line and the column headers
-  // TODO: Consider the charset information on the length calculations
-  shcore::print(separator + "| ");
-  for (index = 0; index < field_count; index++)
-  {
-    std::string data = (boost::format(formats[index]) % _metadata[index].name()).str();
-    shcore::print(data);
-
-    // Once the header is printed, updates the numeric fields formats
-    // so they are right aligned
-    if (IS_NUM(_metadata[index].type()))
-      formats[index] = formats[index].replace(1, 1, "");
-  }
-
-  shcore::print("\n" + separator);
-
-  // Now prints the records
-  for (row_index = 0; row_index < records->size(); row_index++)
-  {
-    shcore::print("| ");
-
-    shcore::Value::Array_type_ref record = (*records)[row_index].as_array();
-
-    for (size_t field_index = 0; field_index < _metadata.size(); field_index++)
-    {
-      std::string raw_value = (*record)[field_index].descr();
-      std::string data = (boost::format(formats[field_index]) % (raw_value)).str();
-
-      shcore::print(data);
-    }
-    shcore::print("\n");
-  }
-
-  shcore::print(separator);
-}
-
-shcore::Value Base_resultset::get_warnings(bool by_index)
-{
-  Value ret_val;
-
-  Value::Map_type_ref options(new shcore::Value::Map_type);
-  (*options)["key_by_index"] = Value(by_index);
-
-  boost::shared_ptr<Base_connection> conn = _owner.lock();
-  if (conn)
-  {
-    Value result_wrapper = conn->sql("show warnings", shcore::Value(options));
-
-    if (result_wrapper)
-    {
-      boost::shared_ptr<mysh::Base_resultset> result = result_wrapper.as_object<mysh::Base_resultset>();
-      shcore::Argument_list args;
-      args.push_back(Value::False());
-      ret_val = result->fetch_all(args);
-    }
-  }
-  return ret_val;
-}
-
-void Base_resultset::print_warnings()
-{
-  Value warnings = get_warnings();
-
-  if (warnings)
-  {
-    Value::Array_type_ref warning_list = warnings.as_array();
-    size_t index = 0, size = warning_list->size();
-
-    while (index < size)
-    {
-      Value record = warning_list->at(index);
-      boost::shared_ptr<Value::Map_type> row = record.as_map();
-
-      unsigned long error = ((*row)["1"].as_int());
-
-      std::string type = (*row)["0"].as_string();
-      std::string msg = (*row)["2"].as_string();
-      shcore::print((boost::format("%s (Code %ld): %s\n") % type % error % msg).str());
-
-      index++;
-    }
-  }
-}
\ No newline at end of file
diff --git a/modules/mod_connection.h b/modules/mod_connection.h
deleted file mode 100644
index 79449303f5424360aab10599082f419063082811..0000000000000000000000000000000000000000
--- a/modules/mod_connection.h
+++ /dev/null
@@ -1,192 +0,0 @@
-/*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; version 2 of the
- * License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#ifndef _MOD_CONNECTION_H_
-#define _MOD_CONNECTION_H_
-
-#include "mod_common.h"
-#include "shellcore/types.h"
-#include "shellcore/types_cpp.h"
-#include "../utils/utils_time.h"
-
-#include <boost/enable_shared_from_this.hpp>
-
-namespace shcore
-{
-  class Shell_core;
-  class Proxy_object;
-};
-
-namespace mysh
-{
-  bool MOD_PUBLIC parse_mysql_connstring(const std::string &connstring,
-                                     std::string &protocol, std::string &user, std::string &password,
-                                     std::string &host, int &port, std::string &sock,
-                                     std::string &db, int &pwd_found);
-  std::string MOD_PUBLIC strip_password(const std::string &connstring);
-  class Base_resultset;
-  class MOD_PUBLIC Base_connection : public shcore::Cpp_object_bridge
-  {
-  public:
-    Base_connection(const std::string &uri, const char *password = NULL);
-
-    // Methods from Cpp_object_bridge will be defined here
-    // Since all the connections will expose the same members
-    virtual bool operator == (const Object_bridge &other) const;
-
-    virtual std::string &append_descr(std::string &s_out, int indent = -1, int quote_strings = 0) const;
-    virtual std::string &append_repr(std::string &s_out) const;
-
-    virtual std::vector<std::string> get_members() const;
-    virtual shcore::Value get_member(const std::string &prop) const;
-
-    // set_member should be implemented in case there are write properties
-    //virtual void set_member(const std::string &prop, shcore::Value value);
-
-    virtual shcore::Value close(const shcore::Argument_list &args) = 0;
-    virtual shcore::Value sql(const std::string &sql, shcore::Value options) = 0;
-    virtual shcore::Value sql_one(const std::string &sql) = 0;
-    virtual bool next_result(Base_resultset *target, bool first_result = false) = 0;
-
-    virtual shcore::Value sql_(const shcore::Argument_list &args);
-    virtual shcore::Value sql_one_(const shcore::Argument_list &args);
-
-    std::string uri() const { return _uri; }
-
-  protected:
-    MySQL_timer _timer;
-  private:
-    std::string _uri;
-    std::string _pwd;
-  };
-
-  class MOD_PUBLIC Field
-  {
-  public:
-    Field(const std::string& catalog, const std::string& db, const std::string& table, const std::string& otable, const std::string& name, const std::string& oname, int length, int type, int flags, int decimals, int charset);
-
-    const std::string& catalog() { return _catalog; };
-    const std::string& db() { return _db; };
-    const std::string& table() { return _table; };
-    const std::string& org_table() { return _org_table; };
-    const std::string& name() { return _name; };
-    const std::string& org_name() { return _org_name; };
-    const unsigned int length() { return _length; }
-    const unsigned int type() { return _type; }
-    const unsigned int flags() { return _flags; }
-    const unsigned int decimals() { return _decimals; }
-    const unsigned int charset() { return _charset; }
-
-    const unsigned int max_length() { return _max_length; }
-    void max_length(int length) { _max_length = length; }
-
-    const unsigned int name_length() { return _name_length; }
-
-  private:
-    std::string _catalog;
-    std::string _db;
-    std::string _table;
-    std::string _org_table;
-    std::string _name;
-    std::string _org_name;
-    unsigned long _length;
-    unsigned int _type;
-    unsigned int _flags;
-    unsigned int _decimals;
-    unsigned int _charset;
-
-    unsigned long _max_length;
-    unsigned long _name_length;
-  };
-
-  class Base_row
-  {
-  public:
-    Base_row(std::vector<Field>* metadata = NULL);
-    virtual ~Base_row(){}
-    virtual shcore::Value get_value(int index) = 0;
-    virtual std::string get_value_as_string(int index) = 0;
-    shcore::Value as_document();
-    shcore::Value as_data_array();
-
-    void set_key_by_index(bool value) { _key_by_index = value; }
-  protected:
-    bool _key_by_index;
-    std::vector<Field>* _fields;
-  };
-
-  class Base_resultset : public shcore::Cpp_object_bridge
-  {
-  public:
-    Base_resultset(boost::shared_ptr<Base_connection> owner, uint64_t affected_rows, uint64_t last_insert_id, int warning_count, const char* info, boost::shared_ptr<shcore::Value::Map_type> options = boost::shared_ptr<shcore::Value::Map_type>());
-
-    // Methods from Cpp_object_bridge will be defined here
-    // Since all the connections will expose the same members
-    virtual std::vector<std::string> get_members() const;
-    virtual shcore::Value get_member(const std::string &prop) const;
-    virtual bool operator == (const Object_bridge &other) const;
-
-    // Retrieves the metadata for an executed statement
-    // Returns -1 in case of error or the number of records loaded
-    virtual int fetch_metadata() = 0;
-
-    // Business logic methods common to all connections
-    bool has_rows();
-    bool has_resultset() { return _has_resultset; };
-    int warning_count() { return _warning_count; }
-    shcore::Value print(const shcore::Argument_list &args);
-    virtual shcore::Value next(const shcore::Argument_list &args);
-    shcore::Value next_result(const shcore::Argument_list &args);
-    shcore::Value get_metadata(const shcore::Argument_list &args);
-    virtual shcore::Value fetch_all(const shcore::Argument_list &args);
-    shcore::Value affected_rows(const shcore::Argument_list &args);
-    shcore::Value fetched_row_count(const shcore::Argument_list &args);
-    shcore::Value warning_count(const shcore::Argument_list &args);
-    shcore::Value execution_time(const shcore::Argument_list &args);
-
-  private:
-    void print_json();
-    void print_normal();
-    void print_table(shcore::Value::Array_type_ref records);
-    shcore::Value get_warnings(bool by_index = true);
-    void print_warnings();
-
-  protected:
-    // Methods requiring database interaction, must be
-    // defined by the subclasses
-    virtual Base_row *next_row() = 0;
-    bool next_result();
-
-    boost::weak_ptr<Base_connection> _owner;
-
-    bool _key_by_index;
-    std::vector<Field> _metadata;
-
-    bool _has_resultset;  // Indicates active result is result from a query statement
-    int _fetched_row_count;       // Returns the number of read records
-
-    unsigned long _raw_duration;
-    uint64_t _affected_rows;
-    uint64_t _last_insert_id;
-    std::string _info;
-    int _warning_count;
-  };
-};
-
-#endif
diff --git a/modules/mod_crud_collection_add.cc b/modules/mod_crud_collection_add.cc
index 53d8369d5e4cd30a0b84f01b626f5b700bd19f5b..722dcc02631c28f6ecaf3210317fe4f5f214f053 100644
--- a/modules/mod_crud_collection_add.cc
+++ b/modules/mod_crud_collection_add.cc
@@ -18,31 +18,21 @@
  */
 #include <boost/bind.hpp>
 #include "mod_crud_collection_add.h"
+#include "mod_mysqlx_resultset.h"
 
-using namespace mysh;
+using namespace mysh::mysqlx;
 using namespace shcore;
 
-CollectionAdd::CollectionAdd(const shcore::Argument_list &args) :
-Crud_definition(args)
+CollectionAdd::CollectionAdd(const ::mysqlx::AddStatement &add)
+: _add(new ::mysqlx::AddStatement(add))
 {
-  // _conn, schema, collection
-  args.ensure_count(3, "CollectionAdd");
-
-  std::string path;
-  _data.reset(new shcore::Value::Map_type());
-  (*_data)["data_model"] = Value(Mysqlx::Crud::DOCUMENT);
-  (*_data)["schema"] = args[1];
-  (*_data)["collection"] = args[2];
-
   // Exposes the methods available for chaining
   add_method("add", boost::bind(&CollectionAdd::add, this, _1), "data");
-  add_method("bind", boost::bind(&CollectionAdd::bind, this, _1), "data");
   add_method("execute", boost::bind(&Crud_definition::execute, this, _1), "data");
 
   // Registers the dynamic function behavior
   register_dynamic_function("add", "");
-  register_dynamic_function("bind", "add, addDocuments");
-  register_dynamic_function("execute", "addDocuments, bind");
+  register_dynamic_function("execute", "add");
 
   // Initial function update
   update_functions("");
@@ -51,38 +41,19 @@ Crud_definition(args)
 shcore::Value CollectionAdd::add(const shcore::Argument_list &args)
 {
   // Each method validates the received parameters
-  args.ensure_count(0, 1, "CollectionAdd::add");
+  args.ensure_count(1, "CollectionAdd::add");
 
-  // default path is with no arguments
-  std::string path;
-  if (args.size())
-  {
-    path = "Documents";
-    (*_data)[path] = args[0];
-  }
+  _add->add(::mysqlx::Document(args.string_at(0)));
 
   // Updates the exposed functions
-  update_functions("add" + path);
+  update_functions("add");
 
   return Value(Object_bridge_ref(this));
 }
 
-shcore::Value CollectionAdd::bind(const shcore::Argument_list &args)
+shcore::Value CollectionAdd::execute(const shcore::Argument_list &args)
 {
-  // TODO: Logic to determine the kind of parameter passed
-  //       Should end up adding one of the next to the data dictionary:
-  //       - ValuesAndnestedFinds
-  //       - ParamsValuesAndNestedFinds
-  //       - IteratorObject
-
-  // Updates the exposed functions
-  update_functions("bind");
+  args.ensure_count(0, "CollectionAdd::execute");
 
-  return Value(Object_bridge_ref(this));
-}
-
-boost::shared_ptr<shcore::Object_bridge> CollectionAdd::create(const shcore::Argument_list &args)
-{
-  args.ensure_count(3, 4, "CollectionAdd()");
-  return boost::shared_ptr<shcore::Object_bridge>(new CollectionAdd(args));
+  return shcore::Value::wrap(new mysqlx::Collection_resultset(boost::shared_ptr< ::mysqlx::Result>(_add->execute())));
 }
\ No newline at end of file
diff --git a/modules/mod_crud_collection_add.h b/modules/mod_crud_collection_add.h
index 4d069672c8c65b1d1c93855e9b49c667d2c347b0..2165dc4a4398006a32a348e6dd3fd6e1f4453356 100644
--- a/modules/mod_crud_collection_add.h
+++ b/modules/mod_crud_collection_add.h
@@ -24,19 +24,26 @@
 #define _MOD_CRUD_COLLECTION_ADD_H_
 
 #include "crud_definition.h"
+#include "mysqlx_crud.h"
 
 namespace mysh
 {
-  class CollectionAdd : public Crud_definition
+  namespace mysqlx
   {
-  public:
-    CollectionAdd(const shcore::Argument_list &args);
-  public:
-    virtual std::string class_name() const { return "CollectionAdd"; }
-    static boost::shared_ptr<shcore::Object_bridge> create(const shcore::Argument_list &args);
-    shcore::Value add(const shcore::Argument_list &args);
-    shcore::Value bind(const shcore::Argument_list &args);
-  };
-};
+    class CollectionAdd : public Crud_definition
+    {
+    public:
+      CollectionAdd(const ::mysqlx::AddStatement &add);
+    public:
+      virtual std::string class_name() const { return "CollectionAdd"; }
+      shcore::Value add(const shcore::Argument_list &args);
+
+      virtual shcore::Value execute(const shcore::Argument_list &args);
+      ::mysqlx::AddStatement *stmt() { return _add.get(); }
+    private:
+      std::auto_ptr< ::mysqlx::AddStatement> _add;
+    };
+  }
+}
 
 #endif
diff --git a/modules/mod_crud_collection_find.cc b/modules/mod_crud_collection_find.cc
index 0fafb5cb1cf1d0e4c3c591bfdca826fe1fef80c9..16fbb75a55c451f6c14c22630d18c009fb66157f 100644
--- a/modules/mod_crud_collection_find.cc
+++ b/modules/mod_crud_collection_find.cc
@@ -19,20 +19,20 @@
 #include <boost/bind.hpp>
 #include "mod_crud_collection_find.h"
 
-using namespace mysh;
+using namespace mysh::mysqlx;
 using namespace shcore;
 
 CollectionFind::CollectionFind(const shcore::Argument_list &args) :
-Crud_definition(args)
+Crud_definition()
 {
   // _conn, schema, collection
-  args.ensure_count(3, "CollectionFind");
+  /*  args.ensure_count(3, "CollectionFind");
 
-  std::string path;
-  _data.reset(new shcore::Value::Map_type());
-  (*_data)["data_model"] = Value(Mysqlx::Crud::DOCUMENT);
-  (*_data)["schema"] = args[1];
-  (*_data)["collection"] = args[2];
+    std::string path;
+    _data.reset(new shcore::Value::Map_type());
+    (*_data)["data_model"] = Value(Mysqlx::Crud::DOCUMENT);
+    (*_data)["schema"] = args[1];
+    (*_data)["collection"] = args[2];*/
 
   // Exposes the methods available for chaining
   add_method("find", boost::bind(&CollectionFind::find, this, _1), "data");
@@ -123,7 +123,7 @@ shcore::Value CollectionFind::skip(const shcore::Argument_list &args)
   if (args[0].type != shcore::Integer)
     throw shcore::Exception::argument_error("CollectionFind::skip: integer parameter required.");
 
-  (*_data)["LimitOffset"] = args[0];
+  //(*_data)["LimitOffset"] = args[0];
 
   update_functions("skip");
 
@@ -137,7 +137,7 @@ shcore::Value CollectionFind::limit(const shcore::Argument_list &args)
   if (args[0].type != shcore::Integer)
     throw shcore::Exception::argument_error("CollectionFind::limit: integer parameter required.");
 
-  (*_data)["NumberOfRows"] = args[0];
+  //(*_data)["NumberOfRows"] = args[0];
 
   update_functions("limit");
 
diff --git a/modules/mod_crud_collection_find.h b/modules/mod_crud_collection_find.h
index 3ee0854931f8d960f2d19664a1ac82a289a33001..f8e821a09e38684dc95d34e6a74f6db692430c39 100644
--- a/modules/mod_crud_collection_find.h
+++ b/modules/mod_crud_collection_find.h
@@ -24,24 +24,34 @@
 #define _MOD_CRUD_COLLECTION_FIND_H_
 
 #include "crud_definition.h"
+#include "mysqlx_crud.h"
 
 namespace mysh
 {
-  class CollectionFind : public Crud_definition
+  namespace mysqlx
   {
-  public:
-    CollectionFind(const shcore::Argument_list &args);
-  public:
-    virtual std::string class_name() const { return "CollectionFind"; }
-    static boost::shared_ptr<shcore::Object_bridge> create(const shcore::Argument_list &args);
-    shcore::Value find(const shcore::Argument_list &args);
-    shcore::Value fields(const shcore::Argument_list &args);
-    shcore::Value group_by(const shcore::Argument_list &args);
-    shcore::Value having(const shcore::Argument_list &args);
-    shcore::Value sort(const shcore::Argument_list &args);
-    shcore::Value skip(const shcore::Argument_list &args);
-    shcore::Value limit(const shcore::Argument_list &args);
-    shcore::Value bind(const shcore::Argument_list &args);
+    class CollectionFind : public Crud_definition
+    {
+    public:
+      CollectionFind(const shcore::Argument_list &args);
+    public:
+      virtual std::string class_name() const { return "CollectionFind"; }
+      static boost::shared_ptr<shcore::Object_bridge> create(const shcore::Argument_list &args);
+      shcore::Value find(const shcore::Argument_list &args);
+      shcore::Value fields(const shcore::Argument_list &args);
+      shcore::Value group_by(const shcore::Argument_list &args);
+      shcore::Value having(const shcore::Argument_list &args);
+      shcore::Value sort(const shcore::Argument_list &args);
+      shcore::Value skip(const shcore::Argument_list &args);
+      shcore::Value limit(const shcore::Argument_list &args);
+      shcore::Value bind(const shcore::Argument_list &args);
+
+      virtual shcore::Value execute(const shcore::Argument_list &args);
+
+      ::mysqlx::FindStatement *stmt() { return _find.get(); }
+    private:
+      std::auto_ptr< ::mysqlx::FindStatement> _find;
+    };
   };
 };
 
diff --git a/modules/mod_crud_collection_remove.cc b/modules/mod_crud_collection_remove.cc
index 4d67368edddf769d6f7b3c6b649c4740ee3a0c9f..c3586153abd825716402516a4a593adf13038289 100644
--- a/modules/mod_crud_collection_remove.cc
+++ b/modules/mod_crud_collection_remove.cc
@@ -19,20 +19,20 @@
 #include <boost/bind.hpp>
 #include "mod_crud_collection_remove.h"
 
-using namespace mysh;
+using namespace mysh::mysqlx;
 using namespace shcore;
 
 CollectionRemove::CollectionRemove(const shcore::Argument_list &args) :
-Crud_definition(args)
+Crud_definition()
 {
   // _conn, schema, collection
   args.ensure_count(3, "CollectionRemove");
 
-  std::string path;
+  /*std::string path;
   _data.reset(new shcore::Value::Map_type());
   (*_data)["data_model"] = Value(Mysqlx::Crud::DOCUMENT);
   (*_data)["schema"] = args[1];
-  (*_data)["collection"] = args[2];
+  (*_data)["collection"] = args[2];*/
 
   // Exposes the methods available for chaining
   add_method("remove", boost::bind(&CollectionRemove::remove, this, _1), "data");
@@ -88,7 +88,7 @@ shcore::Value CollectionRemove::limit(const shcore::Argument_list &args)
   if (args[0].type != shcore::Integer)
     throw shcore::Exception::argument_error("CollectionRemove::limit: integer parameter required.");
 
-  (*_data)["NumberOfRows"] = args[0];
+  //(*_data)["NumberOfRows"] = args[0];
 
   update_functions("limit");
 
@@ -101,9 +101,9 @@ shcore::Value CollectionRemove::bind(const shcore::Argument_list &args)
 
   return Value(Object_bridge_ref(this));
 }
-
+/*
 boost::shared_ptr<shcore::Object_bridge> CollectionRemove::create(const shcore::Argument_list &args)
 {
-  args.ensure_count(3, 4, "CollectionRemove()");
-  return boost::shared_ptr<shcore::Object_bridge>(new CollectionRemove(args));
-}
\ No newline at end of file
+args.ensure_count(3, 4, "CollectionRemove()");
+return boost::shared_ptr<shcore::Object_bridge>(new CollectionRemove(args));
+}*/
\ No newline at end of file
diff --git a/modules/mod_crud_collection_remove.h b/modules/mod_crud_collection_remove.h
index 0147cc4acc9829e907f8760a7967a8e1ddc7d804..eed2e5c21e4ac219462e9afc10f8baf39dbcb26f 100644
--- a/modules/mod_crud_collection_remove.h
+++ b/modules/mod_crud_collection_remove.h
@@ -27,17 +27,20 @@
 
 namespace mysh
 {
-  class CollectionRemove : public Crud_definition
+  namespace mysqlx
   {
-  public:
-    CollectionRemove(const shcore::Argument_list &args);
-  public:
-    virtual std::string class_name() const { return "CollectionRemove"; }
-    static boost::shared_ptr<shcore::Object_bridge> create(const shcore::Argument_list &args);
-    shcore::Value remove(const shcore::Argument_list &args);
-    shcore::Value order_by(const shcore::Argument_list &args);
-    shcore::Value limit(const shcore::Argument_list &args);
-    shcore::Value bind(const shcore::Argument_list &args);
+    class CollectionRemove : public Crud_definition
+    {
+    public:
+      CollectionRemove(const shcore::Argument_list &args);
+    public:
+      virtual std::string class_name() const { return "CollectionRemove"; }
+      static boost::shared_ptr<shcore::Object_bridge> create(const shcore::Argument_list &args);
+      shcore::Value remove(const shcore::Argument_list &args);
+      shcore::Value order_by(const shcore::Argument_list &args);
+      shcore::Value limit(const shcore::Argument_list &args);
+      shcore::Value bind(const shcore::Argument_list &args);
+    };
   };
 };
 
diff --git a/modules/mod_crud_table_insert.cc b/modules/mod_crud_table_insert.cc
index 0aa229a7ace8675046f1ec73cd5b35933263d7e4..2d8c0e58255625a567900530c03814eaf067e7ce 100644
--- a/modules/mod_crud_table_insert.cc
+++ b/modules/mod_crud_table_insert.cc
@@ -19,7 +19,7 @@
 #include <boost/bind.hpp>
 #include "mod_crud_table_insert.h"
 
-using namespace mysh;
+using namespace mysh::mysqlx;
 using namespace shcore;
 
 /*
@@ -32,15 +32,15 @@ using namespace shcore;
 * - Message information that is not provided through the different functions
 */
 TableInsert::TableInsert(const shcore::Argument_list &args) :
-Crud_definition(args)
+Crud_definition()
 {
   args.ensure_count(3, "TableInsert");
 
-  std::string path;
+  /*std::string path;
   _data.reset(new shcore::Value::Map_type());
   (*_data)["data_model"] = shcore::Value(Mysqlx::Crud::TABLE);
   (*_data)["schema"] = args[1];
-  (*_data)["collection"] = args[2];
+  (*_data)["collection"] = args[2];*/
 
   // The values function should not be enabled if values were already given
   add_method("insert", boost::bind(&TableInsert::insert, this, _1), "data");
@@ -78,7 +78,7 @@ shcore::Value TableInsert::insert(const shcore::Argument_list &args)
     }
 
     // Stores the data
-    (*_data)[path] = args[0];
+    //(*_data)[path] = args[0];
   }
 
   // Updates the exposed functions
@@ -93,7 +93,7 @@ shcore::Value TableInsert::values(const shcore::Argument_list &args)
   args.ensure_count(1, "TableInsert::values");
 
   // Adds the parameters to the data map
-  (*_data)["Values"] = args[0];
+  //(*_data)["Values"] = args[0];
 
   // Updates the exposed functions
   update_functions("values");
@@ -116,8 +116,8 @@ shcore::Value TableInsert::bind(const shcore::Argument_list &args)
   return Value(Object_bridge_ref(this));
 }
 
-boost::shared_ptr<shcore::Object_bridge> TableInsert::create(const shcore::Argument_list &args)
+/*boost::shared_ptr<shcore::Object_bridge> TableInsert::create(const shcore::Argument_list &args)
 {
-  args.ensure_count(3, 4, "TableInsert()");
-  return boost::shared_ptr<shcore::Object_bridge>(new TableInsert(args));
-}
\ No newline at end of file
+args.ensure_count(3, 4, "TableInsert()");
+return boost::shared_ptr<shcore::Object_bridge>(new TableInsert(args));
+}*/
\ No newline at end of file
diff --git a/modules/mod_crud_table_insert.h b/modules/mod_crud_table_insert.h
index 000fc36a5a326cf0ba9ff8b9b384af6d9bfcf2e9..6508344bf64f5645c8541829dd0e540ec5050ce2 100644
--- a/modules/mod_crud_table_insert.h
+++ b/modules/mod_crud_table_insert.h
@@ -27,16 +27,19 @@
 
 namespace mysh
 {
-  class TableInsert : public Crud_definition
+  namespace mysqlx
   {
-  public:
-    TableInsert(const shcore::Argument_list &args);
-  public:
-    virtual std::string class_name() const { return "TableInsert"; }
-    static boost::shared_ptr<shcore::Object_bridge> create(const shcore::Argument_list &args);
-    shcore::Value insert(const shcore::Argument_list &args);
-    shcore::Value values(const shcore::Argument_list &args);
-    shcore::Value bind(const shcore::Argument_list &args);
+    class TableInsert : public Crud_definition
+    {
+    public:
+      TableInsert(const shcore::Argument_list &args);
+    public:
+      virtual std::string class_name() const { return "TableInsert"; }
+      static boost::shared_ptr<shcore::Object_bridge> create(const shcore::Argument_list &args);
+      shcore::Value insert(const shcore::Argument_list &args);
+      shcore::Value values(const shcore::Argument_list &args);
+      shcore::Value bind(const shcore::Argument_list &args);
+    };
   };
 };
 
diff --git a/modules/mod_db.cc b/modules/mod_db.cc
deleted file mode 100644
index ac213dd84d613c880ffe62a7f2cfc11234cea28b..0000000000000000000000000000000000000000
--- a/modules/mod_db.cc
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; version 2 of the
- * License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#include "mod_db.h"
-
-#include "shellcore/object_factory.h"
-#include "shellcore/shell_core.h"
-#include "shellcore/lang_base.h"
-
-#include "shellcore/proxy_object.h"
-
-#include "mod_session.h"
-#include "mod_db_table.h"
-
-#include "mod_connection.h"
-
-#include <boost/bind.hpp>
-#include <boost/lexical_cast.hpp>
-#include <boost/format.hpp>
-#include <boost/pointer_cast.hpp>
-
-
-using namespace mysh;
-using namespace shcore;
-
-
-#include <iostream>
-
-
-Db::Db(boost::shared_ptr<Session> session, const std::string &schema)
-: _session(session), _schema(schema)
-{
-}
-
-
-Db::~Db()
-{
-}
-
-
-void Db::cache_table_names()
-{
-  boost::shared_ptr<Session> sess(_session.lock());
-  if (sess)
-  {
-    _tables = Value::new_map().as_map();
-    {
-      Value options(Value::new_map());
-      (*options.as_map())["key_by_index"] = Value::True();
-      Value result = sess->conn()->sql("show tables in `"+_schema+"`", options);
-      Value doc;
-      while ((doc = result.as_object<Base_resultset>()->next(Argument_list())) && doc.type != Null)
-      {
-        std::string table = (*doc.as_map())["0"].as_string();
-        (*_tables)[table] = Value(Object_bridge_ref(new Db_table(shared_from_this(), table)));
-      }
-    }
-  }
-}
-
-
-std::string Db::class_name() const
-{
-  return "Db";
-}
-
-
-std::string &Db::append_descr(std::string &s_out, int indent, int quote_strings) const
-{
-  s_out.append("<Db:"+_schema+">");
-  return s_out;
-}
-
-
-std::string &Db::append_repr(std::string &s_out) const
-{
-  return append_descr(s_out, false);
-}
-
-
-std::vector<std::string> Db::get_members() const
-{
-  std::vector<std::string> members(Cpp_object_bridge::get_members());
-  members.push_back("name");
-  members.push_back("t");
-  members.push_back("session");
-  for (Value::Map_type::const_iterator iter = _tables->begin();
-       iter != _tables->end(); ++iter)
-  {
-    members.push_back(iter->first);
-  }
-  return members;
-}
-
-
-bool Db::operator == (const Object_bridge &other) const
-{
-  if (class_name() == other.class_name())
-  {
-    return _session.lock() == ((Db*)&other)->_session.lock() && _schema == ((Db*)&other)->_schema;
-  }
-  return false;
-}
-
-
-Value Db::get_member(const std::string &prop) const
-{
-  if (prop == "name")
-    return Value(_schema);
-  else if (prop == "session")
-    return Value(boost::static_pointer_cast<Object_bridge>(_session.lock()));
-  else if (prop == "t")
-    return Value(_tables);
-
-  Value::Map_type::const_iterator iter = _tables->find(prop);
-  if (iter == _tables->end())
-  {
-    return Value(boost::shared_ptr<Object_bridge>(new Db_table(const_cast<Db*>(this)->shared_from_this(), prop)));
-  }
-  else
-  {
-    return Value(boost::shared_ptr<Object_bridge>(iter->second.as_object()));
-  }
-}
-
-
-void Db::set_member(const std::string &prop, Value value)
-{
-  Cpp_object_bridge::set_member(prop, value);
-}
-
-
diff --git a/modules/mod_db.h b/modules/mod_db.h
deleted file mode 100644
index f6c4e7d0c0365b81b13af59ea4a5b71358fa28cd..0000000000000000000000000000000000000000
--- a/modules/mod_db.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; version 2 of the
- * License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-// Interactive DB access module
-// (the one exposed as the db variable in the shell)
-
-#ifndef _MOD_DB_H_
-#define _MOD_DB_H_
-
-#include "mod_common.h"
-#include "shellcore/types.h"
-#include "shellcore/types_cpp.h"
-
-#include <boost/enable_shared_from_this.hpp>
-#include <boost/weak_ptr.hpp>
-
-namespace shcore
-{
-  class Proxy_object;
-};
-
-namespace mysh {
-
-class Session;
-class Db_table;
-
-class MOD_PUBLIC Db : public shcore::Cpp_object_bridge, public boost::enable_shared_from_this<Db>
-{
-public:
-  Db(boost::shared_ptr<Session> owner, const std::string &name);
-  ~Db();
-
-  virtual std::string class_name() const;
-  virtual std::string &append_descr(std::string &s_out, int indent=-1, int quote_strings=0) const;
-  virtual std::string &append_repr(std::string &s_out) const;
-  virtual std::vector<std::string> get_members() const;
-  virtual bool operator == (const Object_bridge &other) const;
-  virtual shcore::Value get_member(const std::string &prop) const;
-  virtual void set_member(const std::string &prop, shcore::Value value);
-
-  void cache_table_names();
-
-  boost::weak_ptr<Session> session() const { return _session; }
-
-  std::string schema() const { return _schema; }
-private:
-  boost::weak_ptr<Session> _session;
-  boost::shared_ptr<shcore::Value::Map_type> _tables;
-  boost::shared_ptr<shcore::Value::Map_type> _collections;
-
-  std::string _schema;
-};
-
-};
-
-#endif
diff --git a/modules/mod_db_table.cc b/modules/mod_db_table.cc
deleted file mode 100644
index 2abbd8f645b6749d41f794c931098fb35591f918..0000000000000000000000000000000000000000
--- a/modules/mod_db_table.cc
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; version 2 of the
- * License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#include "mod_db.h"
-#include "mod_db_table.h"
-
-using namespace mysh;
-using namespace shcore;
-
-
-#include <iostream>
-
-
-Db_table::Db_table(boost::shared_ptr<Db> owner, const std::string &name)
-: _owner(owner), _table_name(name)
-{
-}
-
-
-Db_table::~Db_table()
-{
-}
-
-
-std::string Db_table::class_name() const
-{
-  return "Db_table";
-}
-
-std::string &Db_table::append_descr(std::string &s_out, int indent, int quote_strings) const
-{
-  s_out.append("<"+class_name()+":"+_table_name+">");
-  return s_out;
-}
-
-
-std::vector<std::string> Db_table::get_members() const
-{
-  std::vector<std::string> members(Cpp_object_bridge::get_members());
-  members.push_back("insert");
-  members.push_back("update");
-  members.push_back("find");
-  return members;
-}
-
-
-
-Value Db_table::get_member(const std::string &prop) const
-{
-  if (prop == "__name__")
-    return Value(_table_name);
-
-  if (prop == "insert")
-  {
-    shcore::print("not implemented\n");
-  }
-  else if (prop == "update")
-  {
-    shcore::print("not implemented\n");
-  }
-  else if (prop == "find")
-  {
-    shcore::print("not implemented\n");
-  }
-
-  return Cpp_object_bridge::get_member(prop);
-}
-
-
-
-bool Db_table::operator == (const Object_bridge &other) const
-{
-  //XXX there's gotta be a better/safer way to do this
-  if (other.class_name() == class_name())
-    return _owner.lock() == ((const Db_table*)&other)->_owner.lock() && _table_name == ((const Db_table*)&other)->_table_name;
-  return false;
-}
-
diff --git a/modules/mod_db_table.h b/modules/mod_db_table.h
deleted file mode 100644
index 82199b9e39949c18b9dcf5f8a0ef898424e01e4e..0000000000000000000000000000000000000000
--- a/modules/mod_db_table.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; version 2 of the
- * License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-// Interactive Table access module
-// (the one exposed as the table members of the db object in the shell)
-
-#ifndef _MOD_DB_TABLE_H_
-#define _MOD_DB_TABLE_H_
-
-#include "shellcore/types.h"
-#include "shellcore/types_cpp.h"
-
-#include "mod_connection.h"
-
-#include <boost/weak_ptr.hpp>
-
-namespace shcore
-{
-  class Shell_core;
-};
-
-namespace mysh {
-
-class Db;
-
-class Db_table : public shcore::Cpp_object_bridge
-{
-public:
-  Db_table(boost::shared_ptr<Db> owner, const std::string &name);
-  ~Db_table();
-
-  virtual std::string &append_descr(std::string &s_out, int indent, int quote_strings) const;
-
-  virtual std::string class_name() const;
-  virtual std::vector<std::string> get_members() const;
-  virtual shcore::Value get_member(const std::string &prop) const;
-  virtual bool operator == (const Object_bridge &other) const;
-private:
-  boost::weak_ptr<Db> _owner;
-  std::string _table_name;
-};
-
-};
-
-#endif
diff --git a/modules/mod_mysql.cc b/modules/mod_mysql.cc
deleted file mode 100644
index 457d69d5e976cb8c56f6852c0f5722a2b8a9686c..0000000000000000000000000000000000000000
--- a/modules/mod_mysql.cc
+++ /dev/null
@@ -1,328 +0,0 @@
-/*
- * Copyright (c) 2014, 1015, Oracle and/or its affiliates. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; version 2 of the
- * License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#include "mod_mysql.h"
-
-#include "shellcore/obj_date.h"
-
-#include <boost/format.hpp>
-#include <boost/bind.hpp>
-#include <boost/lexical_cast.hpp>
-
-using namespace mysh;
-
-#include <iostream>
-
-#include "shellcore/object_factory.h"
-REGISTER_ALIASED_OBJECT(mysql, Connection, Mysql_connection);
-
-#define MAX_COLUMN_LENGTH 1024
-#define MIN_COLUMN_LENGTH 4
-
-Mysql_resultset::Mysql_resultset(boost::shared_ptr<Mysql_connection> owner, uint64_t affected_rows, int warning_count, const char *info, boost::shared_ptr<shcore::Value::Map_type> options)
-: Base_resultset(owner, affected_rows, _last_insert_id, warning_count, info, options)
-{
-}
-
-int Mysql_resultset::fetch_metadata()
-{
-  int num_fields = 0;
-
-  _metadata.clear();
-
-  // res could be NULL on queries not returning data
-  boost::shared_ptr<MYSQL_RES> res = _result.lock();
-
-  if (res)
-  {
-    num_fields = mysql_num_fields(res.get());
-    MYSQL_FIELD *fields = mysql_fetch_fields(res.get());
-
-    for (int index = 0; index < num_fields; index++)
-    {
-      _metadata.push_back(Field(fields[index].catalog,
-                                fields[index].db,
-                                fields[index].table,
-                                fields[index].org_table,
-                                fields[index].name,
-                                fields[index].org_name,
-                                fields[index].length,
-                                fields[index].type,
-                                fields[index].flags,
-                                fields[index].decimals,
-                                fields[index].charsetnr));
-    }
-  }
-
-  return num_fields;
-}
-
-Mysql_resultset::~Mysql_resultset()
-{
-}
-
-Base_row *Mysql_resultset::next_row()
-{
-  Base_row *ret_val = NULL;
-
-  if (has_resultset())
-  {
-    // Loads the first row
-    boost::shared_ptr<MYSQL_RES> res = _result.lock();
-
-    if (res)
-    {
-      MYSQL_ROW mysql_row = mysql_fetch_row(res.get());
-      if (mysql_row)
-      {
-        unsigned long *lengths;
-        lengths = mysql_fetch_lengths(res.get());
-
-        ret_val = new Mysql_row(mysql_row, lengths, &_metadata);
-        ret_val->set_key_by_index(_key_by_index);
-
-        // Each read row increases the count
-        _fetched_row_count++;
-      }
-    }
-  }
-  return ret_val;
-}
-
-void Mysql_resultset::reset(boost::shared_ptr<MYSQL_RES> res, unsigned long duration)
-{
-  _result = res;
-  _raw_duration = duration;
-
-  _has_resultset = (res != NULL);
-}
-
-Mysql_row::Mysql_row(MYSQL_ROW row, unsigned long *lengths, std::vector<Field>* metadata) : Base_row(metadata), _row(row), _lengths(lengths)
-{
-}
-
-shcore::Value Mysql_row::get_value(int index)
-{
-  if (_row[index] == NULL)
-    return shcore::Value::Null();
-  else
-  {
-    switch ((*_fields)[index].type())
-    {
-      case MYSQL_TYPE_NULL:
-        return shcore::Value::Null();
-      case MYSQL_TYPE_DECIMAL:
-      case MYSQL_TYPE_DATE:
-      case MYSQL_TYPE_TIME:
-      case MYSQL_TYPE_STRING:
-      case MYSQL_TYPE_VARCHAR:
-      case MYSQL_TYPE_VAR_STRING:
-        return shcore::Value(std::string(_row[index], _lengths[index]));
-
-      case MYSQL_TYPE_YEAR:
-      case MYSQL_TYPE_TINY:
-      case MYSQL_TYPE_SHORT:
-      case MYSQL_TYPE_INT24:
-      case MYSQL_TYPE_LONG:
-      case MYSQL_TYPE_LONGLONG:
-        return shcore::Value(boost::lexical_cast<int64_t>(_row[index]));
-
-      case MYSQL_TYPE_FLOAT:
-      case MYSQL_TYPE_DOUBLE:
-        return shcore::Value(boost::lexical_cast<double>(_row[index]));
-        break;
-
-      case MYSQL_TYPE_DATETIME:
-      case MYSQL_TYPE_TIMESTAMP:
-      case MYSQL_TYPE_DATETIME2:
-      case MYSQL_TYPE_TIMESTAMP2:
-        return shcore::Value(shcore::Date::unrepr(_row[index]));
-        break;
-    }
-  }
-
-  return shcore::Value();
-}
-
-std::string Mysql_row::get_value_as_string(int index)
-{
-  return _row[index] ? _row[index] : "NULL";
-}
-
-//----------------------------------------------
-
-Mysql_connection::Mysql_connection(const std::string &uri, const char *password)
-: Base_connection(uri), _mysql(NULL)
-{
-  std::string protocol;
-  std::string user;
-  std::string pass;
-  std::string host;
-  int port = 3306;
-  std::string sock;
-  std::string db;
-  long flags = CLIENT_MULTI_RESULTS;
-  int pwd_found;
-
-  _mysql = mysql_init(NULL);
-
-  if (!parse_mysql_connstring(uri, protocol, user, pass, host, port, sock, db, pwd_found))
-    throw shcore::Exception::argument_error("Could not parse URI for MySQL connection");
-
-  if (password)
-    pass.assign(password);
-
-  unsigned int tcp = MYSQL_PROTOCOL_TCP;
-  mysql_options(_mysql, MYSQL_OPT_PROTOCOL, &tcp);
-  if (!mysql_real_connect(_mysql, host.c_str(), user.c_str(), pass.c_str(), db.empty() ? NULL : db.c_str(), port, sock.empty() ? NULL : sock.c_str(), flags))
-  {
-    throw shcore::Exception::error_with_code_and_state("MySQLError", mysql_error(_mysql), mysql_errno(_mysql), mysql_sqlstate(_mysql));
-  }
-}
-
-boost::shared_ptr<shcore::Object_bridge> Mysql_connection::create(const shcore::Argument_list &args)
-{
-  args.ensure_count(1, 2, "Mysql_connection()");
-  return boost::shared_ptr<shcore::Object_bridge>(new Mysql_connection(args.string_at(0),
-                                                                       args.size() > 1 ? args.string_at(1).c_str() : NULL));
-}
-
-shcore::Value Mysql_connection::close(const shcore::Argument_list &args)
-{
-  args.ensure_count(0, "Mysql_connection::close");
-
-  // This should be logged, for now commenting to
-  // avoid having unneeded output on the script mode
-  // shcore::print("disconnect\n");
-  if (_mysql)
-    mysql_close(_mysql);
-  _mysql = NULL;
-  return shcore::Value(shcore::Null);
-}
-
-Mysql_resultset *Mysql_connection::_sql(const std::string &query, shcore::Value options)
-{
-  if (_prev_result)
-  {
-    _prev_result.reset();
-
-    while (mysql_next_result(_mysql) == 0)
-    {
-      MYSQL_RES *trailing_result = mysql_use_result(_mysql);
-      mysql_free_result(trailing_result);
-    }
-  }
-
-  _timer.start();
-
-  if (mysql_real_query(_mysql, query.c_str(), query.length()) != 0)
-  {
-    throw shcore::Exception::error_with_code_and_state("MySQLError", mysql_error(_mysql), mysql_errno(_mysql), mysql_sqlstate(_mysql));
-  }
-
-  Mysql_resultset* result = new Mysql_resultset(shared_from_this(), mysql_affected_rows(_mysql), mysql_warning_count(_mysql), mysql_info(_mysql), options && options.type == shcore::Map ? options.as_map() : boost::shared_ptr<shcore::Value::Map_type>());
-
-  return result;
-}
-
-shcore::Value Mysql_connection::sql(const std::string &query, shcore::Value options)
-{
-  Mysql_resultset* result = _sql(query, options);
-
-  if (next_result(result, true))
-    return shcore::Value(boost::shared_ptr<shcore::Object_bridge>(result));
-  else
-  {
-    delete result;
-    return shcore::Value::Null();
-  }
-}
-
-template <class T>
-static void free_result(T* result)
-{
-  mysql_free_result(result);
-  result = NULL;
-}
-
-shcore::Value Mysql_connection::sql_one(const std::string &query)
-{
-  Mysql_resultset* result = _sql(query, shcore::Value());
-  shcore::Value ret_val = shcore::Value::Null();
-
-  if (next_result(result, true))
-    ret_val = result->next(shcore::Argument_list());
-
-  delete result;
-
-  return ret_val;
-}
-
-bool Mysql_connection::next_result(Base_resultset *target, bool first_result)
-{
-  bool ret_val = false;
-
-  // Skips fetching a record on the first result
-  int more_results = 0;
-
-  if (!first_result)
-  {
-    _prev_result.reset();
-    more_results = mysql_next_result(_mysql);
-  }
-
-  Mysql_resultset *real_target = dynamic_cast<Mysql_resultset *> (target);
-
-  // If there are more results
-  if (more_results == 0)
-  {
-    // Retrieves the next result
-    MYSQL_RES* result = mysql_use_result(_mysql);
-
-    if (result)
-      _prev_result = boost::shared_ptr<MYSQL_RES>(result, &free_result<MYSQL_RES>);
-
-    // Only returns true when this method was called and there were
-    // Additional results
-    ret_val = true;
-  }
-
-  _timer.end();
-
-  // We need to update the received result object with the information
-  // for the next result set
-  real_target->reset(_prev_result, _timer.raw_duration());
-
-  if (_prev_result)
-    real_target->fetch_metadata();
-
-  return ret_val;
-}
-
-Mysql_connection::~Mysql_connection()
-{
-  close(shcore::Argument_list());
-}
-
-/*
-shcore::Value Mysql_connection::stats(const shcore::Argument_list &args)
-{
-return shcore::Value();
-}
-*/
\ No newline at end of file
diff --git a/modules/mod_mysql.h b/modules/mod_mysql.h
deleted file mode 100644
index be95eae13add4d108b416c90cebc4f965b23d236..0000000000000000000000000000000000000000
--- a/modules/mod_mysql.h
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; version 2 of the
- * License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-// MySQL DB access module, for use by plugins and others
-// For the module that implements interactive DB functionality see mod_db
-
-#ifndef _MOD_MYSQL_H_
-#define _MOD_MYSQL_H_
-
-#include "shellcore/types.h"
-#include "shellcore/types_cpp.h"
-
-#if WIN32
-#  include <winsock2.h>
-#endif
-
-#include <mysql.h>
-#include "mod_common.h"
-#include "mod_connection.h"
-
-namespace mysh {
-  class Mysql_row : public Base_row
-  {
-  public:
-    Mysql_row(MYSQL_ROW row, unsigned long *lengths, std::vector<Field>* metadata = NULL);
-    virtual ~Mysql_row() {}
-
-    virtual shcore::Value get_value(int index);
-    virtual std::string get_value_as_string(int index);
-
-  private:
-    MYSQL_ROW _row;
-    unsigned long *_lengths;
-  };
-
-  class Mysql_connection;
-  class MOD_PUBLIC Mysql_resultset : public Base_resultset
-  {
-  public:
-    Mysql_resultset(boost::shared_ptr<Mysql_connection> owner, uint64_t affected_rows, int warning_count, const char *info, boost::shared_ptr<shcore::Value::Map_type> options = boost::shared_ptr<shcore::Value::Map_type>());
-    virtual ~Mysql_resultset();
-
-    void reset(boost::shared_ptr<MYSQL_RES> res, unsigned long duration);
-
-    virtual std::string class_name() const { return "Mysql_resultset"; }
-    virtual int fetch_metadata();
-
-  protected:
-    virtual Base_row* next_row();
-
-  private:
-    boost::weak_ptr<MYSQL_RES> _result;
-  };
-
-  class MOD_PUBLIC Mysql_connection : public Base_connection, public boost::enable_shared_from_this<Mysql_connection>
-  {
-  public:
-    Mysql_connection(const std::string &uri, const char *password = NULL);
-    ~Mysql_connection();
-
-    virtual std::string class_name() const { return "Mysql_connection"; }
-
-    virtual shcore::Value close(const shcore::Argument_list &args);
-    virtual shcore::Value sql(const std::string &sql, shcore::Value options);
-    virtual shcore::Value sql_one(const std::string &sql);
-
-    virtual bool next_result(Base_resultset *target, bool first_result = false);
-
-    static boost::shared_ptr<Object_bridge> create(const shcore::Argument_list &args);
-
-  private:
-    std::string _uri;
-    MYSQL *_mysql;
-
-    boost::shared_ptr<MYSQL_RES> _prev_result;
-    virtual Mysql_resultset *_sql(const std::string &sql, shcore::Value options);
-  };
-};
-
-#endif
diff --git a/modules/mod_mysql_resultset.cc b/modules/mod_mysql_resultset.cc
new file mode 100644
index 0000000000000000000000000000000000000000..894a0a655a9ad75faea889ac378e090588a6ced4
--- /dev/null
+++ b/modules/mod_mysql_resultset.cc
@@ -0,0 +1,308 @@
+/*
+ * Copyright (c) 2014, 2015 Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#include <iostream>
+
+#include <boost/asio.hpp>
+#include <boost/bind.hpp>
+#include <boost/algorithm/string.hpp>
+
+#include <string>
+#include <iostream>
+#include <iomanip>
+#include "mod_mysql_resultset.h"
+#include "mysql.h"
+
+using namespace mysh;
+using namespace shcore;
+using namespace mysh::mysql;
+
+Resultset::Resultset(boost::shared_ptr< ::mysql::Result> result)
+: _result(result)
+{
+}
+
+shcore::Value Resultset::next(const shcore::Argument_list &args)
+{
+  args.ensure_count(0, "Resultset::next");
+  Row *inner_row = _result->next();
+
+  if (inner_row)
+  {
+    mysh::Row *value_row = new mysh::Row();
+
+    std::vector<Field> metadata(_result->get_metadata());
+
+    for (size_t index = 0; index < metadata.size(); index++)
+      value_row->add_item(metadata[index].name(), inner_row->get_value(index));
+
+    return shcore::Value::wrap(value_row);
+  }
+
+  return shcore::Value::Null();
+}
+
+shcore::Value Resultset::next_result(const shcore::Argument_list &args)
+{
+  args.ensure_count(0, "Resultset::nextResult");
+
+  return shcore::Value(_result->next_result());
+}
+
+shcore::Value Resultset::all(const shcore::Argument_list &args)
+{
+  args.ensure_count(0, "Resultset::all");
+
+  boost::shared_ptr<shcore::Value::Array_type> array(new shcore::Value::Array_type);
+
+  shcore::Value record = next(args);
+
+  while (record)
+  {
+    array->push_back(record);
+    record = next(args);
+  }
+
+  return shcore::Value(array);
+}
+
+shcore::Value Resultset::get_member(const std::string &prop) const
+{
+  if (prop == "fetchedRowCount")
+    return shcore::Value((int64_t)_result->fetched_row_count());
+
+  if (prop == "affectedRows")
+    return shcore::Value((int64_t)((_result->affected_rows() == ~(my_ulonglong)0) ? 0 : _result->affected_rows()));
+
+  if (prop == "warningCount")
+    return shcore::Value(_result->warning_count());
+
+  if (prop == "warnings")
+  {
+    Result* inner_warnings = _result->query_warnings();
+    boost::shared_ptr<Resultset> warnings(new Resultset(boost::shared_ptr<Result>(inner_warnings)));
+    return warnings->all(shcore::Argument_list());
+  }
+
+  if (prop == "info")
+    return shcore::Value(_result->info());
+
+  if (prop == "executionTime")
+    return shcore::Value(MySQL_timer::format_legacy(_result->execution_time(), true));
+
+  if (prop == "lastInsertId")
+    return shcore::Value((int)_result->last_insert_id());
+
+  if (prop == "info")
+    return shcore::Value(_result->info());
+
+  if (prop == "hasData")
+    return Value(_result->has_resultset());
+
+  if (prop == "columnMetadata")
+  {
+    std::vector<Field> metadata(_result->get_metadata());
+
+    boost::shared_ptr<shcore::Value::Array_type> array(new shcore::Value::Array_type);
+
+    int num_fields = metadata.size();
+
+    for (int i = 0; i < num_fields; i++)
+    {
+      boost::shared_ptr<shcore::Value::Map_type> map(new shcore::Value::Map_type);
+
+      (*map)["catalog"] = shcore::Value(metadata[i].catalog());
+      (*map)["db"] = shcore::Value(metadata[i].db());
+      (*map)["table"] = shcore::Value(metadata[i].table());
+      (*map)["org_table"] = shcore::Value(metadata[i].org_table());
+      (*map)["name"] = shcore::Value(metadata[i].name());
+      (*map)["org_name"] = shcore::Value(metadata[i].org_name());
+      (*map)["charset"] = shcore::Value(int(metadata[i].charset()));
+      (*map)["length"] = shcore::Value(int(metadata[i].length()));
+      (*map)["type"] = shcore::Value(int(metadata[i].type()));
+      (*map)["flags"] = shcore::Value(int(metadata[i].flags()));
+      (*map)["decimal"] = shcore::Value(int(metadata[i].decimals()));
+      (*map)["max_length"] = shcore::Value(int(metadata[i].max_length()));
+      (*map)["name_length"] = shcore::Value(int(metadata[i].name_length()));
+
+      // Temporal hack to identify numeric values
+      (*map)["is_numeric"] = shcore::Value(IS_NUM(metadata[i].type()));
+
+      array->push_back(shcore::Value(map));
+    }
+
+    return shcore::Value(array);
+  }
+
+  return BaseResultset::get_member(prop);
+}
+
+#if 0
+// Used to consume all the remaining messages of the current resultset that are coming from the
+// server.
+// If complete false it will only flush the messages about the current result in the resultset
+// If it is true it will flush all the messages for the result set
+void Resultset::flush_messages(bool complete)
+{
+  Message *msg;
+  int mid;
+  bool done_flushing = false;
+  try
+  {
+    boost::shared_ptr<mysh::X_connection> owner = _xowner.lock();
+    if (owner)
+    {
+      do
+      {
+        // Handles any error properly
+        if (_next_mid == Mysqlx::ServerMessages::ERROR)
+          owner->get_protobuf()->handle_wrong_response(mid, msg, "flushing result");
+        else
+        {
+          // Complete flush ends on fetch done or stmt execute ok
+          // note that stmt execute ok is only received by results
+          // with resultset metadata, so is not always present.
+          if (complete)
+          {
+            if (_expect_metadata)
+              done_flushing = _next_mid == Mysqlx::ServerMessages::SQL_STMT_EXECUTE_OK;
+            else
+              done_flushing = _next_mid == Mysqlx::ServerMessages::SQL_CURSOR_FETCH_DONE;
+
+            _all_fetch_done = done_flushing;
+            _current_fetch_done = done_flushing;
+          }
+          else
+          {
+            done_flushing = (_next_mid == Mysqlx::ServerMessages::SQL_CURSOR_FETCH_DONE ||
+                             _next_mid == Mysqlx::ServerMessages::SQL_CURSOR_FETCH_DONE_MORE_RESULTSETS ||
+                             _next_mid == Mysqlx::ServerMessages::SQL_STMT_EXECUTE_OK);
+
+            // On simple resultset request, if this is the last resultset then we need to continue reading if
+            // metadata is expected
+            if (_next_mid == Mysqlx::ServerMessages::SQL_CURSOR_FETCH_DONE && _expect_metadata)
+              done_flushing = false;
+
+            _current_fetch_done = done_flushing;
+          }
+
+          reset(-1, _next_mid, _next_message);
+
+          if (done_flushing && _expect_metadata)
+            set_result_metadata(_next_message);
+
+          delete _next_message;
+          _next_message = NULL;
+
+          if (!done_flushing)
+            _next_message = owner->get_protobuf()->read_response(_next_mid);
+        }
+      } while (!done_flushing);
+    }
+  }
+  CATCH_AND_TRANSLATE();
+}
+
+int Resultset::fetch_metadata()
+{
+  // Fetch the metadata
+  int ret_val = 0;
+  boost::shared_ptr<mysh::X_connection> owner = _xowner.lock();
+
+  _metadata.clear();
+
+  if (owner)
+  {
+    try
+    {
+      while (_next_mid == Mysqlx::ServerMessages::SQL_COLUMN_META_DATA)
+      {
+        Mysqlx::Sql::ColumnMetaData *meta = dynamic_cast<Mysqlx::Sql::ColumnMetaData *>(_next_message);
+
+        _metadata.push_back(Field(meta->catalog(),
+          meta->schema(),
+          meta->table(),
+          meta->original_table(),
+          meta->name(),
+          meta->original_name(),
+          0, // length: not supported yet
+          meta->type(),
+          0, // flags: not supported yet
+          meta->fractional_digits(),// decimals are now sent as fractional digits
+          0)); // charset: not supported yet
+
+        ret_val++;
+
+        _next_message = owner->get_protobuf()->read_response(_next_mid);
+      }
+
+      // Validates exit in case of error...
+      if (_next_mid == Mysqlx::ServerMessages::ERROR)
+      {
+        // Since metadata will be empty, it implies the result had no records
+        Mysqlx::Error *error = dynamic_cast<Mysqlx::Error *>(_next_message);
+        std::cout << "Error retrieving metadata: " << error->msg() << std::endl;
+        ret_val = -1;
+      }
+    }
+    CATCH_AND_TRANSLATE();
+  }
+
+  return ret_val;
+}
+
+void Resultset::reset(unsigned long duration, int next_mid, ::google::protobuf::Message* next_message)
+{
+  if (next_mid)
+  {
+    _next_mid = next_mid;
+    _next_message = next_message;
+
+    // Nothing to be read anymnore on these cases
+    if (_expect_metadata)
+      _all_fetch_done = (_next_mid == Mysqlx::ServerMessages::SQL_STMT_EXECUTE_OK);
+    else
+      _all_fetch_done = (_next_mid == Mysqlx::ServerMessages::SQL_CURSOR_FETCH_DONE);
+
+    // Nothing to be read for the current result on these cases
+    _current_fetch_done = (_next_mid == Mysqlx::ServerMessages::SQL_CURSOR_FETCH_DONE ||
+                           _next_mid == Mysqlx::ServerMessages::SQL_CURSOR_FETCH_DONE_MORE_RESULTSETS ||
+                           _all_fetch_done);
+  }
+
+  if (duration != (unsigned long)-1)
+    _raw_duration = duration;
+}
+
+void Resultset::set_result_metadata(Message *msg)
+{
+  Mysqlx::Sql::StmtExecuteOk *stmt_exec_ok = dynamic_cast<Mysqlx::Sql::StmtExecuteOk*>(msg);
+
+  if (stmt_exec_ok)
+  {
+    if (stmt_exec_ok->has_rows_affected())
+      _affected_rows = stmt_exec_ok->rows_affected();
+
+    if (stmt_exec_ok->has_last_insert_id())
+      _last_insert_id = stmt_exec_ok->last_insert_id();
+  }
+  else
+    throw shcore::Exception::logic_error("Unexpected message to set resultset metadata.");
+}
+#endif
\ No newline at end of file
diff --git a/modules/mod_mysql_resultset.h b/modules/mod_mysql_resultset.h
new file mode 100644
index 0000000000000000000000000000000000000000..560c6c6fd802a5d739e16a5fdc308629965b124f
--- /dev/null
+++ b/modules/mod_mysql_resultset.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2015 Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+// MySQL DB access module, for use by plugins and others
+// For the module that implements interactive DB functionality see mod_db
+
+#ifndef _MOD_XRESULT_H_
+#define _MOD_XRESULT_H_
+
+#include "shellcore/types.h"
+#include "shellcore/types_cpp.h"
+#include "base_resultset.h"
+#include <list>
+
+namespace mysh
+{
+  namespace mysql
+  {
+    class Result;
+    class Resultset : public BaseResultset
+    {
+    public:
+      Resultset(boost::shared_ptr<Result> result);
+
+      virtual std::string class_name() const { return "mysql::Resultset"; }
+      virtual shcore::Value get_member(const std::string &prop) const;
+
+      virtual shcore::Value next(const shcore::Argument_list &args);
+      virtual shcore::Value all(const shcore::Argument_list &args);
+      virtual shcore::Value next_result(const shcore::Argument_list &args);
+
+    protected:
+      boost::shared_ptr<Result> _result;
+    };
+  }
+};
+
+#endif
diff --git a/modules/mod_mysql_schema.cc b/modules/mod_mysql_schema.cc
new file mode 100644
index 0000000000000000000000000000000000000000..910a681705e0aaf79d942e1eaab7ad0e2fe65d03
--- /dev/null
+++ b/modules/mod_mysql_schema.cc
@@ -0,0 +1,205 @@
+/*
+ * Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#include "mod_mysql_schema.h"
+#include "mod_mysql_table.h"
+#include "mod_mysql_view.h"
+#include "mod_mysql_session.h"
+#include "mod_mysql_resultset.h"
+
+#include "shellcore/object_factory.h"
+#include "shellcore/shell_core.h"
+#include "shellcore/lang_base.h"
+
+#include "shellcore/proxy_object.h"
+
+#include <boost/bind.hpp>
+#include <boost/lexical_cast.hpp>
+#include <boost/format.hpp>
+#include <boost/pointer_cast.hpp>
+
+using namespace mysh::mysql;
+using namespace shcore;
+
+#include <iostream>
+
+Schema::Schema(boost::shared_ptr<Session> session, const std::string &schema)
+: DatabaseObject(session, NULL, schema)
+{
+  add_method("getTables", boost::bind(&DatabaseObject::get_member_method, this, _1, "getTables", "tables"), "name", shcore::String, NULL);
+  add_method("getViews", boost::bind(&DatabaseObject::get_member_method, this, _1, "getViews", "views"), "name", shcore::String, NULL);
+
+  add_method("getTable", boost::bind(&Schema::getTable, this, _1), "name", shcore::String, NULL);
+  add_method("getView", boost::bind(&Schema::getView, this, _1), "name", shcore::String, NULL);
+
+  _tables = Value::new_map().as_map();
+  _views = Value::new_map().as_map();
+}
+
+Schema::Schema(boost::shared_ptr<const Session> session, const std::string &schema) :
+Schema(boost::const_pointer_cast<Session>(session), schema)
+{
+}
+
+Schema::~Schema()
+{
+}
+
+void Schema::cache_table_objects()
+{
+  boost::shared_ptr<Session> sess(boost::dynamic_pointer_cast<Session>(_session.lock()));
+  if (sess)
+  {
+    Result *result = sess->connection()->executeSql("show full tables in `" + _name + "`");
+    Row *row = result->next();
+    while (row)
+    {
+      std::string object_name = row->get_value_as_string(0);
+      std::string object_type = row->get_value_as_string(1);
+
+      if (object_type == "BASE TABLE" || object_type == "LOCAL TEMPORARY")
+        (*_tables)[object_name] = Value::wrap(new Table(shared_from_this(), object_name));
+      else if (object_type == "VIEW" || object_type == "SYSTEM VIEW")
+        (*_views)[object_name] = Value::wrap(new View(shared_from_this(), object_name));
+
+      row = result->next();
+    }
+  }
+}
+
+std::vector<std::string> Schema::get_members() const
+{
+  std::vector<std::string> members(DatabaseObject::get_members());
+  members.push_back("tables");
+  members.push_back("views");
+
+  for (Value::Map_type::const_iterator iter = _tables->begin();
+       iter != _tables->end(); ++iter)
+  {
+    members.push_back(iter->first);
+  }
+
+  for (Value::Map_type::const_iterator iter = _views->begin();
+       iter != _views->end(); ++iter)
+  {
+    members.push_back(iter->first);
+  }
+
+  return members;
+}
+
+Value Schema::get_member(const std::string &prop) const
+{
+  Value ret_val;
+
+  // Check the member is on the base classes before attempting to
+  // retrieve it since it may throw invalid member otherwise
+  // If not on the parent classes and not here then we can safely assume
+  // it is must be either a table, collection or view and attempt loading it as such
+  if (DatabaseObject::has_member(prop))
+    ret_val = DatabaseObject::get_member(prop);
+  else if (prop == "tables")
+    ret_val = Value(_tables);
+  else if (prop == "views")
+    ret_val = Value(_views);
+  else
+  {
+    // At this point the property should be one of table
+    // collection or view
+    ret_val = find_in_collection(prop, _tables);
+
+    if (!ret_val)
+      ret_val = find_in_collection(prop, _views);
+
+    if (!ret_val)
+      ret_val = _load_object(prop);
+
+    if (!ret_val)
+      throw Exception::attrib_error("Invalid object member " + prop);
+  }
+
+  return ret_val;
+}
+
+shcore::Value Schema::getTable(const shcore::Argument_list &args)
+{
+  args.ensure_count(1, (class_name() + "::getTable").c_str());
+  std::string name = args.string_at(0);
+
+  Value::Map_type::const_iterator iter = _tables->find(name);
+  if (iter != _tables->end())
+    return Value(boost::shared_ptr<Object_bridge>(iter->second.as_object()));
+  else
+    return Value();
+
+  //return shcore::Value::wrap(new Table(shared_from_this(), name));
+}
+
+shcore::Value Schema::getView(const shcore::Argument_list &args)
+{
+  args.ensure_count(1, (class_name() + "::getCollection").c_str());
+  std::string name = args.string_at(0);
+
+  Value::Map_type::const_iterator iter = _views->find(name);
+  if (iter != _views->end())
+    return Value(boost::shared_ptr<Object_bridge>(iter->second.as_object()));
+  else
+    return Value();
+
+  //return shcore::Value::wrap(new View(shared_from_this(), name));
+}
+
+shcore::Value Schema::find_in_collection(const std::string& name, boost::shared_ptr<shcore::Value::Map_type>source) const
+{
+  Value::Map_type::const_iterator iter = source->find(name);
+  if (iter != source->end())
+    return Value(boost::shared_ptr<Object_bridge>(iter->second.as_object()));
+  else
+    return Value();
+}
+
+Value Schema::_load_object(const std::string& name, const std::string& type) const
+{
+  Value ret_val;
+  boost::shared_ptr<Session> sess(boost::dynamic_pointer_cast<Session>(_session.lock()));
+  if (sess)
+  {
+    Result *result = sess->connection()->executeSql("show full tables in `" + _name + "` like '" + name + "';");
+    Row *row = result->next();
+
+    if (row)
+    {
+      std::string object_name = row->get_value_as_string(0);
+      std::string object_type = row->get_value_as_string(1);
+
+      if (type.empty() || (type == "TABLE" && (object_type == "BASE TABLE" || object_type == "LOCAL TEMPORARY")))
+      {
+        ret_val = Value::wrap(new Table(shared_from_this(), object_name));
+        (*_tables)[object_name] = ret_val;
+      }
+      else if (type.empty() || (type == "VIEW" && (object_type == "VIEW" || object_type == "SYSTEM VIEW")))
+      {
+        ret_val = Value::wrap(new View(shared_from_this(), object_name));
+        (*_views)[object_name] = ret_val;
+      }
+    }
+  }
+
+  return ret_val;
+}
\ No newline at end of file
diff --git a/modules/mod_mysql_schema.h b/modules/mod_mysql_schema.h
new file mode 100644
index 0000000000000000000000000000000000000000..6eeb7ffe52f81f02418d57c18ad5d2fcfe829757
--- /dev/null
+++ b/modules/mod_mysql_schema.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+// Interactive DB access module
+// (the one exposed as the db variable in the shell)
+
+#ifndef _MOD_DB_H_
+#define _MOD_DB_H_
+
+#include "mod_common.h"
+#include "base_database_object.h"
+#include "shellcore/types.h"
+#include "shellcore/types_cpp.h"
+
+#include <boost/enable_shared_from_this.hpp>
+#include <boost/weak_ptr.hpp>
+
+namespace shcore
+{
+  class Proxy_object;
+};
+
+namespace mysh
+{
+  namespace mysql
+  {
+    class Session;
+    class Table;
+
+    class MOD_PUBLIC Schema : public DatabaseObject, public boost::enable_shared_from_this<Schema>
+    {
+    public:
+      Schema(boost::shared_ptr<Session> owner, const std::string &name);
+      Schema(boost::shared_ptr<const Session> owner, const std::string &name);
+      ~Schema();
+
+      virtual std::string class_name() const{ return "Schema"; };
+
+      virtual std::vector<std::string> get_members() const;
+      virtual shcore::Value get_member(const std::string &prop) const;
+
+      void cache_table_objects();
+
+      friend class Table;
+      friend class View;
+    private:
+      boost::shared_ptr<shcore::Value::Map_type> _tables;
+      boost::shared_ptr<shcore::Value::Map_type> _views;
+
+      shcore::Value _load_object(const std::string& name, const std::string& type = "") const;
+      shcore::Value find_in_collection(const std::string& name, boost::shared_ptr<shcore::Value::Map_type>source) const;
+      shcore::Value getTable(const shcore::Argument_list &args);
+      shcore::Value getView(const shcore::Argument_list &args);
+    };
+  };
+};
+
+#endif
diff --git a/modules/mod_mysql_session.cc b/modules/mod_mysql_session.cc
new file mode 100644
index 0000000000000000000000000000000000000000..a02e12ed0f92dd53cefc296e59056d159f5a6acd
--- /dev/null
+++ b/modules/mod_mysql_session.cc
@@ -0,0 +1,314 @@
+/*
+ * Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#include "mod_mysql_session.h"
+
+#include "shellcore/object_factory.h"
+#include "shellcore/shell_core.h"
+#include "shellcore/lang_base.h"
+
+#include "shellcore/proxy_object.h"
+
+#include <boost/bind.hpp>
+#include <boost/lexical_cast.hpp>
+#include <boost/format.hpp>
+#include <boost/pointer_cast.hpp>
+#include <set>
+
+#include "mysql.h"
+#include "mod_mysql_resultset.h"
+#include "mod_mysql_schema.h"
+
+#define MAX_COLUMN_LENGTH 1024
+#define MIN_COLUMN_LENGTH 4
+
+using namespace mysh::mysql;
+using namespace shcore;
+
+REGISTER_OBJECT(mysql, Session);
+
+#include <iostream>
+
+Session::Session()
+: _show_warnings(false)
+{
+  //_schema_proxy.reset(new Proxy_object(boost::bind(&Session::get_db, this, _1)));
+
+  add_method("executeSql", boost::bind(&Session::executeSql, this, _1),
+    "stmt", shcore::String,
+    NULL);
+
+  _schemas.reset(new shcore::Value::Map_type);
+}
+
+Connection *Session::connection()
+{
+  return _conn.get();
+}
+
+Value Session::connect(const Argument_list &args)
+{
+  args.ensure_count(1, 2, "Session::connect");
+
+  std::string uri = args.string_at(0);
+
+  std::string protocol;
+  std::string user;
+  std::string pass;
+  const char *pwd_override = NULL;
+  std::string host;
+  std::string sock;
+  std::string db;
+  std::string uri_stripped;
+
+  int pwd_found;
+  int port = 0;
+
+  if (!parse_mysql_connstring(uri, protocol, user, pass, host, port, sock, db, pwd_found))
+    throw shcore::Exception::argument_error("Could not parse URI for MySQL connection");
+
+  // If password is received as parameter, then it overwrites
+  // Anything found on the URI
+  if (2 == args.size())
+    pwd_override = args.string_at(1).c_str();
+
+  _conn.reset(new Connection(uri, pwd_override));
+
+  _load_schemas();
+  _load_default_schema();
+
+  return Value::Null();
+}
+
+Value Session::executeSql(const Argument_list &args)
+{
+  args.ensure_count(1, "Session::sql");
+  // Will return the result of the SQL execution
+  // In case of error will be Undefined
+  Value ret_val;
+  if (!_conn)
+    throw Exception::logic_error("Not connected.");
+  else
+  {
+    // Options are the statement and optionally options to modify
+    // How the resultset is created.
+    std::string statement = args.string_at(0);
+
+    if (statement.empty())
+      throw Exception::argument_error("No query specified.");
+    else
+      ret_val = Value::wrap(new Resultset(boost::shared_ptr<Result>(_conn->executeSql(statement))));
+  }
+
+  return ret_val;
+}
+
+std::string Session::uri() const
+{
+  return _conn->uri();
+}
+
+std::vector<std::string> Session::get_members() const
+{
+  std::vector<std::string> members(BaseSession::get_members());
+
+  // This function is here only to append the schemas as direct members
+  // Will use a set to prevent duplicates
+  std::set<std::string> set(members.begin(), members.end());
+  for (Value::Map_type::const_iterator iter = _schemas->begin(); iter != _schemas->end(); ++iter)
+    set.insert(iter->first);
+
+  for (std::vector<std::string>::iterator index = members.begin(); index != members.end(); ++index)
+    set.erase(*index);
+
+  for (std::set<std::string>::iterator index = set.begin(); index != set.end(); ++index)
+    members.push_back(*index);
+
+  return members;
+}
+
+Value Session::get_member(const std::string &prop) const
+{
+  // Retrieves the member first from the parent
+  Value ret_val;
+
+  // Check the member is on the base classes before attempting to
+  // retrieve it since it may throw invalid member otherwise
+  // If not on the parent classes and not here then we can safely assume
+  // it is a schema and attempt loading it as such
+  if (BaseSession::has_member(prop))
+    ret_val = BaseSession::get_member(prop);
+  else if (prop == "schemas")
+    ret_val = Value(_schemas);
+  else if (prop == "uri")
+    ret_val = Value(_conn->uri());
+  else if (prop == "defaultSchema")
+  {
+    if (_default_schema)
+      ret_val = Value(boost::static_pointer_cast<Object_bridge>(_default_schema));
+    else
+      ret_val = Value::Null();
+  }
+  else
+  {
+    // Since the property was not satisfied, we assume it is a schema and
+    // proceed to retrieve it
+    shcore::Argument_list args;
+    args.push_back(Value(prop));
+
+    ret_val = get_schema(args);
+  }
+
+  return ret_val;
+}
+
+void Session::_load_default_schema()
+{
+  _default_schema.reset();
+
+  if (_conn)
+  {
+    shcore::Argument_list query;
+    query.push_back(Value("select schema()"));
+
+    Value res = executeSql(query);
+
+    boost::shared_ptr<Resultset> rset = res.as_object<Resultset>();
+    Value next_row = rset->next(shcore::Argument_list());
+
+    if (next_row)
+    {
+      boost::shared_ptr<mysh::Row> row = next_row.as_object<mysh::Row>();
+      shcore::Value schema = row->get_member("schema()");
+
+      if (schema)
+      {
+        std::string name = schema.as_string();
+        _update_default_schema(name);
+      }
+    }
+  }
+}
+
+void Session::_load_schemas()
+{
+  if (_conn)
+  {
+    shcore::Argument_list query;
+    query.push_back(Value("show databases;"));
+
+    Value res = executeSql(query);
+
+    shcore::Argument_list args;
+    boost::shared_ptr<Resultset> rset = res.as_object<Resultset>();
+    Value next_row = rset->next(args);
+    boost::shared_ptr<mysh::Row> row;
+
+    while (next_row)
+    {
+      row = next_row.as_object<mysh::Row>();
+      shcore::Value schema = row->get_member("Database");
+      if (schema)
+      {
+        boost::shared_ptr<Schema> object(new Schema(shared_from_this(), schema.as_string()));
+        (*_schemas)[schema.as_string()] = shcore::Value(boost::static_pointer_cast<Object_bridge>(object));
+      }
+
+      next_row = rset->next(args);
+    }
+  }
+}
+
+shcore::Value Session::get_schema(const shcore::Argument_list &args) const
+{
+  std::string function_name = class_name() + ".getSchema";
+  args.ensure_count(1, function_name.c_str());
+
+  std::string name = args[0].as_string();
+
+  if (_schemas->has_key(name))
+  {
+    boost::shared_ptr<Schema> schema = (*_schemas)[name].as_object<Schema>();
+
+    // This will validate the schema continues valid
+    schema->cache_table_objects();
+  }
+  else
+  {
+    if (_conn)
+    {
+      boost::shared_ptr<Schema> schema(new Schema(shared_from_this(), name));
+
+      // Here this call will also validate the schema is valid
+      schema->cache_table_objects();
+
+      (*_schemas)[name] = Value(boost::static_pointer_cast<Object_bridge>(schema));
+    }
+    else
+      throw Exception::runtime_error("Session not connected");
+  }
+
+  // If this point is reached, the schema will be there!
+  return (*_schemas)[name];
+}
+
+shcore::Value Session::set_default_schema(const shcore::Argument_list &args)
+{
+  args.ensure_count(1, "Session.setDefaultSchema");
+
+  if (_conn)
+  {
+    std::string name = args[0].as_string();
+
+    shcore::Argument_list query;
+    query.push_back(Value("use " + name + ";"));
+
+    Value res = executeSql(query);
+
+    _update_default_schema(name);
+  }
+  else
+    throw Exception::runtime_error("Session not connected");
+
+  return get_member("defaultSchema");
+}
+
+void Session::_update_default_schema(const std::string& name)
+{
+  if (!name.empty())
+  {
+    if (_schemas->has_key(name))
+      _default_schema = (*_schemas)[name].as_object<Schema>();
+    else
+    {
+      _default_schema.reset(new Schema(shared_from_this(), name));
+      _default_schema->cache_table_objects();
+      (*_schemas)[name] = Value(boost::static_pointer_cast<Object_bridge>(_default_schema));
+    }
+  }
+}
+
+boost::shared_ptr<shcore::Object_bridge> Session::create(const shcore::Argument_list &args)
+{
+  boost::shared_ptr<Session> session(new Session());
+
+  session->connect(args);
+
+  return session;
+}
\ No newline at end of file
diff --git a/modules/mod_mysql_session.h b/modules/mod_mysql_session.h
new file mode 100644
index 0000000000000000000000000000000000000000..c10e9599435db00030246f7b15799c754165b409
--- /dev/null
+++ b/modules/mod_mysql_session.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+// Interactive session access module
+// Exposed as "session" in the shell
+
+#ifndef _MOD_SESSION_H_
+#define _MOD_SESSION_H_
+
+#include "mod_common.h"
+#include "shellcore/types.h"
+#include "shellcore/types_cpp.h"
+#include "shellcore/ishell_core.h"
+#include "mysql.h"
+#include "base_session.h"
+
+#include <boost/enable_shared_from_this.hpp>
+
+namespace shcore
+{
+  class Shell_core;
+  class Proxy_object;
+};
+
+namespace mysh
+{
+  namespace mysql
+  {
+    class Schema;
+    class MOD_PUBLIC Session : public BaseSession, public boost::enable_shared_from_this<Session>
+    {
+    public:
+      Session();
+      virtual ~Session() {};
+
+      // Virtual methods from object bridge
+      virtual std::string class_name() const { return "Session"; };
+      virtual shcore::Value get_member(const std::string &prop) const;
+      std::vector<std::string> get_members() const;
+
+      // Virtual methods from ISession
+      virtual shcore::Value connect(const shcore::Argument_list &args);
+      virtual void disconnect() { _conn.reset(); }
+      virtual shcore::Value executeSql(const shcore::Argument_list &args);
+      virtual bool is_connected() const { return _conn ? true : false; }
+
+      virtual std::string uri() const;
+      virtual shcore::Value get_schema(const shcore::Argument_list &args) const;
+      virtual shcore::Value set_default_schema(const shcore::Argument_list &args);
+
+      static boost::shared_ptr<shcore::Object_bridge> create(const shcore::Argument_list &args);
+
+      Connection *connection();
+
+    private:
+      void _update_default_schema(const std::string& name);
+      void _load_default_schema();
+      void _load_schemas();
+
+      boost::shared_ptr<Connection> _conn;
+
+      boost::shared_ptr<Schema> _default_schema;
+      boost::shared_ptr<shcore::Value::Map_type> _schemas;
+
+      //boost::shared_ptr<shcore::Proxy_object> _schema_proxy;
+
+      bool _show_warnings;
+    };
+  };
+};
+
+#endif
diff --git a/modules/mod_mysql_table.cc b/modules/mod_mysql_table.cc
new file mode 100644
index 0000000000000000000000000000000000000000..54037bfda3926ff81aee98061d337494e8f90d8b
--- /dev/null
+++ b/modules/mod_mysql_table.cc
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#include "mod_mysql_schema.h"
+#include "mod_mysql_table.h"
+
+using namespace mysh;
+using namespace mysh::mysql;
+using namespace shcore;
+
+Table::Table(boost::shared_ptr<Schema> owner, const std::string &name)
+: DatabaseObject(owner->_session.lock(), owner, name)
+{
+}
+
+Table::Table(boost::shared_ptr<const Schema> owner, const std::string &name)
+: Table(boost::const_pointer_cast<Schema>(owner), name)
+{
+}
+
+Table::~Table()
+{
+}
\ No newline at end of file
diff --git a/modules/mod_mysql_table.h b/modules/mod_mysql_table.h
new file mode 100644
index 0000000000000000000000000000000000000000..70359d76b8fd324cdf4ee2d43de83d8366941e95
--- /dev/null
+++ b/modules/mod_mysql_table.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+// Interactive Table access module
+// (the one exposed as the table members of the db object in the shell)
+
+#ifndef _MOD_MYSQL_TABLE_H_
+#define _MOD_MYSQL_TABLE_H_
+
+#include "base_database_object.h"
+#include "shellcore/types.h"
+#include "shellcore/types_cpp.h"
+
+namespace mysh
+{
+  namespace mysql
+  {
+    class Schema;
+
+    class Table : public DatabaseObject
+    {
+    public:
+      Table(boost::shared_ptr<Schema> owner, const std::string &name);
+      Table(boost::shared_ptr<const Schema> owner, const std::string &name);
+      virtual ~Table();
+
+      virtual std::string class_name() const { return "Table"; }
+    };
+  }
+}
+
+#endif
diff --git a/modules/mod_mysql_view.cc b/modules/mod_mysql_view.cc
new file mode 100644
index 0000000000000000000000000000000000000000..5cc0fa68ae1b7f7395681a26a346e9d08da7d71a
--- /dev/null
+++ b/modules/mod_mysql_view.cc
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#include "mod_mysql_schema.h"
+#include "mod_mysql_view.h"
+
+using namespace mysh;
+using namespace mysh::mysql;
+using namespace shcore;
+
+View::View(boost::shared_ptr<Schema> owner, const std::string &name)
+: DatabaseObject(owner->_session.lock(), owner, name)
+{
+}
+
+View::View(boost::shared_ptr<const Schema> owner, const std::string &name) :
+View(boost::const_pointer_cast<Schema>(owner), name)
+{
+}
+
+View::~View()
+{
+}
\ No newline at end of file
diff --git a/modules/mod_mysql_view.h b/modules/mod_mysql_view.h
new file mode 100644
index 0000000000000000000000000000000000000000..754d8934ff8119bde1a432c580c52b4142b8feb6
--- /dev/null
+++ b/modules/mod_mysql_view.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+// Interactive Table access module
+// (the one exposed as the table members of the db object in the shell)
+
+#ifndef _MOD_MYSQL_VIEW_H_
+#define _MOD_MYSQL_VIEW_H_
+
+#include "base_database_object.h"
+#include "shellcore/types.h"
+#include "shellcore/types_cpp.h"
+
+namespace mysh
+{
+  namespace mysql
+  {
+    class Schema;
+
+    class View : public DatabaseObject
+    {
+    public:
+      View(boost::shared_ptr<Schema> owner, const std::string &name);
+      View(boost::shared_ptr<const Schema> owner, const std::string &name);
+      virtual ~View();
+
+      virtual std::string class_name() const { return "View"; }
+    };
+  }
+}
+
+#endif
diff --git a/modules/mod_mysqlx.cc b/modules/mod_mysqlx.cc
deleted file mode 100644
index 878c747d20c691fd83f09825a60d210125c9cc42..0000000000000000000000000000000000000000
--- a/modules/mod_mysqlx.cc
+++ /dev/null
@@ -1,704 +0,0 @@
-/*
- * Copyright (c) 2014, 2015 Oracle and/or its affiliates. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; version 2 of the
- * License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#include "mysqlx_parser.h"
-#include "mod_mysqlx.h"
-
-using namespace mysh;
-using namespace shcore;
-
-#include <iostream>
-
-#include <boost/asio.hpp>
-#include <boost/bind.hpp>
-#include <boost/algorithm/string.hpp>
-
-#include <string>
-#include <iostream>
-#include <iomanip>
-
-#include "uuid_gen.h"
-
-#include "shellcore/object_factory.h"
-#include "mod_crud_collection_add.h"
-#include "mod_crud_collection_find.h"
-#include "mod_crud_collection_remove.h"
-#include "mod_crud_table_insert.h"
-#include "mod_result.h"
-
-REGISTER_ALIASED_OBJECT(mysqlx, Connection, X_connection);
-REGISTER_OBJECT(mysqlx, CollectionAdd);
-REGISTER_OBJECT(mysqlx, CollectionFind);
-REGISTER_OBJECT(mysqlx, CollectionRemove);
-REGISTER_OBJECT(mysqlx, TableInsert);
-
-/*
-* Helper function to ensure the exceptions generated on the mysqlx_connector
-* are properly translated to the corresponding shcore::Exception type
-*/
-static void translate_exception()
-{
-  try
-  {
-    throw;
-  }
-  catch (boost::system::system_error &e)
-  {
-    throw shcore::Exception::runtime_error(e.what());
-  }
-  catch (std::runtime_error &e)
-  {
-    throw shcore::Exception::runtime_error(e.what());
-  }
-  catch (std::logic_error &e)
-  {
-    throw shcore::Exception::logic_error(e.what());
-  }
-  catch (...)
-  {
-    throw;
-  }
-}
-
-#define CATCH_AND_TRANSLATE()   \
-  catch (...)                   \
-{ translate_exception(); }
-
-X_connection::X_connection(const std::string &uri, const char *password)
-: Base_connection(uri, password), _next_stmt_id(0)
-{
-  std::string protocol;
-  std::string user;
-  std::string pass;
-  std::string host;
-  int port = 33060;
-  std::string sock;
-  std::string db;
-  int pwd_found;
-
-  if (!parse_mysql_connstring(uri, protocol, user, pass, host, port, sock, db, pwd_found))
-    throw shcore::Exception::argument_error("Could not parse URI for MySQL connection");
-
-  if (password)
-    pass.assign(password);
-
-  std::stringstream ss;
-  ss << port;
-
-  try
-  {
-    _protobuf = boost::shared_ptr<mysqlx::Mysqlx_test_connector>(new mysqlx::Mysqlx_test_connector(host, ss.str()));
-  }
-  CATCH_AND_TRANSLATE();
-
-  auth(user.c_str(), pass.c_str());
-}
-
-void X_connection::auth(const char *user, const char *pass)
-{
-  Mysqlx::Session::AuthenticateStart m;
-
-  m.set_mech_name("plain");
-  m.set_auth_data(user);
-  m.set_initial_response(pass);
-  _protobuf->send_message(&m);
-
-  int mid;
-  try
-  {
-    Message *r = _protobuf->read_response(mid);
-
-    if (r)
-      delete r;
-  }
-  CATCH_AND_TRANSLATE();
-
-  if (mid != Mysqlx::ServerMessages::SESS_AUTHENTICATE_OK)
-  {
-    throw shcore::Exception::argument_error("Authentication failed...");
-  }
-}
-
-boost::shared_ptr<shcore::Object_bridge> X_connection::create(const shcore::Argument_list &args)
-{
-  args.ensure_count(1, 2, "Mysqlx_connection()");
-  return boost::shared_ptr<shcore::Object_bridge>(new X_connection(args.string_at(0),
-    args.size() > 1 ? args.string_at(1).c_str() : NULL));
-}
-
-X_resultset *X_connection::_sql(const std::string &query, shcore::Value options)
-{
-  int mid;
-  Message* msg;
-
-  // Reads any remaining stuff from the previos result
-  // To let the comm in a clean state
-  if (_last_result && !_last_result->is_all_fetch_done())
-    _last_result->flush_messages(true);
-
-  _timer.start();
-  ++_next_stmt_id;
-
-  bool has_data = false;
-
-  try
-  {
-    Mysqlx::Sql::StmtExecute stmt;
-    stmt.set_stmt(query);
-    mid = Mysqlx::ClientMessages::SQL_STMT_EXECUTE;
-
-    std::set<int> responses;
-    responses.insert(Mysqlx::ServerMessages::SQL_STMT_EXECUTE_OK);
-    responses.insert(Mysqlx::ServerMessages::SQL_COLUMN_META_DATA);
-
-    msg = _protobuf->send_receive_message(mid, &stmt, responses, "executing statement: " + query);
-
-    has_data = mid == Mysqlx::ServerMessages::SQL_COLUMN_META_DATA;
-  }
-  CATCH_AND_TRANSLATE();
-
-  X_resultset* result = new X_resultset(shared_from_this(), has_data, _next_stmt_id, 0, 0, 0, NULL, mid, msg, true,
-                                        options && options.type == shcore::Map ? options.as_map() : boost::shared_ptr<shcore::Value::Map_type>());
-
-  // If no data will be returned then loads the resultset metadata
-  // And fills the timer data as well
-  if (mid == Mysqlx::ServerMessages::SQL_STMT_EXECUTE_OK)
-  {
-    _timer.end();
-
-    result->set_result_metadata(msg);
-    result->reset(_timer.raw_duration());
-  }
-
-  return result;
-}
-
-shcore::Value X_connection::sql_one(const std::string &query)
-{
-  shcore::Value ret_val = shcore::Value::Null();
-
-  // Executes the normal query
-  sql(query, shcore::Value());
-
-  if (_last_result->has_resultset())
-  {
-    shcore::Argument_list no_args;
-    ret_val = _last_result->next(no_args);
-
-    // Reads whatever is remaining, we do not care about it
-    _last_result->flush_messages(true);
-  }
-
-  return ret_val;
-}
-
-shcore::Value X_connection::sql(const std::string &query, shcore::Value options)
-{
-  // Creates the resultset
-  _last_result.reset(_sql(query, options));
-
-  // Calls next result so the metadata is loaded
-  // if any result
-  if (_last_result->has_resultset())
-    next_result(_last_result.get(), true);
-
-  return shcore::Value(boost::shared_ptr<shcore::Object_bridge>(_last_result));
-}
-
-shcore::Value X_connection::close(const shcore::Argument_list &args)
-{
-  if (_last_result && !_last_result->is_all_fetch_done())
-    _last_result->flush_messages(true);
-
-  _protobuf->close();
-
-  return shcore::Value();
-}
-
-X_connection::~X_connection()
-{
-  close(shcore::Argument_list());
-}
-
-shcore::Value X_connection::crud_execute(const std::string& id, shcore::Value::Map_type_ref data)
-{
-  shcore::Value ret_val;
-
-  if (id == "TableInsert")
-    ret_val = crud_table_insert(data);
-  else if (id == "CollectionAdd")
-    ret_val = crud_collection_add(data);
-  else if (id == "CollectionFind")
-    ret_val = crud_collection_find(data);
-  else if (id == "CollectionRemove")
-    ret_val = crud_collection_remove(data);
-
-  return ret_val;
-}
-
-std::string get_new_uuid()
-{
-  uuid_type uuid;
-  generate_uuid(uuid);
-
-  std::stringstream str;
-  str << std::hex << std::noshowbase << std::setfill('0') << std::setw(2);
-  //*
-  str << (int)uuid[0] << std::setw(2) << (int)uuid[1] << std::setw(2) << (int)uuid[2] << std::setw(2) << (int)uuid[3];
-  str << std::setw(2) << (int)uuid[4] << std::setw(2) << (int)uuid[5];
-  str << std::setw(2) << (int)uuid[6] << std::setw(2) << (int)uuid[7];
-  str << std::setw(2) << (int)uuid[8] << std::setw(2) << (int)uuid[9];
-  str << std::setw(2) << (int)uuid[10] << std::setw(2) << (int)uuid[11]
-    << std::setw(2) << (int)uuid[12] << std::setw(2) << (int)uuid[13]
-    << std::setw(2) << (int)uuid[14] << std::setw(2) << (int)uuid[15];
-
-  return str.str();
-}
-
-shcore::Value X_connection::crud_collection_add(shcore::Value::Map_type_ref data)
-{
-  //----SAMPLE IMPLEMENTATION
-  // This implementation allows performing a table insert operation as:
-  //
-  // table.insert(['col1', 'col2','col3']).values(['val1', val2', 'val3']).run()
-  //
-  // The definitive implementation should consider many different cases
-  // and also many validations must be included
-  uint64_t affected_rows = 0;
-  uint64_t last_insert_id = 0;
-  uuid_type uuid;
-
-  try
-  {
-    Mysqlx::Crud::Insert insert;
-    insert.mutable_collection()->set_schema((*data)["schema"].as_string());
-    insert.mutable_collection()->set_name((*data)["collection"].as_string());
-    insert.set_data_model(Mysqlx::Crud::DataModel((*data)["data_model"].as_int()));
-
-    std::vector<std::string> json_docs;
-    size_t count = 0;
-
-    if (data->has_key("Documents"))
-    {
-      shcore::Value::Map_type_ref doc;
-      shcore::Value::Array_type_ref doc_collection;
-
-      switch ((*data)["Documents"].type)
-      {
-        case shcore::Map:
-          doc = (*data)["Documents"].as_map();
-          if (!doc->has_key("_id"))
-          {
-            (*doc)["_id"] = shcore::Value(get_new_uuid());
-          }
-
-          // Appends the document to the list to be inserted
-          json_docs.push_back((*data)["Documents"].repr());
-          break;
-        case shcore::Array:
-          doc_collection = (*data)["Documents"].as_array();
-          count = doc_collection->size();
-          for (size_t index = 0; index < count; index++)
-          {
-            if ((*doc_collection)[index].type == shcore::Map)
-            {
-              doc = (*doc_collection)[index].as_map();
-              if (!doc->has_key("_id"))
-                (*doc)["_id"] = shcore::Value(get_new_uuid());
-
-              // Appends the document to the list to be inserted
-              json_docs.push_back((*doc_collection)[index].repr());
-            }
-            else
-              throw shcore::Exception::argument_error("Invalid document specified on list for add operation.");
-          }
-          break;
-        default:
-          throw shcore::Exception::argument_error("Invalid document specified on add operation.");
-          break;
-      }
-    }
-
-    // Here it gors the implementation in case no Documents are specified
-    // i.e. uses an iterator instead
-    else
-      throw shcore::Exception::logic_error("No documents specified on add operation.");
-
-    int mid = Mysqlx::ClientMessages::CRUD_INSERT;
-
-    // Assumming there were docs, if not a failure should have been raised already
-    // Creates the row list
-    for (size_t index = 0; index < json_docs.size(); index++)
-    {
-      Mysqlx::Sql::Row* row = insert.mutable_row()->Add();
-      X_row::add_field(row, shcore::Value(json_docs[index]));
-    }
-
-    Message* msg = _protobuf->send_receive_message(mid, &insert, Mysqlx::ServerMessages::SQL_STMT_EXECUTE_OK, "Inserting documents...");
-
-    Mysqlx::Sql::StmtExecuteOk *insert_ok = dynamic_cast<Mysqlx::Sql::StmtExecuteOk *>(msg);
-
-    if (insert_ok->has_rows_affected())
-      affected_rows = insert_ok->rows_affected();
-    if (insert_ok->has_last_insert_id())
-      last_insert_id = insert_ok->last_insert_id();
-  }
-  CATCH_AND_TRANSLATE();
-
-  // Creates a resultset with the received info
-  X_resultset* result = new X_resultset(shared_from_this(), false, _next_stmt_id, affected_rows, 0, 0, NULL, 0, NULL, false);
-
-  return shcore::Value(boost::shared_ptr<shcore::Object_bridge>(result));
-}
-
-shcore::Value X_connection::crud_collection_find(shcore::Value::Map_type_ref data)
-{
-  // The definitive implementation should consider many different cases
-  // and also many validations must be included
-  uint64_t affected_rows = 0;
-  uint64_t last_insert_id = 0;
-  uuid_type uuid;
-  int mid;
-  Message* msg;
-
-  // Reads any remaining stuff from the previos result
-  // To let the comm in a clean state
-  if (_last_result && !_last_result->is_all_fetch_done())
-    _last_result->flush_messages(true);
-
-  _timer.start();
-  ++_next_stmt_id;
-
-  bool has_data = false;
-
-  try
-  {
-    Mysqlx::Crud::Find find;
-    find.mutable_collection()->set_schema((*data)["schema"].as_string());
-    find.mutable_collection()->set_name((*data)["collection"].as_string());
-    find.set_data_model(Mysqlx::Crud::DataModel((*data)["data_model"].as_int()));
-
-    if (data->has_key("find.SearchCondition"))
-    {
-      std::string filter = (*data)["find.SearchCondition"].as_string();
-      find.set_allocated_criteria(mysqlx::parser::parse_collection_filter(filter).release());
-    }
-
-    if (data->has_key("fields.SearchFields"))
-    {
-      std::string str_columns = (*data)["fields.SearchFields"].as_string();
-      mysqlx::parser::parse_collection_column_list_with_alias(*find.mutable_projection(), str_columns);
-    }
-
-    if (data->has_key("groupby.SearchFields"))
-    {
-      // TODO: Not supported by protocol
-    }
-
-    if (data->has_key("having.SearchCondition"))
-    {
-      // TODO: Not supported by protocol
-    }
-
-    if (data->has_key("SortFields"))
-    {
-      // TODO: Set the ordering when the Srot parser is implemented
-    }
-
-    if (data->has_key("NumberOfRows"))
-    {
-      find.mutable_limit()->set_skip((*data)["NumberOfRows"].as_int());
-
-      if (data->has_key("LimitOffset"))
-        find.mutable_limit()->set_offset((*data)["LimitOffset"].as_int());
-    }
-
-    mid = Mysqlx::ClientMessages::CRUD_FIND;
-
-    std::set<int> responses;
-    responses.insert(Mysqlx::ServerMessages::SQL_STMT_EXECUTE_OK);
-    responses.insert(Mysqlx::ServerMessages::SQL_COLUMN_META_DATA);
-
-    msg = _protobuf->send_receive_message(mid, &find, responses, "Finding documents...");
-
-    has_data = mid == Mysqlx::ServerMessages::SQL_COLUMN_META_DATA;
-  }
-  CATCH_AND_TRANSLATE();
-
-  Collection_resultset* result = new Collection_resultset(shared_from_this(), has_data, _next_stmt_id, 0, 0, 0, NULL, mid, msg, false, boost::shared_ptr<shcore::Value::Map_type>());
-
-  // If no data will be returned then loads the resultset metadata
-  // And fills the timer data as well
-  if (mid == Mysqlx::ServerMessages::SQL_STMT_EXECUTE_OK)
-  {
-    _timer.end();
-
-    result->set_result_metadata(msg);
-    result->reset(_timer.raw_duration());
-  }
-
-  // Creates the resultset
-  _last_result.reset(result);
-
-  // Calls next result so the metadata is loaded
-  // if any result
-  if (_last_result->has_resultset())
-    next_result(_last_result.get(), true);
-
-  return shcore::Value(boost::shared_ptr<shcore::Object_bridge>(_last_result));
-}
-
-shcore::Value X_connection::crud_collection_remove(shcore::Value::Map_type_ref data)
-{
-  // The definitive implementation should consider many different cases
-  // and also many validations must be included
-  uint64_t affected_rows = 0;
-  uint64_t last_insert_id = 0;
-  uuid_type uuid;
-  int mid;
-  Message* msg;
-
-  // Reads any remaining stuff from the previos result
-  // To let the comm in a clean state
-  if (_last_result && !_last_result->is_all_fetch_done())
-    _last_result->flush_messages(true);
-
-  _timer.start();
-  ++_next_stmt_id;
-
-  bool has_data = false;
-
-  try
-  {
-    Mysqlx::Crud::Delete remove;
-    remove.mutable_collection()->set_schema((*data)["schema"].as_string());
-    remove.mutable_collection()->set_name((*data)["collection"].as_string());
-    remove.set_data_model(Mysqlx::Crud::DataModel((*data)["data_model"].as_int()));
-
-    if (data->has_key("SearchCondition"))
-    {
-      std::string filter = (*data)["SearchCondition"].as_string();
-      remove.set_allocated_criteria(mysqlx::parser::parse_collection_filter(filter).release());
-    }
-
-    if (data->has_key("SortFields"))
-    {
-      // TODO: Set the ordering when the Srot parser is implemented
-    }
-
-    if (data->has_key("NumberOfRows"))
-      remove.mutable_limit()->set_skip((*data)["NumberOfRows"].as_int());
-
-    mid = Mysqlx::ClientMessages::CRUD_DELETE;
-
-    msg = _protobuf->send_receive_message(mid, &remove, Mysqlx::ServerMessages::SQL_STMT_EXECUTE_OK, "Deleting documents...");
-  }
-  CATCH_AND_TRANSLATE();
-
-  X_resultset* result = new X_resultset(shared_from_this(), false, _next_stmt_id, 0, 0, 0, NULL, mid, msg, false);
-
-  _timer.end();
-  result->set_result_metadata(msg);
-  result->reset(_timer.raw_duration());
-
-  // Creates the resultset
-  _last_result.reset(result);
-
-  return shcore::Value(boost::shared_ptr<shcore::Object_bridge>(_last_result));
-}
-
-shcore::Value X_connection::crud_table_insert(shcore::Value::Map_type_ref data)
-{
-  //----SAMPLE IMPLEMENTATION
-  // This implementation allows performing a table insert operation as:
-  //
-  // table.insert(['col1', 'col2','col3']).values(['val1', val2', 'val3']).run()
-  //
-  // The definitive implementation should consider many different cases
-  // and also many validations must be included
-  uint64_t affected_rows = 0;
-  uint64_t last_insert_id = 0;
-
-  try
-  {
-    Mysqlx::Crud::Insert insert;
-    insert.mutable_collection()->set_schema((*data)["schema"].as_string());
-    insert.mutable_collection()->set_name((*data)["collection"].as_string());
-    insert.set_data_model(Mysqlx::Crud::DataModel((*data)["data_model"].as_int()));
-
-    if (data->has_key("Fields"))
-    {
-      if (data->has_key("Values"))
-      {
-        shcore::Value::Array_type_ref fields = (*data)["Fields"].as_array();
-        shcore::Value::Array_type_ref values = (*data)["Values"].as_array();
-
-        if (fields->size() == values->size())
-        {
-          Mysqlx::Crud::Column *column;
-          size_t index;
-
-          // Creates the projection
-          for (index = 0; index < fields->size(); index++)
-          {
-            column = insert.mutable_projection()->Add();
-            column->set_name(fields->at(index).as_string());
-          }
-
-          // Creates the row list
-          Mysqlx::Sql::Row *row = insert.mutable_row()->Add();
-          for (index = 0; index < fields->size(); index++)
-            X_row::add_field(row, values->at(index));
-        }
-      }
-    }
-    else if (data->has_key("FieldsAndValues"))
-    {
-    }
-
-    int mid = Mysqlx::ClientMessages::CRUD_INSERT;
-    Message* msg = _protobuf->send_receive_message(mid, &insert, Mysqlx::ServerMessages::SQL_STMT_EXECUTE_OK, "Inserting record...");
-
-    Mysqlx::Sql::StmtExecuteOk *insert_ok = dynamic_cast<Mysqlx::Sql::StmtExecuteOk *>(msg);
-
-    if (insert_ok->has_rows_affected())
-      affected_rows = insert_ok->rows_affected();
-    if (insert_ok->has_last_insert_id())
-      last_insert_id = insert_ok->last_insert_id();
-  }
-  CATCH_AND_TRANSLATE();
-
-  // Creates the resultset
-  X_resultset* result = new X_resultset(shared_from_this(), false, _next_stmt_id, affected_rows, 0, 0, NULL, 0, NULL, false);
-
-  return shcore::Value(boost::shared_ptr<shcore::Object_bridge>(result));
-}
-
-bool X_connection::next_result(Base_resultset *target, bool first_result)
-{
-  bool ret_val = false;
-  X_resultset *real_target = dynamic_cast<X_resultset *> (target);
-
-  // Just to ensure the right instance was received as parameter
-  if (real_target && real_target->has_resultset())
-  {
-    // The first call to next result is done to fetch the metadata
-    // Subsequent calls to next_result need to ensure all the messages on the
-    // tx buffer are cleared out first
-    if (!first_result && !real_target->is_current_fetch_done())
-      real_target->flush_messages(false);
-
-    if (!real_target->is_all_fetch_done())
-    {
-      ret_val = true;
-      real_target->fetch_metadata();
-
-      _timer.end();
-      real_target->reset(_timer.raw_duration());
-    }
-  }
-
-  return ret_val;
-}
-
-X_row::X_row(Mysqlx::Sql::Row *row, std::vector<Field>* metadata) : Base_row(metadata), _row(row)
-{
-}
-
-shcore::Value X_row::get_value(int index)
-{
-  Mysqlx::Datatypes::Any field(_row->field(index));
-
-  // TODO: Is there a way a field has nothing (like in mysql NULL)
-  // TODO: What if field.has_object and field.has_array
-  if (field.has_scalar())
-  {
-    if (field.scalar().has_v_bool())
-      return shcore::Value(field.scalar().v_bool());
-    else if (field.scalar().has_v_double())
-      return shcore::Value(field.scalar().v_double());
-    else if (field.scalar().has_v_float())
-      return shcore::Value(field.scalar().v_float());
-    //else if (field.scalar().has_v_null())
-    //  return shcore::Value::Null();
-    else if (field.scalar().has_v_string())
-      return shcore::Value(field.scalar().v_string().value());
-    else if (field.scalar().has_v_opaque())
-      return shcore::Value(field.scalar().v_opaque());
-    else if (field.scalar().has_v_signed_int())
-      return shcore::Value(field.scalar().v_signed_int());
-    else if (field.scalar().has_v_unsigned_int())
-      return shcore::Value(int64_t(field.scalar().v_unsigned_int()));
-  }
-
-  return shcore::Value::Null();
-}
-
-std::string X_row::get_value_as_string(int index)
-{
-  shcore::Value value = get_value(index);
-  return value.repr();
-}
-
-void X_row::add_field(Mysqlx::Sql::Row *row, shcore::Value value)
-{
-  Mysqlx::Datatypes::Any *field = row->add_field();
-
-  field->set_type(Mysqlx::Datatypes::Any::SCALAR);
-
-  switch (value.type)
-  {
-    case Null:
-    case Undefined:
-      field->mutable_scalar()->set_type(Mysqlx::Datatypes::Scalar::V_NULL);
-      break;
-    case Bool:
-      field->mutable_scalar()->set_type(Mysqlx::Datatypes::Scalar::V_BOOL);
-      field->mutable_scalar()->set_v_bool(value.as_bool());
-      break;
-    case Float:
-      field->mutable_scalar()->set_type(Mysqlx::Datatypes::Scalar::V_DOUBLE);
-      field->mutable_scalar()->set_v_double(value.as_double());
-      break;
-    case Integer:
-      field->mutable_scalar()->set_type(Mysqlx::Datatypes::Scalar::V_UINT);
-      field->mutable_scalar()->set_v_unsigned_int(value.as_int());
-      break;
-    case String:
-      field->mutable_scalar()->set_type(Mysqlx::Datatypes::Scalar::V_STRING);
-      field->mutable_scalar()->mutable_v_string()->set_value(value.as_string());
-      break;
-    case Array:
-      break;
-    case Function:
-      break;
-    case Map:
-      break;
-    case MapRef:
-      break;
-    case Object:
-      break;
-  }
-}
-
-X_row::~X_row()
-{
-  if (_row)
-    delete _row;
-}
\ No newline at end of file
diff --git a/modules/mod_mysqlx.h b/modules/mod_mysqlx.h
deleted file mode 100644
index a49fcd2d06054e8e41ca78f2f971a3782c0f6631..0000000000000000000000000000000000000000
--- a/modules/mod_mysqlx.h
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Copyright (c) 2014, 2015 Oracle and/or its affiliates. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; version 2 of the
- * License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-// MySQL DB access module, for use by plugins and others
-// For the module that implements interactive DB functionality see mod_db
-
-#ifndef _MOD_MYSQLX_H_
-#define _MOD_MYSQLX_H_
-
-#include "shellcore/types.h"
-#include "shellcore/types_cpp.h"
-#include "mod_connection.h"
-
-#include <list>
-#include "mysqlx_test_connector.h"
-
-namespace mysh
-{
-  class X_resultset;
-  class MOD_PUBLIC X_connection : public mysh::Base_connection, public boost::enable_shared_from_this<X_connection>
-  {
-    typedef boost::asio::ip::tcp tcp;
-  public:
-    X_connection(const std::string &uri, const char *password = NULL);
-    virtual ~X_connection();
-
-    virtual std::string class_name() const { return "X_connection"; }
-
-    void auth(const char *user, const char *pass);
-    void flush();
-
-    // Connector Implementation
-    virtual shcore::Value close(const shcore::Argument_list &args);
-    virtual shcore::Value sql(const std::string &query, shcore::Value options);
-    virtual shcore::Value sql_one(const std::string &query);
-
-    shcore::Value crud_execute(const std::string& id, shcore::Value::Map_type_ref data);
-    shcore::Value crud_table_insert(shcore::Value::Map_type_ref data);
-    shcore::Value crud_collection_add(shcore::Value::Map_type_ref data);
-    shcore::Value crud_collection_find(shcore::Value::Map_type_ref data);
-    shcore::Value crud_collection_remove(shcore::Value::Map_type_ref data);
-
-    virtual bool next_result(Base_resultset *target, bool first_result = false);
-
-    static boost::shared_ptr<Object_bridge> create(const shcore::Argument_list &args);
-
-    boost::shared_ptr< ::mysqlx::Mysqlx_test_connector> get_protobuf() { return _protobuf; }
-
-  protected:
-    boost::shared_ptr< ::mysqlx::Mysqlx_test_connector> _protobuf;
-
-  private:
-    int _next_stmt_id;
-    X_resultset *_sql(const std::string &query, shcore::Value options);
-    boost::shared_ptr<X_resultset> _last_result;
-  };
-
-  class MOD_PUBLIC X_row : public Base_row
-  {
-  public:
-    X_row(Mysqlx::Sql::Row *row, std::vector<Field>* metadata = NULL);
-    virtual ~X_row();
-
-    virtual shcore::Value get_value(int index);
-    virtual std::string get_value_as_string(int index);
-
-    static void add_field(Mysqlx::Sql::Row *row, shcore::Value value);
-
-  private:
-    Mysqlx::Sql::Row *_row;
-  };
-};
-
-#endif
diff --git a/modules/mod_mysqlx_collection.cc b/modules/mod_mysqlx_collection.cc
new file mode 100644
index 0000000000000000000000000000000000000000..fe4f98d3b623e828ed9494b5aacbf5fd640a9d17
--- /dev/null
+++ b/modules/mod_mysqlx_collection.cc
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#include "mod_mysqlx_schema.h"
+#include "mod_mysqlx_collection.h"
+#include <boost/bind.hpp>
+
+#include "mod_crud_collection_add.h"
+
+using namespace mysh;
+using namespace mysh::mysqlx;
+using namespace shcore;
+
+Collection::Collection(boost::shared_ptr<Schema> owner, const std::string &name)
+: DatabaseObject(owner->_session.lock(), owner, name), _collection_impl(owner->_schema_impl->getCollection(name))
+{
+  add_method("add", boost::bind(&Collection::add_, this, _1), "searchCriteria", shcore::String, NULL);
+  add_method("modify", boost::bind(&Collection::modify_, this, _1), "searchCriteria", shcore::String, NULL);
+  add_method("find", boost::bind(&Collection::find_, this, _1), "searchCriteria", shcore::String, NULL);
+  add_method("remove", boost::bind(&Collection::remove_, this, _1), "searchCriteria", shcore::String, NULL);
+}
+
+Collection::Collection(boost::shared_ptr<const Schema> owner, const std::string &name) :
+Collection(boost::const_pointer_cast<Schema>(owner), name)
+{
+}
+
+Collection::~Collection()
+{
+}
+
+shcore::Value Collection::add_(const shcore::Argument_list &args)
+{
+  std::string doc;
+  args.ensure_count(0, 1, "Collection::add");
+
+  if (args.size())
+    doc = args.string_at(0);
+
+  return shcore::Value::wrap(new CollectionAdd(_collection_impl->add(::mysqlx::Document(doc))));
+}
+
+shcore::Value Collection::modify_(const shcore::Argument_list &args)
+{
+  std::string searchCriteria;
+  args.ensure_count(1, "Collection::modify");
+  searchCriteria = args.string_at(0);
+  // return shcore::Value::wrap(new CollectionFind(_coll->find(searchCriteria)));
+  return shcore::Value();
+}
+
+shcore::Value Collection::remove_(const shcore::Argument_list &args)
+{
+  std::string searchCriteria;
+  args.ensure_count(1, "Collection::remove");
+  searchCriteria = args.string_at(0);
+  // return shcore::Value::wrap(new CollectionFind(_coll->find(searchCriteria)));
+  return shcore::Value();
+}
+
+shcore::Value Collection::find_(const shcore::Argument_list &args)
+{
+  std::string searchCriteria;
+  args.ensure_count(1, "Collection::find");
+  searchCriteria = args.string_at(0);
+  // return shcore::Value::wrap(new CollectionFind(_coll->find(searchCriteria)));
+  return shcore::Value();
+}
\ No newline at end of file
diff --git a/modules/mod_mysqlx_collection.h b/modules/mod_mysqlx_collection.h
new file mode 100644
index 0000000000000000000000000000000000000000..ec7a05ec0acf570f4f1fba73a956f89c5d192b89
--- /dev/null
+++ b/modules/mod_mysqlx_collection.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+// Interactive Table access module
+// (the one exposed as the table members of the db object in the shell)
+
+#ifndef _MOD_MYSQLX_COLLECTION_H_
+#define _MOD_MYSQLX_COLLECTION_H_
+
+#include "base_database_object.h"
+#include "shellcore/types.h"
+#include "shellcore/types_cpp.h"
+
+namespace mysh
+{
+  namespace mysqlx
+  {
+    class Schema;
+
+    class Collection : public DatabaseObject
+    {
+    public:
+      Collection(boost::shared_ptr<Schema> owner, const std::string &name);
+      Collection(boost::shared_ptr<const Schema> owner, const std::string &name);
+      ~Collection();
+
+      virtual std::string class_name() const { return "Collection"; }
+
+    private:
+      shcore::Value add_(const shcore::Argument_list &args);
+      shcore::Value find_(const shcore::Argument_list &args);
+      shcore::Value modify_(const shcore::Argument_list &args);
+      shcore::Value remove_(const shcore::Argument_list &args);
+
+    private:
+      boost::shared_ptr< ::mysqlx::Collection> _collection_impl;
+    };
+  }
+}
+
+#endif
diff --git a/modules/mod_mysqlx_resultset.cc b/modules/mod_mysqlx_resultset.cc
new file mode 100644
index 0000000000000000000000000000000000000000..a1943ec2142762a4eb57b80fcb0edf6bbb7a3657
--- /dev/null
+++ b/modules/mod_mysqlx_resultset.cc
@@ -0,0 +1,186 @@
+/*
+ * Copyright (c) 2014, 2015 Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#include "mod_mysqlx_resultset.h"
+#include "mysqlx.h"
+
+using namespace mysh;
+using namespace shcore;
+using namespace mysh::mysqlx;
+
+Resultset::Resultset(boost::shared_ptr< ::mysqlx::Result> result)
+: _result(result)
+{
+}
+
+Resultset::~Resultset(){}
+
+shcore::Value Resultset::get_member(const std::string &prop) const
+{
+  Value ret_val;
+  if (prop == "fetchedRowCount")
+    ret_val = Value(0);
+  else if (prop == "affectedRows")
+    ret_val = Value(_result->affectedRows());
+  else if (prop == "warningCount")
+    ret_val = Value(0); // TODO: Warning count not being received on X Protocol
+  else if (prop == "executionTime")
+    ret_val = Value("0"); // TODO: Execution time not being provided on X Protocol
+  else if (prop == "lastInsertId")
+    ret_val = Value(_result->lastInsertId());
+  else if (prop == "info")
+    ret_val = Value(""); // TODO: Info not being provided on X Protocol
+  else if (prop == "hasData")
+    ret_val = Value(_result->columnMetadata()->size() > 0);
+  else if (prop == "columnMetadata")
+  {
+    boost::shared_ptr<shcore::Value::Array_type> array(new shcore::Value::Array_type);
+
+    int num_fields = _result->columnMetadata()->size();
+
+    for (int i = 0; i < num_fields; i++)
+    {
+      boost::shared_ptr<shcore::Value::Map_type> map(new shcore::Value::Map_type);
+
+      (*map)["catalog"] = shcore::Value(_result->columnMetadata()->at(i).catalog);
+      //(*map)["db"] = shcore::Value(_result->columnMetadata()->at(i).db);
+      (*map)["table"] = shcore::Value(_result->columnMetadata()->at(i).table);
+      (*map)["org_table"] = shcore::Value(_result->columnMetadata()->at(i).original_table);
+      (*map)["name"] = shcore::Value(_result->columnMetadata()->at(i).name);
+      (*map)["org_name"] = shcore::Value(_result->columnMetadata()->at(i).original_name);
+      (*map)["charset"] = shcore::Value(_result->columnMetadata()->at(i).charset);
+      (*map)["length"] = shcore::Value(int(_result->columnMetadata()->at(i).length));
+      (*map)["type"] = shcore::Value(int(_result->columnMetadata()->at(i).type)); // TODO: Translate to MySQL Type
+      (*map)["flags"] = shcore::Value(int(_result->columnMetadata()->at(i).flags));
+      (*map)["decimal"] = shcore::Value(int(_result->columnMetadata()->at(i).fractional_digits)); // TODO: decimals??
+      (*map)["max_length"] = shcore::Value(0);
+      (*map)["name_length"] = shcore::Value(int(_result->columnMetadata()->at(i).name.length()));
+
+      // Temporal hack to identify numeric values
+      ::mysqlx::FieldType type = _result->columnMetadata()->at(i).type;
+      (*map)["is_numeric"] = shcore::Value(type == ::mysqlx::SINT ||
+                                           type == ::mysqlx::UINT ||
+                                           type == ::mysqlx::DOUBLE ||
+                                           type == ::mysqlx::FLOAT ||
+                                           type == ::mysqlx::DECIMAL);
+
+      array->push_back(shcore::Value(map));
+
+      return shcore::Value(array);
+    }
+  }
+  else
+    ret_val = BaseResultset::get_member(prop);
+
+  return ret_val;
+}
+
+shcore::Value Resultset::next(const shcore::Argument_list &args)
+{
+  boost::shared_ptr<std::vector< ::mysqlx::ColumnMetadata>> metadata = _result->columnMetadata();
+  if (metadata->size() > 0)
+  {
+    ::mysqlx::Row *row = _result->next();
+    if (row)
+    {
+      mysh::Row *value_row = new mysh::Row();
+
+      for (size_t index = 0; index < metadata->size(); index++)
+      {
+        Value field_value;
+        switch (metadata->at(index).type)
+        {
+          case ::mysqlx::SINT:
+            field_value = Value(row->sInt64Field(index));
+          case ::mysqlx::UINT:
+            field_value = Value(row->sInt64Field(index));//TODO: add UInt64 in shcore Value
+            //return Value(_row->uInt64Field(index));
+          case ::mysqlx::DOUBLE:
+            field_value = Value(row->doubleField(index));
+          case ::mysqlx::FLOAT:
+            field_value = Value(row->floatField(index));
+          case ::mysqlx::BYTES:
+            field_value = Value(row->stringField(index));
+          case ::mysqlx::TIME:
+          case ::mysqlx::DATETIME:
+          case ::mysqlx::SET:
+          case ::mysqlx::ENUM:
+          case ::mysqlx::BIT:
+          case ::mysqlx::DECIMAL:
+            //XXX TODO
+            break;
+        }
+        value_row->add_item(metadata->at(index).name, field_value);
+      }
+
+      return shcore::Value::wrap(value_row);
+    }
+  }
+  return shcore::Value();
+}
+
+shcore::Value Resultset::all(const shcore::Argument_list &args)
+{
+  Value::Array_type_ref array(new Value::Array_type());
+
+  std::string function = class_name() + "::all";
+  bool raw = false;
+
+  args.ensure_count(0, function.c_str());
+
+  // Gets the next row
+  Value record = next(args);
+  while (record)
+  {
+    array->push_back(record);
+    record = next(args);
+  }
+
+  return Value(array);
+}
+
+shcore::Value Resultset::next_result(const shcore::Argument_list &args)
+{
+  args.ensure_count(0, "Resultset::nextResult");
+
+  return shcore::Value(_result->nextResult());
+}
+
+Collection_resultset::Collection_resultset(boost::shared_ptr< ::mysqlx::Result> result)
+: Resultset(result)
+{
+}
+
+shcore::Value Collection_resultset::next(const shcore::Argument_list &args)
+{
+  Value ret_val = Value::Null();
+
+  std::string function = class_name() + "::next";
+  bool raw = false;
+
+  args.ensure_count(0, function.c_str());
+
+  if (_result->columnMetadata()->size())
+  {
+    std::auto_ptr< ::mysqlx::Row> r(_result->next());
+    if (r.get())
+      return Value::parse(r->stringField(0));
+  }
+  return shcore::Value();
+}
\ No newline at end of file
diff --git a/modules/mod_mysqlx_resultset.h b/modules/mod_mysqlx_resultset.h
new file mode 100644
index 0000000000000000000000000000000000000000..e927b48bd79cddca72afad0a7ebf6b9fede7b16c
--- /dev/null
+++ b/modules/mod_mysqlx_resultset.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2015 Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+// MySQL DB access module, for use by plugins and others
+// For the module that implements interactive DB functionality see mod_db
+
+#ifndef _MOD_XRESULT_H_
+#define _MOD_XRESULT_H_
+
+#include "base_resultset.h"
+
+namespace mysqlx
+{
+  class Result;
+}
+
+namespace mysh
+{
+  namespace mysqlx
+  {
+    class Resultset : public BaseResultset
+    {
+    public:
+      Resultset(boost::shared_ptr< ::mysqlx::Result> result);
+
+      virtual ~Resultset();
+
+      virtual std::string class_name() const { return "Resultset"; }
+      virtual shcore::Value get_member(const std::string &prop) const;
+
+      virtual shcore::Value next(const shcore::Argument_list &args);
+      virtual shcore::Value all(const shcore::Argument_list &args);
+      virtual shcore::Value next_result(const shcore::Argument_list &args);
+
+      int get_cursor_id() { return _cursor_id; }
+
+    protected:
+      boost::shared_ptr< ::mysqlx::Result> _result;
+
+    private:
+      int _cursor_id;
+    };
+
+    class Collection_resultset : public Resultset
+    {
+    public:
+      Collection_resultset(boost::shared_ptr< ::mysqlx::Result> result);
+
+      virtual std::string class_name() const  { return "CollectionResultset"; }
+      virtual shcore::Value next(const shcore::Argument_list &args);
+    };
+  }
+};
+
+#endif
diff --git a/modules/mod_mysqlx_schema.cc b/modules/mod_mysqlx_schema.cc
new file mode 100644
index 0000000000000000000000000000000000000000..5f220a6adee70590f4b69137ea34ebd9584d7512
--- /dev/null
+++ b/modules/mod_mysqlx_schema.cc
@@ -0,0 +1,242 @@
+/*
+ * Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#include "mod_mysqlx_schema.h"
+#include "mod_mysqlx_session.h"
+
+#include "shellcore/object_factory.h"
+#include "shellcore/shell_core.h"
+#include "shellcore/lang_base.h"
+
+#include "shellcore/proxy_object.h"
+
+#include "mod_mysqlx_session.h"
+#include "mod_mysqlx_table.h"
+#include "mod_mysqlx_collection.h"
+#include "mod_mysqlx_view.h"
+
+#include <boost/bind.hpp>
+#include <boost/lexical_cast.hpp>
+#include <boost/format.hpp>
+#include <boost/pointer_cast.hpp>
+
+using namespace mysh;
+using namespace mysh::mysqlx;
+using namespace shcore;
+
+Schema::Schema(boost::shared_ptr<ApiBaseSession> session, const std::string &schema)
+: DatabaseObject(session, NULL, schema), _schema_impl(session->session_obj()->getSchema(schema))
+{
+  add_method("getTables", boost::bind(&DatabaseObject::get_member_method, this, _1, "getTables", "tables"), "name", shcore::String, NULL);
+  add_method("getCollections", boost::bind(&DatabaseObject::get_member_method, this, _1, "getCollections", "collections"), "name", shcore::String, NULL);
+  add_method("getViews", boost::bind(&DatabaseObject::get_member_method, this, _1, "getViews", "views"), "name", shcore::String, NULL);
+
+  add_method("getTable", boost::bind(&Schema::getTable, this, _1), "name", shcore::String, NULL);
+  add_method("getCollection", boost::bind(&Schema::getCollection, this, _1), "name", shcore::String, NULL);
+  add_method("getView", boost::bind(&Schema::getView, this, _1), "name", shcore::String, NULL);
+
+  _tables = Value::new_map().as_map();
+  _views = Value::new_map().as_map();
+  _collections = Value::new_map().as_map();
+}
+
+Schema::Schema(boost::shared_ptr<const ApiBaseSession> session, const std::string &schema) :
+Schema(boost::const_pointer_cast<ApiBaseSession>(session), schema)
+{
+}
+
+Schema::~Schema()
+{
+}
+
+void Schema::cache_table_objects()
+{
+  try
+  {
+    boost::shared_ptr<Session> sess(boost::dynamic_pointer_cast<Session>(_session.lock()));
+    if (sess)
+    {
+      {
+        sess->flush_last_result();
+        std::auto_ptr< ::mysqlx::Result> result(sess->session_obj()->executeSql("show full tables in `" + this->_name + "`"));
+        std::auto_ptr< ::mysqlx::Row> row;
+        for (;;)
+        {
+          row.reset(result->next());
+          if (row.get())
+          {
+            std::string object_name = row->stringField(0);
+            std::string object_type = row->stringField(1);
+            if (object_type == "BASE TABLE" || object_type == "LOCAL TEMPORARY")
+            {
+              (*_tables)[object_name] = Value::wrap(new Table(shared_from_this(), object_name));
+
+              // TODO: Temporary hack to allow accessing collections throught getCollection.
+              //       Collections can't be accessed until show full tables or other mechanism
+              //       is in place.
+              //       Note: all tables can be accessed as collections, it's user responsibility for now
+              //       to only access this way real collections
+              (*_collections)[object_name] = Value::wrap(new Collection(shared_from_this(), object_name));
+            }
+            else if (object_type == "VIEW" || object_type == "SYSTEM VIEW")
+              (*_views)[object_name] = Value::wrap(new View(shared_from_this(), object_name));
+            //else
+            //  (*_collections)[object_name] = Value::wrap(new Collection(shared_from_this(), object_name));
+          }
+          else
+            break;
+        }
+      }
+    }
+  }
+  CATCH_AND_TRANSLATE();
+}
+
+std::vector<std::string> Schema::get_members() const
+{
+  std::vector<std::string> members(DatabaseObject::get_members());
+  members.push_back("tables");
+  members.push_back("collections");
+  members.push_back("views");
+
+  for (Value::Map_type::const_iterator iter = _tables->begin();
+       iter != _tables->end(); ++iter)
+  {
+    members.push_back(iter->first);
+  }
+  return members;
+}
+
+Value Schema::get_member(const std::string &prop) const
+{
+  // Retrieves the member first from the parent
+  Value ret_val;
+
+  // Check the member is on the base classes before attempting to
+  // retrieve it since it may throw invalid member otherwise
+  // If not on the parent classes and not here then we can safely assume
+  // it is must be either a table, collection or view and attempt loading it as such
+  if (DatabaseObject::has_member(prop))
+    ret_val = DatabaseObject::get_member(prop);
+  else if (prop == "tables")
+    ret_val = Value(_tables);
+  else if (prop == "collections")
+    ret_val = Value(_collections);
+  else if (prop == "views")
+    ret_val = Value(_views);
+  else
+  {
+    // At this point the property should be one of table
+    // collection or view
+    ret_val = find_in_collection(prop, _tables);
+
+    if (!ret_val)
+      ret_val = find_in_collection(prop, _collections);
+
+    if (!ret_val)
+      ret_val = find_in_collection(prop, _views);
+
+    if (!ret_val)
+      ret_val = _load_object(prop);
+
+    if (!ret_val)
+      throw Exception::attrib_error("Invalid object member " + prop);
+  }
+
+  return ret_val;
+}
+
+shcore::Value Schema::find_in_collection(const std::string& name, boost::shared_ptr<shcore::Value::Map_type>source) const
+{
+  Value::Map_type::const_iterator iter = source->find(name);
+  if (iter != source->end())
+    return Value(boost::shared_ptr<Object_bridge>(iter->second.as_object()));
+  else
+    return Value();
+}
+
+Value Schema::_load_object(const std::string& name, const std::string& type) const
+{
+  Value ret_val;
+  try
+  {
+    boost::shared_ptr<Session> sess(boost::dynamic_pointer_cast<Session>(_session.lock()));
+    if (sess)
+    {
+      {
+        sess->flush_last_result();
+        std::auto_ptr< ::mysqlx::Result> result(sess->session_obj()->executeSql("show full tables in `" + _name + "` like '" + name + "';"));
+        std::auto_ptr< ::mysqlx::Row> row(result->next());
+        if (row.get())
+        {
+          std::string object_name = row->stringField(0);
+          std::string object_type = row->stringField(1);
+
+          if (type.empty() || (type == "TABLE" && (object_type == "BASE TABLE" || object_type == "LOCAL TEMPORARY")))
+          {
+            ret_val = Value::wrap(new Table(shared_from_this(), object_name));
+            (*_tables)[name] = ret_val;
+          }
+          else if (type.empty() || (type == "VIEW" && (object_type == "VIEW" || object_type == "SYSTEM VIEW")))
+          {
+            ret_val = Value::wrap(new Table(shared_from_this(), object_name));
+            (*_views)[name] = ret_val;
+          }
+          else if (type.empty() || (type == "COLLECTION"))
+          {
+            ret_val = Value::wrap(new Table(shared_from_this(), object_name));
+            (*_collections)[name] = ret_val;
+          }
+        }
+
+        result->discardData();
+      }
+    }
+  }
+  CATCH_AND_TRANSLATE();
+
+  return ret_val;
+}
+
+shcore::Value Schema::getTable(const shcore::Argument_list &args)
+{
+  args.ensure_count(1, (class_name() + "::getTable").c_str());
+
+  std::string name = args.string_at(0);
+
+  return find_in_collection(name, _tables);
+}
+
+shcore::Value Schema::getCollection(const shcore::Argument_list &args)
+{
+  args.ensure_count(1, (class_name() + "::getCollection").c_str());
+
+  std::string name = args.string_at(0);
+
+  return find_in_collection(name, _collections);
+}
+
+shcore::Value Schema::getView(const shcore::Argument_list &args)
+{
+  args.ensure_count(1, (class_name() + "::getCollection").c_str());
+
+  std::string name = args.string_at(0);
+
+  return find_in_collection(name, _views);
+}
\ No newline at end of file
diff --git a/modules/mod_mysqlx_schema.h b/modules/mod_mysqlx_schema.h
new file mode 100644
index 0000000000000000000000000000000000000000..5158ec0eef907c3eea4295963e41855b715abe16
--- /dev/null
+++ b/modules/mod_mysqlx_schema.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+// Interactive DB access module
+// (the one exposed as the db variable in the shell)
+
+#ifndef _MOD_SCHEMA_H_
+#define _MOD_SCHEMA_H_
+
+#include "mod_common.h"
+#include "base_database_object.h"
+#include "shellcore/types.h"
+#include "shellcore/types_cpp.h"
+
+#include "mysqlx_crud.h"
+
+#include <boost/enable_shared_from_this.hpp>
+#include <boost/weak_ptr.hpp>
+
+namespace shcore
+{
+  class Proxy_object;
+};
+
+namespace mysh
+{
+  namespace mysqlx
+  {
+    class ApiBaseSession;
+    class Table;
+    class Collection;
+
+    class MOD_PUBLIC Schema : public DatabaseObject, public boost::enable_shared_from_this<Schema>
+    {
+    public:
+      Schema(boost::shared_ptr<ApiBaseSession> owner, const std::string &name);
+      Schema(boost::shared_ptr<const ApiBaseSession> owner, const std::string &name);
+      ~Schema();
+
+      virtual std::string class_name() const { return "Schema"; };
+
+      virtual std::vector<std::string> get_members() const;
+
+      virtual shcore::Value get_member(const std::string &prop) const;
+
+      void cache_table_objects();
+
+      friend class Table;
+      friend class Collection;
+      friend class View;
+    private:
+      shcore::Value _load_object(const std::string& name, const std::string& type = "") const;
+      boost::shared_ptr< ::mysqlx::Schema> _schema_impl;
+      boost::shared_ptr<shcore::Value::Map_type> _tables;
+      boost::shared_ptr<shcore::Value::Map_type> _collections;
+      boost::shared_ptr<shcore::Value::Map_type> _views;
+
+      shcore::Value find_in_collection(const std::string& name, boost::shared_ptr<shcore::Value::Map_type>source) const;
+      shcore::Value getTable(const shcore::Argument_list &args);
+      shcore::Value getCollection(const shcore::Argument_list &args);
+      shcore::Value getView(const shcore::Argument_list &args);
+    };
+  }
+}
+
+#endif
diff --git a/modules/mod_mysqlx_session.cc b/modules/mod_mysqlx_session.cc
new file mode 100644
index 0000000000000000000000000000000000000000..8032d63927fb58a652f5957a32a15593f614101b
--- /dev/null
+++ b/modules/mod_mysqlx_session.cc
@@ -0,0 +1,331 @@
+/*
+ * Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#include "mod_mysqlx_session.h"
+#include "mod_mysqlx_schema.h"
+#include "mod_mysqlx_resultset.h"
+#include "shellcore/object_factory.h"
+#include "shellcore/shell_core.h"
+#include "shellcore/lang_base.h"
+
+#include "shellcore/proxy_object.h"
+
+#include <boost/bind.hpp>
+#include <boost/lexical_cast.hpp>
+#include <boost/format.hpp>
+#include <boost/pointer_cast.hpp>
+
+#define MAX_COLUMN_LENGTH 1024
+#define MIN_COLUMN_LENGTH 4
+
+using namespace mysh;
+using namespace shcore;
+using namespace mysh::mysqlx;
+
+REGISTER_OBJECT(mysqlx, Session);
+REGISTER_OBJECT(mysqlx, NodeSession);
+
+#include <iostream>
+
+ApiBaseSession::ApiBaseSession()
+: _show_warnings(false)
+{
+  _schemas.reset(new shcore::Value::Map_type);
+}
+
+Value ApiBaseSession::connect(const Argument_list &args)
+{
+  std::string function_name = class_name() + ".connect";
+  args.ensure_count(1, 2, function_name.c_str());
+
+  std::string uri = args.string_at(0);
+
+  std::string pwd_override;
+
+  // If password is received as parameter, then it overwrites
+  // Anything found on the URI
+  if (2 == args.size())
+    pwd_override = args.string_at(1).c_str();
+
+  _uri = mysh::strip_password(uri);
+
+  try
+  {
+    _session = ::mysqlx::openSession(uri, pwd_override);
+  }
+  CATCH_AND_TRANSLATE();
+
+  _load_schemas();
+  _load_default_schema();
+
+  return Value::Null();
+}
+
+Value ApiBaseSession::executeSql(const Argument_list &args)
+{
+  std::string function_name = class_name() + ".executeSql";
+  args.ensure_count(1, function_name.c_str());
+  // Will return the result of the SQL execution
+  // In case of error will be Undefined
+  Value ret_val;
+  if (!_session)
+    throw Exception::logic_error("Not connected.");
+  else
+  {
+    // Options are the statement and optionally options to modify
+    // How the resultset is created.
+    std::string statement = args.string_at(0);
+    Value options;
+    if (args.size() == 2)
+      options = args[1];
+
+    if (statement.empty())
+      throw Exception::argument_error("No query specified.");
+    else
+    {
+      try
+      {
+        // Cleans out the comm buffer
+        flush_last_result();
+
+        _last_result.reset(_session->executeSql(statement));
+        ret_val = shcore::Value::wrap(new Resultset(_last_result));
+      }
+      CATCH_AND_TRANSLATE();
+    }
+  }
+
+  return ret_val;
+}
+
+std::vector<std::string> ApiBaseSession::get_members() const
+{
+  std::vector<std::string> members(BaseSession::get_members());
+
+  // This function is here only to append the schemas as direct members
+  // Using a set to prevent duplicates
+  std::set<std::string> set(members.begin(), members.end());
+  for (Value::Map_type::const_iterator iter = _schemas->begin(); iter != _schemas->end(); ++iter)
+    set.insert(iter->first);
+
+  for (std::vector<std::string>::iterator index = members.begin(); index != members.end(); ++index)
+    set.erase(*index);
+
+  for (std::set<std::string>::iterator index = set.begin(); index != set.end(); ++index)
+    members.push_back(*index);
+
+  return members;
+}
+
+Value ApiBaseSession::get_member(const std::string &prop) const
+{
+  // Retrieves the member first from the parent
+  Value ret_val;
+
+  // Check the member is on the base classes before attempting to
+  // retrieve it since it may throw invalid member otherwise
+  // If not on the parent classes and not here then we can safely assume
+  // it is a schema and attempt loading it as such
+  if (BaseSession::has_member(prop))
+    ret_val = BaseSession::get_member(prop);
+  else if (prop == "uri")
+    ret_val = Value(_uri);
+  else if (prop == "schemas")
+    ret_val = Value(_schemas);
+  else if (prop == "defaultSchema")
+  {
+    if (_default_schema)
+      ret_val = Value(boost::static_pointer_cast<Object_bridge>(_default_schema));
+    else
+      ret_val = Value::Null();
+  }
+  else
+  {
+    // Since the property was not satisfied, we assume it is a schema and
+    // proceed to retrieve it
+    shcore::Argument_list args;
+    args.push_back(Value(prop));
+
+    ret_val = get_schema(args);
+  }
+
+  return ret_val;
+}
+
+void ApiBaseSession::flush_last_result()
+{
+  if (_last_result)
+    _last_result->discardData();
+}
+
+void ApiBaseSession::_load_default_schema()
+{
+  try
+  {
+    _default_schema.reset();
+
+    if (_session)
+    {
+      // Cleans out the comm buffer
+      flush_last_result();
+
+      // TODO: update this logic properly
+      ::mysqlx::Result* result = _session->executeSql("select schema()");
+      ::mysqlx::Row *row = result->next();
+
+      std::string name;
+      if (!row->isNullField(0))
+        name = row->stringField(0);
+
+      result->discardData();
+
+      _update_default_schema(name);
+    }
+  }
+  CATCH_AND_TRANSLATE();
+}
+
+void ApiBaseSession::_load_schemas()
+{
+  try
+  {
+    if (_session)
+    {
+      // Cleans out the comm buffer
+      flush_last_result();
+
+      ::mysqlx::Result* result = _session->executeSql("show databases;");
+      ::mysqlx::Row *row = result->next();
+
+      while (row)
+      {
+        std::string schema;
+        if (!row->isNullField(0))
+          schema = row->stringField(0);
+
+        if (!schema.empty())
+        {
+          boost::shared_ptr<Schema> object(new Schema(shared_from_this(), schema));
+          (*_schemas)[schema] = shcore::Value(boost::static_pointer_cast<Object_bridge>(object));
+        }
+
+        row = result->next();
+      }
+
+      result->discardData();
+    }
+  }
+  CATCH_AND_TRANSLATE();
+}
+
+shcore::Value ApiBaseSession::get_schema(const shcore::Argument_list &args) const
+{
+  std::string function_name = class_name() + ".getSchema";
+  args.ensure_count(1, function_name.c_str());
+
+  std::string name = args[0].as_string();
+
+  if (_schemas->has_key(name))
+  {
+    boost::shared_ptr<Schema> schema = (*_schemas)[name].as_object<Schema>();
+
+    // This will validate the schema continues valid
+    schema->cache_table_objects();
+  }
+  else
+  {
+    if (_session)
+    {
+      boost::shared_ptr<Schema> schema(new Schema(shared_from_this(), name));
+
+      // Here this call will also validate the schema is valid
+      schema->cache_table_objects();
+
+      (*_schemas)[name] = Value(boost::static_pointer_cast<Object_bridge>(schema));
+    }
+    else
+      throw Exception::runtime_error("Session not connected");
+  }
+
+  // If this point is reached, the schema will be there!
+  return (*_schemas)[name];
+}
+
+shcore::Value ApiBaseSession::set_default_schema(const shcore::Argument_list &args)
+{
+  std::string function_name = class_name() + ".setDefaultSchema";
+  args.ensure_count(1, function_name.c_str());
+
+  if (_session)
+  {
+    // Cleans out the comm buffer
+    flush_last_result();
+
+    std::string name = args[0].as_string();
+
+    ::mysqlx::Result* result = _session->executeSql("use " + name + ";");
+    result->discardData();
+
+    _update_default_schema(name);
+  }
+  else
+    throw Exception::runtime_error("Session not connected");
+
+  return get_member("defaultSchema");
+}
+
+void ApiBaseSession::_update_default_schema(const std::string& name)
+{
+  if (!name.empty())
+  {
+    if (_schemas->has_key(name))
+      _default_schema = (*_schemas)[name].as_object<Schema>();
+    else
+    {
+      _default_schema.reset(new Schema(shared_from_this(), name));
+      _default_schema->cache_table_objects();
+      (*_schemas)[name] = Value(boost::static_pointer_cast<Object_bridge>(_default_schema));
+    }
+  }
+}
+
+boost::shared_ptr<shcore::Object_bridge> Session::create(const shcore::Argument_list &args)
+{
+  boost::shared_ptr<Session> session(new Session());
+
+  session->connect(args);
+
+  return boost::static_pointer_cast<Object_bridge>(session);
+}
+
+NodeSession::NodeSession() :ApiBaseSession()
+{
+  add_method("executeSql", boost::bind(&Session::executeSql, this, _1),
+             "stmt", shcore::String,
+             NULL);
+}
+
+boost::shared_ptr<shcore::Object_bridge> NodeSession::create(const shcore::Argument_list &args)
+{
+  boost::shared_ptr<NodeSession> session(new NodeSession());
+
+  session->connect(args);
+
+  return boost::static_pointer_cast<Object_bridge>(session);
+}
\ No newline at end of file
diff --git a/modules/mod_mysqlx_session.h b/modules/mod_mysqlx_session.h
new file mode 100644
index 0000000000000000000000000000000000000000..cb77bf1cd3fbf60f88f8de18c75c63319ae4bf24
--- /dev/null
+++ b/modules/mod_mysqlx_session.h
@@ -0,0 +1,131 @@
+/*
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+// Interactive session access module for MySQLx sessions
+// Exposed as "session" in the shell
+
+#ifndef _MOD_XSESSION_H_
+#define _MOD_XSESSION_H_
+
+#include "mod_common.h"
+#include "shellcore/types.h"
+#include "shellcore/types_cpp.h"
+#include "shellcore/ishell_core.h"
+#include "base_session.h"
+#include "mysqlx.h"
+
+#include <boost/enable_shared_from_this.hpp>
+
+namespace shcore
+{
+  class Proxy_object;
+};
+
+/*
+* Helper function to ensure the exceptions generated on the mysqlx_connector
+* are properly translated to the corresponding shcore::Exception type
+*/
+static void translate_exception()
+{
+  try
+  {
+    throw;
+  }
+  catch (std::runtime_error &e)
+  {
+    throw shcore::Exception::runtime_error(e.what());
+  }
+  catch (std::logic_error &e)
+  {
+    throw shcore::Exception::logic_error(e.what());
+  }
+  catch (...)
+  {
+    throw;
+  }
+}
+
+#define CATCH_AND_TRANSLATE()   \
+  catch (...)                   \
+{ translate_exception(); }
+
+namespace mysh
+{
+  namespace mysqlx
+  {
+    class Schema;
+    class MOD_PUBLIC ApiBaseSession : public BaseSession, public boost::enable_shared_from_this<ApiBaseSession>
+    {
+    public:
+      ApiBaseSession();
+      virtual ~ApiBaseSession() {};
+
+      virtual std::vector<std::string> get_members() const;
+      virtual shcore::Value get_member(const std::string &prop) const;
+
+      virtual shcore::Value connect(const shcore::Argument_list &args);
+      virtual void disconnect() { _session.reset(); }
+      virtual shcore::Value executeSql(const shcore::Argument_list &args);
+      virtual bool is_connected() const { return _session ? true : false; }
+      virtual std::string uri() const { return _uri; };
+
+      virtual shcore::Value get_schema(const shcore::Argument_list &args) const;
+      virtual shcore::Value set_default_schema(const shcore::Argument_list &args);
+
+      boost::shared_ptr< ::mysqlx::Session> session_obj() const { return _session; }
+
+      static boost::shared_ptr<shcore::Object_bridge> create(const shcore::Argument_list &args);
+
+      void flush_last_result();
+    protected:
+      boost::shared_ptr< ::mysqlx::Result> _last_result;
+      void _update_default_schema(const std::string& name);
+      void _load_default_schema();
+      void _load_schemas();
+
+      boost::shared_ptr< ::mysqlx::Session> _session;
+
+      boost::shared_ptr<Schema> _default_schema;
+      boost::shared_ptr<shcore::Value::Map_type> _schemas;
+
+      std::string _uri;
+      bool _show_warnings;
+    };
+
+    class MOD_PUBLIC Session : public ApiBaseSession, public boost::enable_shared_from_this<Session>
+    {
+    public:
+      Session(){};
+      virtual ~Session(){};
+      virtual std::string class_name() const { return "Session"; };
+      static boost::shared_ptr<shcore::Object_bridge> create(const shcore::Argument_list &args);
+    };
+
+    class MOD_PUBLIC NodeSession : public ApiBaseSession, public boost::enable_shared_from_this<NodeSession>
+    {
+    public:
+      NodeSession();
+      virtual ~NodeSession(){};
+      virtual std::string class_name() const { return "NodeSession"; };
+      static boost::shared_ptr<shcore::Object_bridge> create(const shcore::Argument_list &args);
+    };
+  }
+}
+
+#endif
diff --git a/modules/mod_mysqlx_table.cc b/modules/mod_mysqlx_table.cc
new file mode 100644
index 0000000000000000000000000000000000000000..829fd32b449de83c08dafc7d39b50a766d35baf9
--- /dev/null
+++ b/modules/mod_mysqlx_table.cc
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#include "mod_mysqlx_schema.h"
+#include "mod_mysqlx_table.h"
+
+using namespace mysh;
+using namespace mysh::mysqlx;
+using namespace shcore;
+
+#include <iostream>
+
+Table::Table(boost::shared_ptr<Schema> owner, const std::string &name)
+: DatabaseObject(owner->_session.lock(), owner, name), _table_impl(owner->_schema_impl->getTable(name))
+{
+}
+
+Table::Table(boost::shared_ptr<const Schema> owner, const std::string &name) :
+Table(boost::const_pointer_cast<Schema>(owner), name)
+{
+}
+
+Table::~Table()
+{
+}
\ No newline at end of file
diff --git a/modules/mod_mysqlx_table.h b/modules/mod_mysqlx_table.h
new file mode 100644
index 0000000000000000000000000000000000000000..04e9a6556edb339c1dcbe2412a055b1325f3cb55
--- /dev/null
+++ b/modules/mod_mysqlx_table.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+// Interactive Table access module
+// (the one exposed as the table members of the db object in the shell)
+
+#ifndef _MOD_MYSQLX_TABLE_H_
+#define _MOD_MYSQLX_TABLE_H_
+
+#include "base_database_object.h"
+#include "shellcore/types.h"
+#include "shellcore/types_cpp.h"
+
+namespace mysh
+{
+  namespace mysqlx
+  {
+    class Schema;
+
+    class Table : public DatabaseObject
+    {
+    public:
+      Table(boost::shared_ptr<Schema> owner, const std::string &name);
+      Table(boost::shared_ptr<const Schema> owner, const std::string &name);
+      virtual ~Table();
+
+      virtual std::string class_name() const { return "Table"; }
+
+    private:
+      boost::shared_ptr< ::mysqlx::Table> _table_impl;
+    };
+  }
+}
+
+#endif
diff --git a/modules/mod_mysqlx_view.cc b/modules/mod_mysqlx_view.cc
new file mode 100644
index 0000000000000000000000000000000000000000..170d994ec5bb636fbae7679739dc239a8640156e
--- /dev/null
+++ b/modules/mod_mysqlx_view.cc
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#include "mod_mysqlx_schema.h"
+#include "mod_mysqlx_view.h"
+
+using namespace mysh;
+using namespace mysh::mysqlx;
+using namespace shcore;
+
+#include <iostream>
+
+View::View(boost::shared_ptr<Schema> owner, const std::string &name)
+: DatabaseObject(owner->_session.lock(), owner, name)//, _table_impl(owner->_schema_impl->getTable(name))
+{
+}
+
+View::View(boost::shared_ptr<const Schema> owner, const std::string &name) :
+View(boost::const_pointer_cast<Schema>(owner), name)
+{
+}
+
+View::~View()
+{
+}
\ No newline at end of file
diff --git a/modules/mod_mysqlx_view.h b/modules/mod_mysqlx_view.h
new file mode 100644
index 0000000000000000000000000000000000000000..7e178a86bed8b7c854fdd74da2986a86349660ae
--- /dev/null
+++ b/modules/mod_mysqlx_view.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+// Interactive Table access module
+// (the one exposed as the table members of the db object in the shell)
+
+#ifndef _MOD_MYSQLX_VIEW_H_
+#define _MOD_MYSQLX_VIEW_H_
+
+#include "base_database_object.h"
+#include "shellcore/types.h"
+#include "shellcore/types_cpp.h"
+
+namespace mysh
+{
+  namespace mysqlx
+  {
+    class Schema;
+
+    class View : public DatabaseObject
+    {
+    public:
+      View(boost::shared_ptr<Schema> owner, const std::string &name);
+      View(boost::shared_ptr<const Schema> owner, const std::string &name);
+      virtual ~View();
+
+      virtual std::string class_name() const { return "View"; }
+
+      //private:
+      //boost::shared_ptr< ::mysqlx::Table> _table_impl;
+    };
+  }
+}
+
+#endif
diff --git a/modules/mod_result.cc b/modules/mod_result.cc
deleted file mode 100644
index 2e6cae8f32bc4bc54fdf65f62a682a8e035db469..0000000000000000000000000000000000000000
--- a/modules/mod_result.cc
+++ /dev/null
@@ -1,339 +0,0 @@
-/*
- * Copyright (c) 2014, 2015 Oracle and/or its affiliates. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; version 2 of the
- * License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#include <iostream>
-
-#include <boost/asio.hpp>
-#include <boost/bind.hpp>
-#include <boost/algorithm/string.hpp>
-
-#include <string>
-#include <iostream>
-#include <iomanip>
-#include "mod_result.h"
-
-using namespace mysh;
-using namespace shcore;
-
-/*
-* Helper function to ensure the exceptions generated on the mysqlx_connector
-* are properly translated to the corresponding shcore::Exception type
-*/
-static void translate_exception()
-{
-  try
-  {
-    throw;
-  }
-  catch (boost::system::system_error &e)
-  {
-    throw shcore::Exception::runtime_error(e.what());
-  }
-  catch (std::runtime_error &e)
-  {
-    throw shcore::Exception::runtime_error(e.what());
-  }
-  catch (std::logic_error &e)
-  {
-    throw shcore::Exception::logic_error(e.what());
-  }
-  catch (...)
-  {
-    throw;
-  }
-}
-
-#define CATCH_AND_TRANSLATE()   \
-  catch (...)                   \
-{ translate_exception(); }
-
-X_resultset::X_resultset(boost::shared_ptr<mysh::X_connection> owner,
-                         bool has_data,
-                         int cursor_id,
-                         uint64_t affected_rows,
-                         uint64_t last_insert_id,
-                         int warning_count,
-                         const char *info,
-                         int next_mid,
-                         Message* next_message,
-                         bool expect_metadata,
-                         boost::shared_ptr<shcore::Value::Map_type> options) :
-Base_resultset(owner, affected_rows, last_insert_id, warning_count, info, options),
-  _xowner(owner),
-  _cursor_id(cursor_id),
-  _next_mid(next_mid),
-  _next_message(next_message),
-  _current_fetch_done(!has_data),
-  _all_fetch_done(!has_data),
-  _expect_metadata(expect_metadata)
-{
-  _has_resultset = has_data;
-}
-
-X_resultset::~X_resultset(){}
-
-Base_row* X_resultset::next_row()
-{
-  Base_row* ret_val = NULL;
-
-  if (has_resultset())
-  {
-    boost::shared_ptr<mysh::X_connection> owner = _xowner.lock();
-
-    if (!is_current_fetch_done() && owner)
-    {
-      try
-      {
-        // Reads the next message
-        // This variable must be cleaned out at the end
-        _next_message = owner->get_protobuf()->read_response(_next_mid);
-
-        if (_next_mid == Mysqlx::ServerMessages::SQL_ROW)
-        {
-          ret_val = new X_row(dynamic_cast<Mysqlx::Sql::Row *>(_next_message), &_metadata);
-          ret_val->set_key_by_index(_key_by_index);
-
-          // Each read row increases the count
-          _fetched_row_count++;
-        }
-        else if (_next_mid == Mysqlx::ServerMessages::SQL_CURSOR_FETCH_DONE)
-          flush_messages(true);
-        else if (_next_mid == Mysqlx::ServerMessages::SQL_CURSOR_FETCH_DONE_MORE_RESULTSETS)
-          _current_fetch_done = true;
-        else
-          owner->get_protobuf()->handle_wrong_response(_next_mid, _next_message, "fetching result.");
-      }
-      CATCH_AND_TRANSLATE();
-    }
-  }
-
-  _next_message = NULL;
-  return ret_val;
-}
-
-// Used to consume all the remaining messages of the current resultset that are coming from the
-// server.
-// If complete false it will only flush the messages about the current result in the resultset
-// If it is true it will flush all the messages for the result set
-void X_resultset::flush_messages(bool complete)
-{
-  Message *msg;
-  int mid;
-  bool done_flushing = false;
-  try
-  {
-    boost::shared_ptr<mysh::X_connection> owner = _xowner.lock();
-    if (owner)
-    {
-      do
-      {
-        // Handles any error properly
-        if (_next_mid == Mysqlx::ServerMessages::ERROR)
-          owner->get_protobuf()->handle_wrong_response(mid, msg, "flushing result");
-        else
-        {
-          // Complete flush ends on fetch done or stmt execute ok
-          // note that stmt execute ok is only received by results
-          // with resultset metadata, so is not always present.
-          if (complete)
-          {
-            if (_expect_metadata)
-              done_flushing = _next_mid == Mysqlx::ServerMessages::SQL_STMT_EXECUTE_OK;
-            else
-              done_flushing = _next_mid == Mysqlx::ServerMessages::SQL_CURSOR_FETCH_DONE;
-
-            _all_fetch_done = done_flushing;
-            _current_fetch_done = done_flushing;
-          }
-          else
-          {
-            done_flushing = (_next_mid == Mysqlx::ServerMessages::SQL_CURSOR_FETCH_DONE ||
-                             _next_mid == Mysqlx::ServerMessages::SQL_CURSOR_FETCH_DONE_MORE_RESULTSETS ||
-                             _next_mid == Mysqlx::ServerMessages::SQL_STMT_EXECUTE_OK);
-
-            // On simple resultset request, if this is the last resultset then we need to continue reading if
-            // metadata is expected
-            if (_next_mid == Mysqlx::ServerMessages::SQL_CURSOR_FETCH_DONE && _expect_metadata)
-              done_flushing = false;
-
-            _current_fetch_done = done_flushing;
-          }
-
-          reset(-1, _next_mid, _next_message);
-
-          if (done_flushing && _expect_metadata)
-            set_result_metadata(_next_message);
-
-          delete _next_message;
-          _next_message = NULL;
-
-          if (!done_flushing)
-            _next_message = owner->get_protobuf()->read_response(_next_mid);
-        }
-      } while (!done_flushing);
-    }
-  }
-  CATCH_AND_TRANSLATE();
-}
-
-int X_resultset::fetch_metadata()
-{
-  // Fetch the metadata
-  int ret_val = 0;
-  boost::shared_ptr<mysh::X_connection> owner = _xowner.lock();
-
-  _metadata.clear();
-
-  if (owner)
-  {
-    try
-    {
-      while (_next_mid == Mysqlx::ServerMessages::SQL_COLUMN_META_DATA)
-      {
-        Mysqlx::Sql::ColumnMetaData *meta = dynamic_cast<Mysqlx::Sql::ColumnMetaData *>(_next_message);
-
-        _metadata.push_back(Field(meta->catalog(),
-          meta->schema(),
-          meta->table(),
-          meta->original_table(),
-          meta->name(),
-          meta->original_name(),
-          0, // length: not supported yet
-          meta->type(),
-          0, // flags: not supported yet
-          meta->fractional_digits(),// decimals are now sent as fractional digits
-          0)); // charset: not supported yet
-
-        ret_val++;
-
-        _next_message = owner->get_protobuf()->read_response(_next_mid);
-      }
-
-      // Validates exit in case of error...
-      if (_next_mid == Mysqlx::ServerMessages::ERROR)
-      {
-        // Since metadata will be empty, it implies the result had no records
-        Mysqlx::Error *error = dynamic_cast<Mysqlx::Error *>(_next_message);
-        std::cout << "Error retrieving metadata: " << error->msg() << std::endl;
-        ret_val = -1;
-      }
-    }
-    CATCH_AND_TRANSLATE();
-  }
-
-  return ret_val;
-}
-
-void X_resultset::reset(unsigned long duration, int next_mid, ::google::protobuf::Message* next_message)
-{
-  if (next_mid)
-  {
-    _next_mid = next_mid;
-    _next_message = next_message;
-
-    // Nothing to be read anymnore on these cases
-    if (_expect_metadata)
-      _all_fetch_done = (_next_mid == Mysqlx::ServerMessages::SQL_STMT_EXECUTE_OK);
-    else
-      _all_fetch_done = (_next_mid == Mysqlx::ServerMessages::SQL_CURSOR_FETCH_DONE);
-
-    // Nothing to be read for the current result on these cases
-    _current_fetch_done = (_next_mid == Mysqlx::ServerMessages::SQL_CURSOR_FETCH_DONE ||
-                           _next_mid == Mysqlx::ServerMessages::SQL_CURSOR_FETCH_DONE_MORE_RESULTSETS ||
-                           _all_fetch_done);
-  }
-
-  if (duration != (unsigned long)-1)
-    _raw_duration = duration;
-}
-
-void X_resultset::set_result_metadata(Message *msg)
-{
-  Mysqlx::Sql::StmtExecuteOk *stmt_exec_ok = dynamic_cast<Mysqlx::Sql::StmtExecuteOk*>(msg);
-
-  if (stmt_exec_ok)
-  {
-    if (stmt_exec_ok->has_rows_affected())
-      _affected_rows = stmt_exec_ok->rows_affected();
-
-    if (stmt_exec_ok->has_last_insert_id())
-      _last_insert_id = stmt_exec_ok->last_insert_id();
-  }
-  else
-    throw shcore::Exception::logic_error("Unexpected message to set resultset metadata.");
-}
-
-Collection_resultset::Collection_resultset(boost::shared_ptr<X_connection> owner,
-                     bool has_data,
-                     int cursor_id,
-                     uint64_t affected_rows,
-                     uint64_t last_insert_id,
-                     int warning_count,
-                     const char *info,
-                     int next_mid,
-                     Message* next_message,
-                     bool expect_metadata,
-                     boost::shared_ptr<shcore::Value::Map_type> options) :
-                     X_resultset(owner, has_data, cursor_id, affected_rows, last_insert_id, warning_count,
-                     info, next_mid, next_message, expect_metadata, options)
-{
-}
-
-shcore::Value Collection_resultset::next(const shcore::Argument_list &args)
-{
-  Value ret_val = Value::Null();
-
-  std::string function = class_name() + "::next";
-  bool raw = false;
-
-  args.ensure_count(0, function.c_str());
-
-  // Gets the next row
-  std::auto_ptr<Base_row> row(next_row());
-
-  if (row.get())
-  {
-    // Now parses the document and returns it
-    Value document = row->get_value(0);
-
-    ret_val = Value::parse(document.as_string());
-  }
-
-  return ret_val;
-}
-
-shcore::Value Collection_resultset::fetch_all(const shcore::Argument_list &args)
-{
-  Value::Array_type_ref array(new Value::Array_type());
-
-  std::string function = class_name() + "::all";
-  bool raw = false;
-
-  args.ensure_count(0, function.c_str());
-
-  // Gets the next row
-  Value record = next(args);
-  while (record)
-  {
-    array->push_back(record);
-    record = next(args);
-  }
-
-  return Value(array);
-}
\ No newline at end of file
diff --git a/modules/mod_result.h b/modules/mod_result.h
deleted file mode 100644
index 80cea95c5d266349ce0c14c40c1bd71c597d76b2..0000000000000000000000000000000000000000
--- a/modules/mod_result.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Copyright (c) 2015 Oracle and/or its affiliates. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; version 2 of the
- * License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-// MySQL DB access module, for use by plugins and others
-// For the module that implements interactive DB functionality see mod_db
-
-#ifndef _MOD_RESULT_H_
-#define _MOD_RESULT_H_
-
-#include "shellcore/types.h"
-#include "shellcore/types_cpp.h"
-#include "mod_mysqlx.h"
-#include <list>
-
-#undef ERROR //Needed to avoid conflict with ERROR in mysqlx.pb.h
-#include "mysqlx.pb.h"
-
-namespace mysh
-{
-  class X_resultset : public Base_resultset
-  {
-  public:
-    X_resultset(boost::shared_ptr<X_connection> owner,
-                bool has_data,
-                int cursor_id,
-                uint64_t affected_rows,
-                uint64_t last_insert_id,
-                int warning_count,
-                const char *info,
-                int next_mid,
-                Message* next_message,
-                bool expect_metadata,
-                boost::shared_ptr<shcore::Value::Map_type> options = boost::shared_ptr<shcore::Value::Map_type>());
-    virtual ~X_resultset();
-
-    virtual std::string class_name() const  { return "X_resultset"; }
-    virtual int fetch_metadata();
-
-    void reset(unsigned long duration = -1, int next_mid = 0, ::google::protobuf::Message* next_message = NULL);
-    void set_result_metadata(Message *msg);
-    int get_cursor_id() { return _cursor_id; }
-    bool is_all_fetch_done()  { return _all_fetch_done; }
-    bool is_current_fetch_done()  { return _current_fetch_done; }
-    void flush_messages(bool complete);
-
-  protected:
-    virtual Base_row* next_row();
-
-    boost::weak_ptr<X_connection> _xowner;
-
-  private:
-    int _cursor_id;
-    int _next_mid;
-    Message* _next_message;
-
-    bool _expect_metadata;
-    bool _current_fetch_done;
-    bool _all_fetch_done;
-  };
-
-  class Collection_resultset : public X_resultset
-  {
-  public:
-    Collection_resultset(boost::shared_ptr<X_connection> owner,
-    bool has_data,
-    int cursor_id,
-    uint64_t affected_rows,
-    uint64_t last_insert_id,
-    int warning_count,
-    const char *info,
-    int next_mid,
-    Message* next_message,
-    bool expect_metadata,
-    boost::shared_ptr<shcore::Value::Map_type> options = boost::shared_ptr<shcore::Value::Map_type>());
-
-    virtual std::string class_name() const  { return "CollectionResultset"; }
-    virtual shcore::Value next(const shcore::Argument_list &args);
-    virtual shcore::Value fetch_all(const shcore::Argument_list &args);
-  };
-};
-
-#endif
diff --git a/modules/mod_session.cc b/modules/mod_session.cc
deleted file mode 100644
index 4af5e96a8d712638c438040e26a91f7dc696f3a9..0000000000000000000000000000000000000000
--- a/modules/mod_session.cc
+++ /dev/null
@@ -1,254 +0,0 @@
-/*
- * Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; version 2 of the
- * License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-#include "mod_session.h"
-
-#include "shellcore/object_factory.h"
-#include "shellcore/shell_core.h"
-#include "shellcore/lang_base.h"
-
-#include "shellcore/proxy_object.h"
-
-#include "mod_db.h"
-
-#include <boost/bind.hpp>
-#include <boost/lexical_cast.hpp>
-#include <boost/format.hpp>
-#include <boost/pointer_cast.hpp>
-
-#include "mod_mysql.h"
-#ifdef X_PROTOCOL_ENABLED
-#include "mod_mysqlx.h"
-#endif
-
-#define MAX_COLUMN_LENGTH 1024
-#define MIN_COLUMN_LENGTH 4
-
-using namespace mysh;
-using namespace shcore;
-
-#include <iostream>
-
-Session::Session(IShell_core *shc)
-: _shcore(shc), _show_warnings(false)
-{
-  _schema_proxy.reset(new Proxy_object(boost::bind(&Session::get_db, this, _1)));
-
-  add_method("sql", boost::bind(&Session::sql, this, _1),
-    "stmt", shcore::String,
-    "*options", shcore::Map,
-    NULL);
-
-  add_method("sql_one", boost::bind(&Session::sql_one, this, _1),
-    "stmt", shcore::String,
-    NULL);
-}
-
-Session::~Session()
-{
-}
-
-Value Session::connect(const Argument_list &args)
-{
-  args.ensure_count(1, 2, "Session::connect");
-
-  std::string uri = args.string_at(0);
-
-  std::string protocol;
-  std::string user;
-  std::string pass;
-  const char *pwd_override = NULL;
-  std::string host;
-  std::string sock;
-  std::string db;
-  std::string uri_stripped;
-
-  int pwd_found;
-  int port = 0;
-
-  if (!parse_mysql_connstring(uri, protocol, user, pass, host, port, sock, db, pwd_found))
-    throw shcore::Exception::argument_error("Could not parse URI for MySQL connection");
-
-  // If password is received as parameter, then it overwrites
-  // Anything found on the URI
-  if (2 == args.size())
-    pwd_override = args.string_at(1).c_str();
-
-  if (protocol.empty() || protocol == "mysql")
-    _conn.reset(new Mysql_connection(uri, pwd_override));
-#ifdef X_PROTOCOL_ENABLED
-  else if (protocol == "mysqlx")
-    _conn.reset(new X_connection(uri, pwd_override));
-#endif
-  else
-    throw shcore::Exception::argument_error("Invalid protocol found in URI");
-
-  return Value::Null();
-}
-
-Value Session::sql(const Argument_list &args)
-{
-  args.ensure_count(1, "Session::sql");
-  // Will return the result of the SQL execution
-  // In case of error will be Undefined
-  Value ret_val;
-  if (!_conn)
-    throw Exception::logic_error("Not connected.");
-  else
-  {
-    // Options are the statement and optionally options to modify
-    // How the resultset is created.
-    std::string statement = args.string_at(0);
-    Value options;
-    if (args.size() == 2)
-      options = args[1];
-
-    if (statement.empty())
-      throw Exception::argument_error("No query specified.");
-    else
-      ret_val = _conn->sql(statement, options);
-  }
-
-  return ret_val;
-}
-
-Value Session::sql_one(const Argument_list &args)
-{
-  args.ensure_count(1, "Session::sql_one");
-
-  Value ret_val;
-  if (!_conn)
-    throw Exception::logic_error("Not connected.");
-  else
-  {
-    // Options are the statement and optionally options to modify
-    // How the resultset is created.
-    std::string statement = args.string_at(0);
-
-    if (statement.empty())
-      throw Exception::argument_error("No query specified.");
-    else
-      ret_val = _conn->sql_one(statement);
-  }
-
-  return ret_val;
-}
-
-void Session::print_exception(const shcore::Exception &e)
-{
-  // Removes the type, at this moment only type is MySQLError
-  // Reason is that leaving it will print things like:
-  // ERROR: MySQLError (code) message
-  // Where ERROR is added on the called print_error routine
-  //std::string message = (*e.error())["type"].as_string();
-
-  std::string message;
-  if ((*e.error()).has_key("code"))
-  {
-    //message.append(" ");
-    message.append(((*e.error())["code"].repr()));
-
-    if ((*e.error()).has_key("state") && (*e.error())["state"])
-      message.append((boost::format(" (%s)") % ((*e.error())["state"].as_string())).str());
-
-    message.append(": ");
-  }
-  message.append(e.what());
-
-  _shcore->print_error(message);
-}
-
-std::string Session::class_name() const
-{
-  return "Session";
-}
-
-std::string &Session::append_descr(std::string &s_out, int indent, int quote_strings) const
-{
-  if (!_conn)
-    s_out.append("<Session:disconnected>");
-  else
-    s_out.append("<Session:" + _conn->uri() + ">");
-  return s_out;
-}
-
-std::string &Session::append_repr(std::string &s_out) const
-{
-  return append_descr(s_out, false);
-}
-
-std::vector<std::string> Session::get_members() const
-{
-  std::vector<std::string> members(Cpp_object_bridge::get_members());
-  members.push_back("dbs");
-  members.push_back("schemas");
-  return members;
-}
-
-Value Session::get_member(const std::string &prop) const
-{
-  if (prop == "dbs" || prop == "schemas")
-  {
-    return Value(boost::static_pointer_cast<Object_bridge>(_schema_proxy));
-  }
-
-  if (!_conn)
-  {
-    _shcore->print_error("Not connected. Use connect(<uri>) or \\connect <uri>\n");
-    return Value::Null();
-  }
-
-  return Cpp_object_bridge::get_member(prop);
-}
-
-void Session::set_member(const std::string &prop, Value value)
-{
-  Cpp_object_bridge::set_member(prop, value);
-}
-
-bool Session::operator == (const Object_bridge &other) const
-{
-  return class_name() == other.class_name() && this == &other;
-}
-
-Value Session::get_db(const std::string &schema)
-{
-  if (_conn)
-  {
-    boost::shared_ptr<Db> db(new Db(shared_from_this(), schema));
-    db->cache_table_names();
-    return Value(boost::static_pointer_cast<Object_bridge>(db));
-  }
-  throw Exception::runtime_error("Session not connected");
-}
-
-boost::shared_ptr<Db> Session::default_schema()
-{
-  if (_conn)
-  {
-    Value res = _conn->sql_one("select schema()");
-    if (res && res.type == Map && res.as_map()->get_type("schema()") == String)
-    {
-      boost::shared_ptr<Db> db(new Db(shared_from_this(), res.as_map()->get_string("schema()")));
-      db->cache_table_names();
-      return db;
-    }
-  }
-  return boost::shared_ptr<Db>();
-}
diff --git a/modules/mod_session.h b/modules/mod_session.h
deleted file mode 100644
index 7bcad247c4f74c0fd03fffefaf218927abff3c0a..0000000000000000000000000000000000000000
--- a/modules/mod_session.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; version 2 of the
- * License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301  USA
- */
-
-// Interactive session access module
-// Exposed as "session" in the shell
-
-#ifndef _MOD_SESSION_H_
-#define _MOD_SESSION_H_
-
-#include "mod_common.h"
-#include "shellcore/types.h"
-#include "shellcore/types_cpp.h"
-#include "shellcore/ishell_core.h"
-
-#include "mod_connection.h"
-
-#include <boost/enable_shared_from_this.hpp>
-
-namespace shcore
-{
-  class Shell_core;
-  class Proxy_object;
-};
-
-namespace mysh {
-
-class Db;
-
-
-class MOD_PUBLIC Session : public shcore::Cpp_object_bridge, public boost::enable_shared_from_this<Session>
-{
-public:
-  Session(shcore::IShell_core *shc);
-  ~Session();
-
-  virtual std::string class_name() const;
-  virtual std::string &append_descr(std::string &s_out, int indent=-1, int quote_strings=0) const;
-  virtual std::string &append_repr(std::string &s_out) const;
-  virtual std::vector<std::string> get_members() const;
-  virtual shcore::Value get_member(const std::string &prop) const;
-  virtual void set_member(const std::string &prop, shcore::Value value);
-  virtual bool operator == (const Object_bridge &other) const;
-
-  shcore::Value connect(const shcore::Argument_list &args);
-  void disconnect() { _conn.reset();  }
-  shcore::Value sql(const shcore::Argument_list &args);
-  shcore::Value sql_one(const shcore::Argument_list &args);
-
-  void print_exception(const shcore::Exception &e);
-
-  boost::shared_ptr<Base_connection> conn() const { return _conn; }
-
-  boost::shared_ptr<Db> default_schema();
-
-  bool is_connected() { return _conn ? true : false;  }
-
-private:
-  shcore::Value get_db(const std::string &schema);
-
-  shcore::IShell_core *_shcore;
-  boost::shared_ptr<Base_connection> _conn;
-
-  boost::shared_ptr<shcore::Proxy_object> _schema_proxy;
-
-  bool _show_warnings;
-};
-
-};
-
-#endif
diff --git a/modules/mysql.cc b/modules/mysql.cc
new file mode 100644
index 0000000000000000000000000000000000000000..69581853e4bf5e57b9bc8c99afaa409a3601a0d2
--- /dev/null
+++ b/modules/mysql.cc
@@ -0,0 +1,321 @@
+/*
+ * Copyright (c) 2014, 1015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+#include "mysql.h"
+#include "base_session.h"
+
+#include "shellcore/obj_date.h"
+
+#include <boost/format.hpp>
+#include <boost/bind.hpp>
+#include <boost/lexical_cast.hpp>
+
+using namespace mysh::mysql;
+
+#include <iostream>
+
+#include "shellcore/object_factory.h"
+
+#define MAX_COLUMN_LENGTH 1024
+#define MIN_COLUMN_LENGTH 4
+
+Result::Result(boost::shared_ptr<Connection> owner, my_ulonglong affected_rows, unsigned int warning_count, const char *info)
+: _connection(owner), _affected_rows(affected_rows), _last_insert_id(0), _warning_count(0), _fetched_row_count(0), _execution_time(0), _has_resultset(false)
+{
+  if (info)
+    _info.assign(info);
+}
+
+int Result::fetch_metadata()
+{
+  int num_fields = 0;
+
+  _metadata.clear();
+
+  // res could be NULL on queries not returning data
+  boost::shared_ptr<MYSQL_RES> res = _result.lock();
+
+  if (res)
+  {
+    num_fields = mysql_num_fields(res.get());
+    MYSQL_FIELD *fields = mysql_fetch_fields(res.get());
+
+    for (int index = 0; index < num_fields; index++)
+    {
+      _metadata.push_back(Field(fields[index].catalog,
+        fields[index].db,
+        fields[index].table,
+        fields[index].org_table,
+        fields[index].name,
+        fields[index].org_name,
+        fields[index].length,
+        fields[index].type,
+        fields[index].flags,
+        fields[index].decimals,
+        fields[index].charsetnr));
+    }
+  }
+
+  return num_fields;
+}
+
+Result::~Result()
+{
+}
+
+Row * Result::next()
+{
+  Row *ret_val = NULL;
+
+  if (has_resultset())
+  {
+    // Loads the first row
+    boost::shared_ptr<MYSQL_RES> res = _result.lock();
+
+    if (res)
+    {
+      MYSQL_ROW mysql_row = mysql_fetch_row(res.get());
+      if (mysql_row)
+      {
+        unsigned long *lengths;
+        lengths = mysql_fetch_lengths(res.get());
+
+        ret_val = new Row(mysql_row, lengths, &_metadata);
+
+        // Each read row increases the count
+        _fetched_row_count++;
+      }
+    }
+  }
+
+  return ret_val;
+}
+
+bool Result::next_result()
+{
+  return _connection->next_result(this);
+}
+
+Result *Result::query_warnings()
+{
+  return _connection->executeSql("show warnings");
+}
+
+void Result::reset(boost::shared_ptr<MYSQL_RES> res, unsigned long duration)
+{
+  _has_resultset = false;
+  if (res)
+    _has_resultset = true;
+
+  _result = res;
+  _execution_time = duration;
+}
+
+Field::Field(const std::string& catalog, const std::string& db, const std::string& table, const std::string& otable, const std::string& name, const std::string& oname, int length, int type, int flags, int decimals, int charset) :
+_catalog(catalog),
+_db(db),
+_table(table),
+_org_table(otable),
+_name(name),
+_org_name(oname),
+_length(length),
+_type(type),
+_flags(flags),
+_decimals(decimals),
+_charset(charset),
+_max_length(0),
+_name_length(name.length())
+{
+}
+
+Row::Row(MYSQL_ROW row, unsigned long *lengths, std::vector<Field>* metadata) :
+_metadata(metadata), _row(row), _lengths(lengths)
+{
+}
+
+shcore::Value Row::get_value(int index)
+{
+  if (_row[index] == NULL)
+    return shcore::Value::Null();
+  else
+  {
+    switch ((*_metadata)[index].type())
+    {
+      case MYSQL_TYPE_NULL:
+        return shcore::Value::Null();
+      case MYSQL_TYPE_DECIMAL:
+      case MYSQL_TYPE_DATE:
+      case MYSQL_TYPE_TIME:
+      case MYSQL_TYPE_STRING:
+      case MYSQL_TYPE_VARCHAR:
+      case MYSQL_TYPE_VAR_STRING:
+        return shcore::Value(std::string(_row[index], _lengths[index]));
+
+      case MYSQL_TYPE_YEAR:
+      case MYSQL_TYPE_TINY:
+      case MYSQL_TYPE_SHORT:
+      case MYSQL_TYPE_INT24:
+      case MYSQL_TYPE_LONG:
+      case MYSQL_TYPE_LONGLONG:
+        return shcore::Value(boost::lexical_cast<int64_t>(_row[index]));
+
+      case MYSQL_TYPE_FLOAT:
+      case MYSQL_TYPE_DOUBLE:
+        return shcore::Value(boost::lexical_cast<double>(_row[index]));
+        break;
+
+      case MYSQL_TYPE_DATETIME:
+      case MYSQL_TYPE_TIMESTAMP:
+      case MYSQL_TYPE_DATETIME2:
+      case MYSQL_TYPE_TIMESTAMP2:
+        return shcore::Value(shcore::Date::unrepr(_row[index]));
+        break;
+    }
+  }
+
+  return shcore::Value();
+}
+
+std::string Row::get_value_as_string(int index)
+{
+  return _row[index] ? _row[index] : "NULL";
+}
+
+//----------------------------------------------
+
+Connection::Connection(const std::string &uri, const char *password)
+: _mysql(NULL)
+{
+  std::string protocol;
+  std::string user;
+  std::string pass;
+  std::string host;
+  int port = 3306;
+  std::string sock;
+  std::string db;
+  long flags = CLIENT_MULTI_RESULTS;
+  int pwd_found;
+
+  _mysql = mysql_init(NULL);
+
+  if (!parse_mysql_connstring(uri, protocol, user, pass, host, port, sock, db, pwd_found))
+    throw shcore::Exception::argument_error("Could not parse URI for MySQL connection");
+
+  if (password)
+    pass.assign(password);
+
+  _uri = strip_password(uri);
+
+  unsigned int tcp = MYSQL_PROTOCOL_TCP;
+  mysql_options(_mysql, MYSQL_OPT_PROTOCOL, &tcp);
+  if (!mysql_real_connect(_mysql, host.c_str(), user.c_str(), pass.c_str(), db.empty() ? NULL : db.c_str(), port, sock.empty() ? NULL : sock.c_str(), flags))
+  {
+    throw shcore::Exception::error_with_code_and_state("MySQLError", mysql_error(_mysql), mysql_errno(_mysql), mysql_sqlstate(_mysql));
+  }
+}
+
+void Connection::close()
+{
+  // This should be logged, for now commenting to
+  // avoid having unneeded output on the script mode
+  // shcore::print("disconnect\n");
+  if (_mysql)
+    mysql_close(_mysql);
+  _mysql = NULL;
+}
+
+Result *Connection::executeSql(const std::string &query)
+{
+  if (_prev_result)
+  {
+    _prev_result.reset();
+
+    while (mysql_next_result(_mysql) == 0)
+    {
+      MYSQL_RES *trailing_result = mysql_use_result(_mysql);
+      mysql_free_result(trailing_result);
+    }
+  }
+
+  _timer.start();
+
+  if (mysql_real_query(_mysql, query.c_str(), query.length()) != 0)
+  {
+    throw shcore::Exception::error_with_code_and_state("MySQLError", mysql_error(_mysql), mysql_errno(_mysql), mysql_sqlstate(_mysql));
+  }
+
+  Result* result = new Result(shared_from_this(), mysql_affected_rows(_mysql), mysql_warning_count(_mysql), mysql_info(_mysql));
+
+  next_result(result, true);
+
+  return result;
+}
+
+template <class T>
+static void free_result(T* result)
+{
+  mysql_free_result(result);
+  result = NULL;
+}
+
+bool Connection::next_result(Result *target, bool first_result)
+{
+  bool ret_val = false;
+
+  // Skips fetching a record on the first result
+  int more_results = 0;
+
+  if (!first_result)
+  {
+    _prev_result.reset();
+    more_results = mysql_next_result(_mysql);
+  }
+
+  Result *real_target = dynamic_cast<Result *> (target);
+
+  // If there are more results
+  if (more_results == 0)
+  {
+    // Retrieves the next result
+    MYSQL_RES* result = mysql_use_result(_mysql);
+
+    if (result)
+      _prev_result = boost::shared_ptr<MYSQL_RES>(result, &free_result<MYSQL_RES>);
+
+    // Only returns true when this method was called and there were
+    // Additional results
+    ret_val = true;
+  }
+
+  _timer.end();
+
+  // We need to update the received result object with the information
+  // for the next result set
+  real_target->reset(_prev_result, _timer.raw_duration());
+
+  if (_prev_result)
+    real_target->fetch_metadata();
+
+  return ret_val;
+}
+
+Connection::~Connection()
+{
+  close();
+}
\ No newline at end of file
diff --git a/modules/mysql.h b/modules/mysql.h
new file mode 100644
index 0000000000000000000000000000000000000000..a9f4074133e669cff8562ca8d8c617825f397b46
--- /dev/null
+++ b/modules/mysql.h
@@ -0,0 +1,170 @@
+/*
+ * Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+// MySQL DB access module, for use by plugins and others
+// For the module that implements interactive DB functionality see mod_db
+
+#ifndef _MOD_MYSQL_H_
+#define _MOD_MYSQL_H_
+
+#include "shellcore/types.h"
+#include "shellcore/types_cpp.h"
+#include "utils_time.h"
+#include "boost/enable_shared_from_this.hpp"
+
+#if WIN32
+#  include <winsock2.h>
+#endif
+
+#include <mysql.h>
+#include "mod_common.h"
+
+namespace mysh
+{
+  namespace mysql
+  {
+    /*    class Session :public ISession, public shcore::Cpp_object_bridge, public boost::enable_shared_from_this<Mysql_connection>
+        {
+        private:
+        MySQL_timer _timer;
+        std::string _uri;
+        std::string _pwd;
+        };*/
+
+    class MOD_PUBLIC Field
+    {
+    public:
+      Field(const std::string& catalog, const std::string& db, const std::string& table, const std::string& otable, const std::string& name, const std::string& oname, int length, int type, int flags, int decimals, int charset);
+
+      const std::string& catalog() { return _catalog; };
+      const std::string& db() { return _db; };
+      const std::string& table() { return _table; };
+      const std::string& org_table() { return _org_table; };
+      const std::string& name() { return _name; };
+      const std::string& org_name() { return _org_name; };
+      const unsigned int length() { return _length; }
+      const unsigned int type() { return _type; }
+      const unsigned int flags() { return _flags; }
+      const unsigned int decimals() { return _decimals; }
+      const unsigned int charset() { return _charset; }
+
+      const unsigned int max_length() { return _max_length; }
+      void max_length(int length) { _max_length = length; }
+
+      const unsigned int name_length() { return _name_length; }
+
+    private:
+      std::string _catalog;
+      std::string _db;
+      std::string _table;
+      std::string _org_table;
+      std::string _name;
+      std::string _org_name;
+      unsigned long _length;
+      unsigned int _type;
+      unsigned int _flags;
+      unsigned int _decimals;
+      unsigned int _charset;
+
+      unsigned long _max_length;
+      unsigned long _name_length;
+    };
+
+    class Row
+    {
+    public:
+      Row(MYSQL_ROW row, unsigned long *lengths, std::vector<Field>* metadata = NULL);
+      virtual ~Row() {}
+
+      virtual shcore::Value get_value(int index);
+      virtual std::string get_value_as_string(int index);
+
+    private:
+      MYSQL_ROW _row;
+      unsigned long *_lengths;
+      std::vector<Field> *_metadata;
+    };
+
+    class Connection;
+    class MOD_PUBLIC Result
+    {
+    public:
+      Result(boost::shared_ptr<Connection> owner, my_ulonglong affected_rows, unsigned int warning_count, const char *info);
+      virtual ~Result();
+
+      void reset(boost::shared_ptr<MYSQL_RES> res, unsigned long duration);
+
+    public:
+      std::vector<Field>& get_metadata(){ return _metadata; };
+
+      // Data Retrieving
+      Row *next();
+      bool next_result();
+      Result *query_warnings();
+
+      bool has_resultset() { return _has_resultset; }
+
+      // Metadata retrieving
+      uint64_t affected_rows() { return _affected_rows; }
+      uint64_t fetched_row_count() { return _fetched_row_count; }
+      int warning_count(){ return _warning_count; }
+      unsigned long execution_time(){ return _execution_time; }
+      uint64_t last_insert_id() { return _last_insert_id; }
+      std::string info() { return _info; }
+
+      //private:
+      int fetch_metadata();
+      int fetch_warnings();
+
+    private:
+      boost::shared_ptr<Connection> _connection;
+      std::vector<Field>_metadata;
+
+      boost::weak_ptr<MYSQL_RES> _result;
+      uint64_t _affected_rows;
+      uint64_t _last_insert_id;
+      unsigned int _warning_count;
+      unsigned int _fetched_row_count;
+      std::string _info;
+      unsigned long _execution_time;
+      bool _has_resultset;
+    };
+
+    class MOD_PUBLIC Connection : public boost::enable_shared_from_this<Connection>
+    {
+    public:
+      Connection(const std::string &uri, const char *password = NULL);
+      ~Connection();
+
+      void close();
+      Result *executeSql(const std::string &sql);
+      bool next_result(Result *target, bool first_result = false);
+      std::string uri() { return _uri; }
+
+    private:
+      std::string _uri;
+      MYSQL *_mysql;
+      MySQL_timer _timer;
+
+      boost::shared_ptr<MYSQL_RES> _prev_result;
+    };
+  };
+};
+
+#endif
diff --git a/mysqlxtest/common/mysqlx_parser.h b/mysqlxtest/common/mysqlx_parser.h
index fda6c1d88bef8086a7bdf782fc497b6cd104a441..970037f95141bc065beafdecf6a8ce9990800e2e 100644
--- a/mysqlxtest/common/mysqlx_parser.h
+++ b/mysqlxtest/common/mysqlx_parser.h
@@ -20,7 +20,6 @@
 #ifndef _MYSQLX_PARSER_H_
 #define _MYSQLX_PARSER_H_
 
-#include "expr_parser.h"
 #include "proj_parser.h"
 
 #include <string>
diff --git a/mysqlxtest/mysqlx.cc b/mysqlxtest/mysqlx.cc
index bd1005c52ea87cf38ce207d0b7096ed26459a729..e60e05e4830fc168680b5db299323b6631bc9db1 100644
--- a/mysqlxtest/mysqlx.cc
+++ b/mysqlxtest/mysqlx.cc
@@ -30,10 +30,10 @@
 #include <limits>
 #include <mysql/service_my_snprintf.h>
 
-#ifdef WIN32
-#  define snprintf _snprintf
-#  pragma push_macro("ERROR")
-#  undef ERROR
+#ifdef WIN32
+#  define snprintf _snprintf
+#  pragma push_macro("ERROR")
+#  undef ERROR
 #endif
 
 using namespace mysqlx;
@@ -225,35 +225,56 @@ Result *Connection::execute_sql(const std::string &sql)
     exec.set_stmt(sql);
     send(exec);
   }
-  return new Result(this, true, true);
+
+  Result *result = new Result(this, true, true);
+
+  result->wait();
+
+  return result;
 }
 
 Result *Connection::execute_find(const Mysqlx::Crud::Find &m)
 {
   send(m);
 
-  return new Result(this, false, true);
+  Result *result = new Result(this, false, true);
+
+  result->wait();
+
+  return result;
 }
 
 Result *Connection::execute_update(const Mysqlx::Crud::Update &m)
 {
   send(m);
 
-  return new Result(this, false, false);
+  Result *result = new Result(this, false, false);
+
+  result->wait();
+
+  return result;
 }
 
 Result *Connection::execute_insert(const Mysqlx::Crud::Insert &m)
 {
   send(m);
 
-  return new Result(this, false, false);
+  Result *result = new Result(this, false, false);
+
+  result->wait();
+
+  return result;
 }
 
 Result *Connection::execute_delete(const Mysqlx::Crud::Delete &m)
 {
   send(m);
 
-  return new Result(this, false, false);
+  Result *result = new Result(this, false, false);
+
+  result->wait();
+
+  return result;
 }
 
 void Connection::authenticate_plain(const std::string &user, const std::string &pass, const std::string &db)
@@ -532,6 +553,19 @@ std::auto_ptr<mysqlx::Message> Result::read_next(int &mid)
   switch (m_state)
   {
     case ReadMetadataI:
+    {
+                        switch (mid)
+                        {
+                          case Mysqlx::ServerMessages::SQL_STMT_EXECUTE_OK:
+                            m_state = ReadDone;
+                            return msg;
+
+                          case Mysqlx::ServerMessages::SQL_COLUMN_META_DATA:
+                            m_state = ReadMetadata;
+                            return msg;
+                        }
+                        break;
+    }
     case ReadMetadata:
     {
                        switch (mid)
@@ -904,6 +938,6 @@ int Row::numFields() const
   return m_data->field_size();
 }
 
-#ifdef WIN32
-#  pragma pop_macro("ERROR")
+#ifdef WIN32
+#  pragma pop_macro("ERROR")
 #endif
\ No newline at end of file
diff --git a/scripting/modules/js/mysql.js b/scripting/modules/js/mysql.js
new file mode 100644
index 0000000000000000000000000000000000000000..0b50ad842a6469dcd974ed80c2f64e01916c4487
--- /dev/null
+++ b/scripting/modules/js/mysql.js
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301  USA
+ */
+
+exports.mysql = {}
+
+// Connection functions
+exports.mysql.openSession = function(connection_data)
+{
+  var session = _F.mysql.Session(connection_data);
+  
+  return session;
+}
\ No newline at end of file
diff --git a/scripting/modules/js/mysqlx.js b/scripting/modules/js/mysqlx.js
index 75d128e6ff1f699f8d09523ca50ca86796107ba3..70a8cf948e5f9d3f74afad61411931ff4fd822a1 100644
--- a/scripting/modules/js/mysqlx.js
+++ b/scripting/modules/js/mysqlx.js
@@ -18,630 +18,20 @@
  */
 
 exports.mysqlx = {}
- 
-exports.mysqlx.openNodeSession = function(connection_data)
-{
-  // TODO: Add logic to enable handling the different formats of the connection data
-  return new NodeSession(connection_data);
-}
 
+// Connection functions
 exports.mysqlx.openSession = function(connection_data)
 {
-  // TODO: Add logic to enable handling the different formats of the connection data
-  return new Session(connection_data);
-}
- 
-//--- Dev-API: Session Object
-function BaseSession(connection_data)
-{
-  // Connection represents the protocol interface
-  // Must be completely hidden from the outside
-  var _conn = _F.mysqlx.Connection(connection_data);
-
-  // Privileged function to enable accessing the connection
-  // to perform operations through it
-  function _exec_sql(sql)
-  {
-    return _conn.sql(sql);
-  }
-  
-  Object.defineProperty(this, '_schemas', {value: {}});
-  Object.defineProperty(this, '_loaded', {value: false, writable:true});
-  Object.defineProperty(this, '_query_data', 
-  {
-    value: function(key, param1, param2)
-    {
-      switch(key)
-      {
-        // Used to load all the schemas on the database
-        case 'default_schema':
-          return _exec_sql('select schema()');
-        case 'schema':
-          return _exec_sql('show databases like "'+ param1 +'"');
-        case 'schemas':
-          return _exec_sql('show databases');
-        case 'tables':
-          if (typeof param1 === 'undefined')
-            throw 'Query data request ' + key + ' is missing a parameter'
-          return _exec_sql('show full tables in `' + param1 + '`')
-        case 'table':
-          if (typeof param1 === 'undefined' || typeof param2 === 'undefined' )
-            throw 'Query data request ' + key + ' is missing a parameter'
-          return _exec_sql('show full tables in `' + param1 + '` like "'+ param2 +'"')
-        default:
-          // Using this hack to only allow arbitrary sql execution from inside
-          // an instance of NodeSession, this is needed because:
-          // - _exec_sql is only visible at this scope.
-          // - Have not found a way to define it as a protected member.
-          // - Even _query_data is hidden, it's accessible from outside.
-          //
-          // TODO: Find a way to define protected members so we can remove the
-          //       usage of NodeSession at this level.
-          if (this instanceof NodeSession)
-            return _exec_sql(key);
-          else
-            throw "Invalid query data operation: " + key;
-      }
-      
-      return null;
-    }
-  });
-  
-  function _instantiate_schema(session, name, in_db, verify)
-  {
-    return new Schema(session, name, _conn, in_db, verify);
-  }
-
-  Object.defineProperty(this, '_new_schema', 
-  {
-    value: function(name, in_db, verify)
-    {
-      return _instantiate_schema(this, name, in_db, verify);
-    }
-  });
-}
-
-BaseSession.prototype.getSchemas = function()
-{
-  if (!this._loaded)
-  {
-    var res = this._query_data('schemas');
-    
-    if (res)
-    {
-      var data = res.all(true);
-      
-      // Creates a new schema object if not exists already
-      for(index in data)
-      {
-        var name = data[index][0];
-        
-        if ( typeof this._schemas[name] === "undefined")
-        {
-          var schema = this._new_schema(name, true, false);
-          
-          // Stores the schema on the registry
-          this._schemas[name] = schema;
-          
-          // As well as session property if does not exist already
-          if (typeof this[name] === 'undefined')
-            this[name] = schema;
-        }
-      }
-      
-      this._loaded = true;
-    }
-  }
-  
-  return this._schemas;
-}
-
-Object.defineProperty(BaseSession.prototype, 'schemas', 
-{
-  enumerable: true,
-  get: BaseSession.prototype.getSchemas
-})
-
-BaseSession.prototype.toString = function()
-{
-  return "BaseSession";
-}
-
-BaseSession.prototype.getSchema = function(name)
-{
-  if ( typeof this._schemas[name] === "undefined")
-  {
-    var schema = this._new_schema(name, true, true);
-    
-    if (typeof schema != "undefined")
-    {
-      // Adds it to the schema registry
-      this._schemas[name] = schema;
-      
-      // As well as session property if does not exist already
-      if (typeof this[name] === 'undefined')
-        this[name] = schema;
-    }
-  }
-  
-  return this._schemas[name]
-}
-
-BaseSession.prototype.getDefaultSchema = function()
-{
-  var schema = null;
-  var res = this._query_data('default_schema');
-  var data = res.next(true);
-  
-  if (data[0] != null)
-    schema = this.getSchema(data[0])
-  
-  return schema;
-}
-
-Object.defineProperty(BaseSession.prototype, 'default_schema', 
-{
-  enumerable: true,
-  get: BaseSession.prototype.getDefaultSchema
-})
-
-//--- Dev-API: Session
-function Session(cd)
-{
-  BaseSession.call(this, cd);
-}
-
-Session.prototype = Object.create(BaseSession.prototype);
-Object.defineProperty(NodeSession.prototype, 'constructor', {value: Session});
-
-exports.mysqlx.Session = Session;
-
-//--- Dev-API: NodeSession
-function NodeSession(cd)
-{
-  BaseSession.call(this, cd);
-
-  this.executeSql = function(sql) 
-  {
-    return this._query_data(sql);
-  }
-}
-
-NodeSession.prototype = Object.create(BaseSession.prototype);
-Object.defineProperty(NodeSession.prototype, 'constructor', {value: NodeSession});
-
-exports.mysqlx.NodeSession = NodeSession;
-
-//-------- Dev-API Database Objects
-function DatabaseObject(session, schema, name, in_db)
-{
-  Object.defineProperty(this, 'session',  {value: session, enumerable: true});
-  Object.defineProperty(this, 'schema',  {value: schema, enumerable: true});
-  Object.defineProperty(this, 'name',  {value: name, enumerable: true});
-  Object.defineProperty(this, 'in_database',  {value: in_db, enumerable: true});
-}
-
-DatabaseObject.prototype.getSession = function()
-{
-  return this.session;
-}
-
-DatabaseObject.prototype.getSchema = function()
-{
-  return this.schema;
-}
-
-DatabaseObject.prototype.getName = function()
-{
-  return this.name;
-}
-
-DatabaseObject.prototype.existsInDatabase = function()
-{
-  return this.in_database;
-}
-
-//--- Schema Object
-function Schema(session, name, connection, in_db, verify)
-{
-  var _conn = connection;
-  
-  Object.defineProperty(this, '_tables', {value: {}});
-  Object.defineProperty(this, '_collections', {value: {}});
-  Object.defineProperty(this, '_views', {value: {}});
-  Object.defineProperty(this, '_loaded', {value: false, writable: true});
-
-  function _instantiate_table(schema, name, in_db, verify)
-  {
-    return new Table(schema, name, _conn, in_db, verify);
-  }
-  
-  function _instantiate_view(schema, name, in_db, verify)
-  {
-    return new View(schema, name, _conn, in_db, verify);
-  }
-  
-  function _instantiate_collection(schema, name, in_db, verify)
-  {
-    return new Collection(schema, name, _conn, in_db, verify);
-  }
-  
-  Object.defineProperty(this, '_new_table', 
-  {
-    value: function(name, in_db, verify)
-    {
-      return _instantiate_table(this, name, in_db, verify);
-    }
-  });
-  
-  Object.defineProperty(this, '_new_view', 
-  {
-    value: function(name, in_db, verify)
-    {
-      return _instantiate_view(this, name, in_db, verify);
-    }
-  });
-  
-  Object.defineProperty(this, '_new_collection', 
-  {
-    value: function(name, in_db, verify)
-    {
-      return _instantiate_collection(this, name, in_db, verify);
-    }
-  });
-  
-  DatabaseObject.call(this, session, this, name, in_db)
-  
-  if (typeof verify !== "undefined" && verify)
-    this._verify()
-}
-
-Schema.prototype = Object.create(DatabaseObject.prototype);
-Object.defineProperty(Schema.prototype, 'constructor', {value: Schema});
-Object.defineProperty(Schema.prototype, '_verify', 
-{
-  value: function()
-  {
-    var is_valid = false;
-    var res = this.session._query_data('schema', this.name);
-    
-    if (res)
-    {
-      var data = res.all(true);
-
-      if (data.length == 1 && data[0][0] == this.name)
-        is_valid = true;
-    }
-    
-    if (!is_valid)
-    {
-      var error = "Undefined schema " + this.name;
-      throw (error)
-    }
-  }
-});
-
-Object.defineProperty(Schema.prototype, '_loadObjects', 
-{
-  value: function()
-  {
-    var res = this.session._query_data('tables', this.name);
-    
-    if (res)
-    {
-      var data = res.all(true);
-      
-      // Creates a new table/view/collection object if not exists already
-      for(index in data)
-      {
-        var type = data[index][1];
-        var name = data[index][0];
-        var object;
-        
-        if (type == "BASE TABLE"){
-          // TODO: temporary logic to allow requesting collections
-          //       This should be placed into it's own else if once
-          //       Collections are identifiable.
-          // NOTE: No collections will be added as schema.collection
-          //       for the moment until this gets fixed
-          if (typeof this._collections[name] === "undefined")
-          {
-            object = this._new_collection(name, true);
-            this._collections[name] = object;
-          }
-          
-          if (typeof this._tables[name] === "undefined")
-          {
-            object = this._new_table(name, true);
-            this._tables[name] = object;
-          }
-        }
-        else
-        {
-          if (typeof this._views[name] === "undefined")
-          {
-            object = this._new_view(name, true);
-            this._views[name] = object;
-          }
-        }
-        
-        // Creates the schema atribute if not already exists
-        if (typeof object !== 'undefined' && typeof this[name] === 'undefined')
-          this[name] = object;
-      }
-    }
-    
-    this._loaded = true;
-  },
-  enumerable: false
-});
-
-Schema.prototype.getCollections = function()
-{
-  if (!this._loaded)
-    this._loadObjects();
+  var session = _F.mysqlx.Session(connection_data);
   
-  return this._collections;
+  return session;
 }
 
-Object.defineProperty(Schema.prototype, 'collections', 
-{
-  enumerable: true,
-  get: Schema.prototype.getCollections
-})
-
-
-Schema.prototype.getCollection = function(name)
-{
-  if ( typeof this._collections[name] === "undefined")
-  {
-    var collection = this._new_collection(name, true, true)
-    
-    if (typeof collection !== 'undefined')
-    {
-      this._collections[name] = collection;
-      
-      if (typeof this[name] === 'undefined')
-        this[name] = collection;
-    }
-  }
-  
-  return this._collections[name]
-}
-
-
-Schema.prototype.getTables = function()
-{
-  if (!this._loaded)
-    this._loadObjects();
-  
-  return this._tables;
-}
-
-Object.defineProperty(Schema.prototype, 'tables', 
-{
-  enumerable: true,
-  get: Schema.prototype.getTables
-})
-
-
-Schema.prototype.getTable = function(name)
-{
-  if ( typeof this._tables[name] === "undefined")
-  {
-    var table = this._new_table(name, true, true);
-    
-    if (typeof table !== 'undefined')
-    {
-      this._tables[name] = table;
-      
-      if (typeof this[name] === 'undefined')
-        this[name] = table;
-    }
-  }
-  
-  return this._tables[name]
-}
-
-Schema.prototype.getViews = function()
-{
-  if (!this._loaded)
-    this._loadObjects();
-  
-  return this._views;
-}
-
-Object.defineProperty(Schema.prototype, 'views', 
-{
-  enumerable: true,
-  get: Schema.prototype.getTables
-})
-
-Schema.prototype.getView = function(name)
-{
-  if ( typeof this._views[name] === "undefined")
-  {
-    var view = new View(this, name, true, true)
-    
-    if (typeof view !== 'undefined')
-    {
-      this._views[name] = view;
-      
-      if (typeof this[name] === 'undefined')
-        this[name] = view;
-    }
-  }
-  
-  return this._views[name]
-}
-
-exports.mysqlx.Schema = Schema;
-
-//--- Table Object
-function Table(schema, name, connection, in_db, verify)
-{
-  var _conn = connection;
-  
-  DatabaseObject.call(this, schema.getSession(), schema, name, in_db);
-  
-  if (typeof verify === "boolean" && verify)
-    this._verify();
-  
-  function _instantiate_insert(schema, table)
-  {
-    return _F.mysqlx.TableInsert(_conn, schema, table);
-  }
-  
-  Object.defineProperty(this, '_new_crud', 
-  {
-    value: function(type)
-    {
-      switch(type)
-      {
-        case 'insert':
-          return _instantiate_insert(this.schema.name, this.name);
-          break;
-      }
-    }
-  });
-}
-
-Table.prototype = Object.create(DatabaseObject.prototype);
-Object.defineProperty(Table.prototype, 'constructor', {value: Table});
-Object.defineProperty(Table.prototype, '_verify', 
-{
-  value: function()
-  {
-    var is_valid = false;
-    var res = this.session._query_data('table', this.schema.name, this.name);
-    
-    if (res)
-    {
-      var data = res.all(true);
-
-      if (data.length == 1 && data[0][1] == "BASE TABLE")
-        is_valid = true;
-    }
-    
-    if (!is_valid)
-    {
-      var error = "Undefined table " + this.name + " on schema " + this.schema.name;
-      throw (error)
-    }
-  }
-});
-
-Table.prototype.insert = function(data)
-{
-  var insert = this._new_crud('insert');
-  
-  if (typeof data === "undefined")
-    return insert.insert();
-  else
-    return insert.insert(data);  
-}
-
-exports.mysqlx.Table = Table;
-
-
-//--- Collection Object
-function Collection(schema, name, connection, in_db, verify)
-{
-  var _conn = connection;
-  
-  DatabaseObject.call(this, schema.getSession(), schema, name, in_db);
-  
-  if (typeof verify === "boolean" && verify)
-    this._verify()
-  
-  function _instantiate_crud(type, schema, collection)
-  {
-    switch(type)
-    {
-      case 'add':
-    return _F.mysqlx.CollectionAdd(_conn, schema, collection);
-      case 'find':
-        return _F.mysqlx.CollectionFind(_conn, schema, collection);
-      case 'remove':
-        return _F.mysqlx.CollectionRemove(_conn, schema, collection);
-    }
-  }
-  
-  Object.defineProperty(this, '_new_crud', 
-  {
-    value: function(type)
-    {
-      return _instantiate_crud(type, this.schema.name, this.name);
-    }
-  });
-  
-}
-
-Collection.prototype = Object.create(DatabaseObject.prototype);
-Object.defineProperty(Collection.prototype, 'constructor', {value: Collection});
-
-Collection.prototype._verify = function()
-{
-  var is_valid = false;
-  var res = this.session._query_data('table', this.schema.name, this.name);
-  
-  if (res)
-  {
-    var data = res.all(true);
-    
-    //TODO: Update this to the right validation once
-    //      collections are identifiable
-    if (data.length == 1 && data[0][1] == "BASE TABLE")
-      is_valid = true;
-  }
-  
-  if (!is_valid)
-  {
-    var error = "Undefined collection " + this.name + " on schema " + this.schema.name;
-    throw (error);
-  }
-}
-
-Collection.prototype.add = function(data)
-{
-  var add = this._new_crud('add');
-  
-  if (typeof data === "undefined")
-    return add.add();
-  else
-    return add.add(data);
-}
-
-Collection.prototype.find = function(data)
-{
-  var find = this._new_crud('find');
-  
-  if (typeof data === "undefined")
-    return find.find();
-  else
-    return find.find(data);
-}
-
-Collection.prototype.remove = function(data)
+exports.mysqlx.openNodeSession = function(connection_data)
 {
-  var remove = this._new_crud('remove');
+  // At some point this will instantiate a nodeSession object
+  var session = _F.mysqlx.NodeSession(connection_data);
   
-  if (typeof data === "undefined")
-    return remove.remove();
-  else
-    return remove.remove(data);
+  return session;
 }
 
-exports.mysqlx.Collection = Collection;
-
-
-//--- View Object
-function View(schema, name, in_db)
-{
-  DatabaseObject.call(this, schema.getSession(), schema, name, in_db);
-}
-
-View.prototype = Object.create(DatabaseObject.prototype);
-Object.defineProperty(View.prototype, 'constructor', {value: View});
-
-exports.mysqlx.View = View;
diff --git a/shellcore/CMakeLists.txt b/shellcore/CMakeLists.txt
index f8d0a1bce1cd77acf902a025c9b81c7dc824eeac..11530a337a7f0d9d96b991e97af6cbcd78fb2f7f 100644
--- a/shellcore/CMakeLists.txt
+++ b/shellcore/CMakeLists.txt
@@ -17,6 +17,7 @@ remove_definitions(-Dmysqlshmods_EXPORTS)
 
 include_directories( ${MYSQL_INCLUDE_DIRS} )
 include_directories( ${CMAKE_BINARY_DIR} )
+include_directories( ${CMAKE_SOURCE_DIR}/mysqlxtest)
 include_directories("${CMAKE_SOURCE_DIR}/include" "${CMAKE_SOURCE_DIR}/utils" "${Boost_INCLUDE_DIRS}")
 include_directories( "${CMAKE_SOURCE_DIR}/common/uuid/include" )
 include_directories( "${CMAKE_SOURCE_DIR}/common/myjson/include" )
diff --git a/shellcore/jscript_type_conversion.cc b/shellcore/jscript_type_conversion.cc
index 9e425b8deaf699b356a6d5b42d4d34e067d7eb04..a09de06f5e24c73d8552808faebe1448ba4ff602 100644
--- a/shellcore/jscript_type_conversion.cc
+++ b/shellcore/jscript_type_conversion.cc
@@ -73,7 +73,7 @@ double JScript_type_bridger::call_num_method(v8::Handle<v8::Object> object, cons
 
 v8::Handle<v8::Value> JScript_type_bridger::native_object_to_js(Object_bridge_ref object)
 {
-  if (object->class_name() == "Date")
+  if (object && object->class_name() == "Date")
   {
     boost::shared_ptr<Date> date = boost::static_pointer_cast<Date>(object);
     return v8::Date::New(owner->isolate(), date->as_ms());
diff --git a/shellcore/shell_sql.cc b/shellcore/shell_sql.cc
index 78de352b791943e514a63116d535e0ba16d52f8e..f0e751226f2307336b8f53aac638ab876b73c9f3 100644
--- a/shellcore/shell_sql.cc
+++ b/shellcore/shell_sql.cc
@@ -18,8 +18,7 @@
  */
 
 #include "shellcore/shell_sql.h"
-#include "../modules/mod_session.h"
-#include "../modules/mod_connection.h"
+#include "../modules/base_session.h"
 #include "../utils/utils_mysql_parsing.h"
 #include <boost/bind.hpp>
 #include <boost/format.hpp>
@@ -49,106 +48,117 @@ Value Shell_sql::handle_input(std::string &code, Interactive_input_state &state,
 
   if (session_wrapper)
   {
-    boost::shared_ptr<mysh::Session> session = session_wrapper.as_object<mysh::Session>();
-    std::vector<std::pair<size_t, size_t> > ranges;
-    size_t statement_count;
-
-    // If no cached code and new code is a multiline statement
-    // allows multiline code to bypass the splitter
-    // This way no delimiter change is needed for i.e.
-    // stored procedures and functions
-    if (_sql_cache.empty() && code.find("\n") != std::string::npos)
-    {
-      ranges.push_back(std::make_pair<size_t, size_t>(0, code.length()));
-      statement_count = 1;
-    }
-    else
-    {
-      // Parses the input string to identify individual statements in it.
-      // Will return a range for every statement that ends with the delimiter, if there
-      // is additional code after the last delimiter, a range for it will be included too.
-      statement_count = shcore::mysql::splitter::determineStatementRanges(code.c_str(), code.length(), _delimiter, ranges, "\n", _parsing_context_stack);
-    }
+    boost::shared_ptr<mysh::BaseSession> session = session_wrapper.as_object<mysh::BaseSession>();
 
-    // statement_count is > 0 if the splitter determined a statement was completed
-    // ranges: contains the char ranges having statements.
-    // special case: statement_count is 1 but there are no ranges: the delimiter was sent on the last call to the splitter
-    //               and it determined the continued statement is now complete, but there's no additional data for it
-    size_t index = 0;
-
-    // Gets the total number of ranges
-    size_t range_count = ranges.size();
-    std::vector<std::string> statements;
-    if (statement_count)
+    if (session)
     {
-      // If cache has data it is part of the found statement so it has to
-      // be flushed at this point into the statements list for execution
-      if (!_sql_cache.empty())
+      std::vector<std::pair<size_t, size_t> > ranges;
+      size_t statement_count;
+
+      // If no cached code and new code is a multiline statement
+      // allows multiline code to bypass the splitter
+      // This way no delimiter change is needed for i.e.
+      // stored procedures and functions
+      if (_sql_cache.empty() && code.find("\n") != std::string::npos)
       {
-        if (statement_count > range_count)
-          statements.push_back(_sql_cache);
-        else
-        {
-          statements.push_back(_sql_cache.append("\n").append(code.substr(ranges[0].first, ranges[0].second)));
-          index++;
-        }
-
-        _sql_cache.clear();
+        ranges.push_back(std::make_pair<size_t, size_t>(0, code.length()));
+        statement_count = 1;
       }
-
-      if (range_count)
+      else
       {
-        // Now also adds the rest of the statements for execution
-        for (; index < statement_count; index++)
-          statements.push_back(code.substr(ranges[index].first, ranges[index].second));
-
-        // If there's still data, itis a partial statement: gets cached
-        if (index < range_count)
-          _sql_cache = code.substr(ranges[index].first, ranges[index].second);
+        // Parses the input string to identify individual statements in it.
+        // Will return a range for every statement that ends with the delimiter, if there
+        // is additional code after the last delimiter, a range for it will be included too.
+        statement_count = shcore::mysql::splitter::determineStatementRanges(code.c_str(), code.length(), _delimiter, ranges, "\n", _parsing_context_stack);
       }
 
-      code = _sql_cache;
+      // statement_count is > 0 if the splitter determined a statement was completed
+      // ranges: contains the char ranges having statements.
+      // special case: statement_count is 1 but there are no ranges: the delimiter was sent on the last call to the splitter
+      //               and it determined the continued statement is now complete, but there's no additional data for it
+      size_t index = 0;
 
-      // Executes every found statement
-      for (index = 0; index < statements.size(); index++)
+      // Gets the total number of ranges
+      size_t range_count = ranges.size();
+      std::vector<std::string> statements;
+      if (statement_count)
       {
-        shcore::Argument_list query;
-        query.push_back(Value(statements[index]));
-
-        try
+        // If cache has data it is part of the found statement so it has to
+        // be flushed at this point into the statements list for execution
+        if (!_sql_cache.empty())
         {
-          ret_val = session->sql(query);
+          if (statement_count > range_count)
+            statements.push_back(_sql_cache);
+          else
+          {
+            statements.push_back(_sql_cache.append("\n").append(code.substr(ranges[0].first, ranges[0].second)));
+            index++;
+          }
+
+          _sql_cache.clear();
         }
-        catch (shcore::Exception &exc)
+
+        if (range_count)
         {
-          session->print_exception(exc);
+          // Now also adds the rest of the statements for execution
+          for (; index < statement_count; index++)
+            statements.push_back(code.substr(ranges[index].first, ranges[index].second));
+
+          // If there's still data, itis a partial statement: gets cached
+          if (index < range_count)
+            _sql_cache = code.substr(ranges[index].first, ranges[index].second);
         }
 
-        if (_last_handled.empty())
-          _last_handled = statements[index];
+        code = _sql_cache;
+
+        // Executes every found statement
+        for (index = 0; index < statements.size(); index++)
+        {
+          shcore::Argument_list query;
+          query.push_back(Value(statements[index]));
+
+          try
+          {
+            if (session->has_member("executeSql"))
+              ret_val = session->call("executeSql", query);
+            else
+              throw shcore::Exception::logic_error("The current session can't be used for SQL execution.");
+          }
+          catch (shcore::Exception &exc)
+          {
+            print_exception(exc);
+          }
+
+          if (_last_handled.empty())
+            _last_handled = statements[index];
+          else
+            _last_handled.append("\n").append(statements[index]);
+        }
+      }
+      else if (range_count)
+      {
+        if (_sql_cache.empty())
+          _sql_cache = code.substr(ranges[0].first, ranges[0].second);
         else
-          _last_handled.append("\n").append(statements[index]);
+          _sql_cache.append("\n").append(code.substr(ranges[0].first, ranges[0].second));
       }
-    }
-    else if (range_count)
-    {
-      if (_sql_cache.empty())
-        _sql_cache = code.substr(ranges[0].first, ranges[0].second);
-      else
-        _sql_cache.append("\n").append(code.substr(ranges[0].first, ranges[0].second));
-    }
-    else // Multiline code, all is "processed"
-      code = "";
+      else // Multiline code, all is "processed"
+        code = "";
 
-    // Nothing was processed so it is not an error
-    if (!statement_count)
-      ret_val = Value::Null();
+      // Nothing was processed so it is not an error
+      if (!statement_count)
+        ret_val = Value::Null();
 
-    if (_parsing_context_stack.empty())
-      state = Input_ok;
+      if (_parsing_context_stack.empty())
+        state = Input_ok;
+      else
+        state = Input_continued;
+    }
     else
-      state = Input_continued;
+      throw shcore::Exception::logic_error("Not connected.");
   }
+  else
+    throw shcore::Exception::logic_error("Not connected.");
 
   // TODO: previous to file processing the caller was caching unprocessed code and sending it again on next
   //       call. On file processing an internal handling of this cache was required.
@@ -178,6 +188,30 @@ bool Shell_sql::print_help(const std::string& topic)
   return ret_val;
 }
 
+void Shell_sql::print_exception(const shcore::Exception &e)
+{
+  // Removes the type, at this moment only type is MySQLError
+  // Reason is that leaving it will print things like:
+  // ERROR: MySQLError (code) message
+  // Where ERROR is added on the called print_error routine
+  //std::string message = (*e.error())["type"].as_string();
+
+  std::string message;
+  if ((*e.error()).has_key("code"))
+  {
+    //message.append(" ");
+    message.append(((*e.error())["code"].repr()));
+
+    if ((*e.error()).has_key("state") && (*e.error())["state"])
+      message.append((boost::format(" (%s)") % ((*e.error())["state"].as_string())).str());
+
+    message.append(": ");
+  }
+  message.append(e.what());
+
+  _owner->print_error(message);
+}
+
 //------------------ SQL COMMAND HANDLERS ------------------//
 
 void Shell_sql::cmd_enable_auto_warnings(const std::vector<std::string>& params)
diff --git a/src/main.cc b/src/main.cc
index 8877c2bd8558df35cd1923e65093c099f7a36fe7..20d123bdef65c51a5eaac0b34f35302e6d215bce 100644
--- a/src/main.cc
+++ b/src/main.cc
@@ -42,8 +42,8 @@
 
 #include "cmdline_options.h"
 
-#include "../modules/mod_session.h"
-#include "../modules/mod_db.h"
+#include "../modules/base_session.h"
+//#include "../modules/mod_schema.h"
 #include <sys/stat.h>
 
 #ifdef WIN32
@@ -109,8 +109,8 @@ private:
 private:
   Interpreter_delegate _delegate;
 
-  boost::shared_ptr<mysh::Session> _session;
-  boost::shared_ptr<mysh::Db> _db;
+  boost::shared_ptr<mysh::BaseSession> _session;
+  //boost::shared_ptr<mysh::mysqlx::Schema> _db;
   boost::shared_ptr<Shell_core> _shell;
 
   std::string _input_buffer;
@@ -143,11 +143,11 @@ _batch_continue_on_error(false)
 
   _shell.reset(new Shell_core(&_delegate));
 
-  _session.reset(new mysh::Session(dynamic_cast<shcore::IShell_core*>(_shell.get())));
-  _shell->set_global("session", Value(boost::static_pointer_cast<Object_bridge>(_session)));
+  //_session.reset(new mysh::mysqlx::Session(dynamic_cast<shcore::IShell_core*>(_shell.get())));
+  //_shell->set_global("session", Value(boost::static_pointer_cast<Object_bridge>(_session)));
 
-  //  _db.reset(new mysh::Db(_shell.get()));
-  //  _shell->set_global("db", Value( boost::static_pointer_cast<Object_bridge, mysh::Db >(_db) ));
+  //  _db.reset(new mysh::Schema(_shell.get()));
+  //  _shell->set_global("db", Value( boost::static_pointer_cast<Object_bridge, mysh::Schema >(_db) ));
 
   std::string cmd_help =
     "SYNTAX:\n"
@@ -230,7 +230,7 @@ bool Interactive_shell::connect(const std::string &uri, bool needs_password)
 
   try
   {
-    if (_session->is_connected())
+    if (_session && _session->is_connected())
     {
       shcore::print("Closing old connection...\n");
       _session->disconnect();
@@ -253,14 +253,19 @@ bool Interactive_shell::connect(const std::string &uri, bool needs_password)
 
 Value Interactive_shell::connect_session(const Argument_list &args)
 {
-  _session->connect(args);
+  // TODO: Review if this replacement is correct
+  boost::shared_ptr<mysh::BaseSession> new_session(mysh::connect_session(args));
+  _session.reset(new_session, new_session.get());
+
+  _shell->set_global("session", Value(boost::static_pointer_cast<Object_bridge>(_session)));
 
-  boost::shared_ptr<mysh::Db> db(_session->default_schema());
-  if (db)
+  Value default_schema = _session->get_member("defaultSchema");
+  if (default_schema)
   {
-    if (_shell->interactive_mode() != Shell_core::Mode_SQL)
-      _shell->print("Default schema `" + db->schema() + "` accessible through db.\n");
-    _shell->set_global("db", Value(boost::static_pointer_cast<Object_bridge>(db)));
+    // TODO: Uncomment this...
+    //if (_shell->interactive_mode() != Shell_core::Mode_SQL)
+    //  _shell->print("Default schema `" + db->schema() + "` accessible through db.\n");
+    _shell->set_global("db", default_schema);
   }
   else
   {
diff --git a/unittest/CMakeLists.txt b/unittest/CMakeLists.txt
index c86c797f2fff60072e91b16e5fa01f5008491c6a..99d40da46c29f4e37323a200ba3a7fe36816c5bb 100644
--- a/unittest/CMakeLists.txt
+++ b/unittest/CMakeLists.txt
@@ -23,8 +23,10 @@ if(WITH_TESTS)
     add_definitions(-DGTEST_LANG_CXX11=0 ${GMOCK_CFLAGS})
     include_directories(${CMAKE_SOURCE_DIR}/unittest/include 
                 ${CMAKE_SOURCE_DIR}/mysqlxtest
+                ${CMAKE_SOURCE_DIR}/mysqlxtest/common
                 ${GTEST_INCLUDE_DIR} 
                 ${CMAKE_SOURCE_DIR}/include
+                ${CMAKE_SOURCE_DIR}/modules
                 ${MYSQL_INCLUDE_DIRS}
     )
 
diff --git a/unittest/data/js/js_err.js b/unittest/data/js/js_err.js
index 5b281e0867ddea21a2d9e4dc4201977c85ddd4e1..1b8ccbbfc5d20d3ba88f85d3b2bb043254833200 100644
--- a/unittest/data/js/js_err.js
+++ b/unittest/data/js/js_err.js
@@ -1,3 +1,3 @@
-session.sql('select "first_result" as myresult');
-session.sql('select * from unexisting.whatever');
-session.sql('select "second_result" as secondtry');
\ No newline at end of file
+session.executeSql('select "first_result" as myresult');
+session.executeSql('select * from unexisting.whatever');
+session.executeSql('select "second_result" as secondtry');
\ No newline at end of file
diff --git a/unittest/data/js/js_ok.js b/unittest/data/js/js_ok.js
index f19a9ed10a1644bc36b9b8e0577891bc4f040ebe..997a9a60c2d805d3facac1c37a028eb3f38bfbdb 100644
--- a/unittest/data/js/js_ok.js
+++ b/unittest/data/js/js_ok.js
@@ -1,2 +1,2 @@
-session.sql('select "first_result" as myresult');
+session.executeSql('select "first_result" as myresult');
 
diff --git a/unittest/expr_parser_t.cc b/unittest/expr_parser_t.cc
index dc72546108c8ce8e0c33c035b568cd2dc3364c01..dd3ed09afc7c560ea1f69a1cb8bff26579ec1284 100644
--- a/unittest/expr_parser_t.cc
+++ b/unittest/expr_parser_t.cc
@@ -1,4 +1,3 @@
-
 /* Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
 
  This program is free software; you can redistribute it and/or modify
@@ -13,6 +12,7 @@
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA */
+#include "expr_parser.h"
 
 #include <cstdio>
 #include <cstdlib>
@@ -37,7 +37,6 @@ namespace shcore
 {
   namespace expr_parser_tests
   {
-
     void print_tokens(const Expr_parser& p, std::stringstream& out)
     {
       bool first = true;
@@ -71,95 +70,95 @@ namespace shcore
         "[19, 6, 7, 37, 16, 37, 21, 48]", "(now() - INTERVAL -2 day)");
       parse_and_assert_expr("1",
         "[21]", "1");
-      parse_and_assert_expr("10+1", 
+      parse_and_assert_expr("10+1",
         "[21, 36, 21]", "(10 + 1)");
-      parse_and_assert_expr("(abc = 1)", 
+      parse_and_assert_expr("(abc = 1)",
         "[6, 19, 25, 21, 7]", "(abc == 1)");
-      parse_and_assert_expr("(func(abc)=1)", 
+      parse_and_assert_expr("(func(abc)=1)",
         "[6, 19, 6, 19, 7, 25, 21, 7]", "(func(abc) == 1)");
-      parse_and_assert_expr("(abc = \"jess\")", 
+      parse_and_assert_expr("(abc = \"jess\")",
         "[6, 19, 25, 20, 7]", "(abc == \"jess\")");
-      parse_and_assert_expr("(abc = \"with \\\"\")", 
+      parse_and_assert_expr("(abc = \"with \\\"\")",
         "[6, 19, 25, 20, 7]", "(abc == \"with \"\"\")");
-      parse_and_assert_expr("(abc != .10)", 
+      parse_and_assert_expr("(abc != .10)",
         "[6, 19, 26, 21, 7]", "(abc != 0.100000)");
-      parse_and_assert_expr("(abc != \"xyz\")", 
+      parse_and_assert_expr("(abc != \"xyz\")",
         "[6, 19, 26, 20, 7]", "(abc != \"xyz\")");
-      parse_and_assert_expr("a + b * c + d", 
+      parse_and_assert_expr("a + b * c + d",
         "[19, 36, 19, 38, 19, 36, 19]", "((a + (b * c)) + d)");
-      parse_and_assert_expr("(a + b) * c + d", 
+      parse_and_assert_expr("(a + b) * c + d",
         "[6, 19, 36, 19, 7, 38, 19, 36, 19]", "(((a + b) * c) + d)");
-      parse_and_assert_expr("(field not in ('a',func('b', 2.0),'c'))", 
+      parse_and_assert_expr("(field not in ('a',func('b', 2.0),'c'))",
         "[6, 19, 1, 14, 6, 20, 24, 19, 6, 20, 24, 21, 7, 24, 20, 7, 7]", "NOT ( field IN (\"a\", func(\"b\", 2.000000), \"c\"))");
-      parse_and_assert_expr("jess.age between 30 and death", 
+      parse_and_assert_expr("jess.age between 30 and death",
         "[19, 22, 19, 10, 21, 2, 19]", "jess.age BETWEEN 30 AND death");
-      parse_and_assert_expr("a + b * c + d", 
+      parse_and_assert_expr("a + b * c + d",
         "[19, 36, 19, 38, 19, 36, 19]", "((a + (b * c)) + d)");
-      parse_and_assert_expr("x > 10 and Y >= -20", 
+      parse_and_assert_expr("x > 10 and Y >= -20",
         "[19, 27, 21, 2, 19, 28, 37, 21]", "((x > 10) && (Y >= -20))");
-      parse_and_assert_expr("a is true and b is null and C + 1 > 40 and (time = now() or hungry())", 
+      parse_and_assert_expr("a is true and b is null and C + 1 > 40 and (time = now() or hungry())",
         "[19, 5, 11, 2, 19, 5, 12, 2, 19, 36, 21, 27, 21, 2, 6, 19, 25, 19, 6, 7, 3, 19, 6, 7, 7]", "((((a is TRUE) && (b is NULL)) && ((C + 1) > 40)) && ((time == now()) || hungry()))");
-      parse_and_assert_expr("a + b + -c > 2", 
+      parse_and_assert_expr("a + b + -c > 2",
         "[19, 36, 19, 36, 37, 19, 27, 21]", "(((a + b) + -c) > 2)");
-      parse_and_assert_expr("now () + b + c > 2", 
+      parse_and_assert_expr("now () + b + c > 2",
         "[19, 6, 7, 36, 19, 36, 19, 27, 21]", "(((now() + b) + c) > 2)");
-      parse_and_assert_expr("now () + @b + c > 2", 
+      parse_and_assert_expr("now () + @b + c > 2",
         "[19, 6, 7, 36, 23, 19, 36, 19, 27, 21]", "(((now() + @b) + c) > 2)");
-      parse_and_assert_expr("now () - interval +2 day > some_other_time() or something_else IS NOT NULL", 
+      parse_and_assert_expr("now () - interval +2 day > some_other_time() or something_else IS NOT NULL",
         "[19, 6, 7, 37, 16, 36, 21, 48, 27, 19, 6, 7, 3, 19, 5, 1, 12]", "(((now() - INTERVAL 2 day) > some_other_time()) || NOT ( (something_else IS NULL)))");
-      parse_and_assert_expr("\"two quotes to one\"\"\"", 
+      parse_and_assert_expr("\"two quotes to one\"\"\"",
         "[20]", "\"two quotes to one\"\"\"");
-      parse_and_assert_expr("'two quotes to one'''", 
+      parse_and_assert_expr("'two quotes to one'''",
         "[20]", "\"two quotes to one'\"");
-      parse_and_assert_expr("'different quote \"'", 
+      parse_and_assert_expr("'different quote \"'",
         "[20]", "\"different quote \"\"\"");
-      parse_and_assert_expr("\"different quote '\"", 
+      parse_and_assert_expr("\"different quote '\"",
         "[20]", "\"different quote '\"");
-      parse_and_assert_expr("`ident`", 
+      parse_and_assert_expr("`ident`",
         "[19]", "ident");
-      parse_and_assert_expr("`ident```", 
+      parse_and_assert_expr("`ident```",
         "[19]", "`ident```");
-      parse_and_assert_expr("`ident\"'`", 
+      parse_and_assert_expr("`ident\"'`",
         "[19]", "`ident\"'`");
-      parse_and_assert_expr("? > x and func(?, ?, ?)", 
+      parse_and_assert_expr("? > x and func(?, ?, ?)",
         "[53, 27, 19, 2, 19, 6, 53, 24, 53, 24, 53, 7]", "((\"?\" > x) && func(\"?\", \"?\", \"?\"))");
-      parse_and_assert_expr("a > now() + interval (2 + x) MiNuTe", 
+      parse_and_assert_expr("a > now() + interval (2 + x) MiNuTe",
         "[19, 27, 19, 6, 7, 36, 16, 6, 21, 36, 19, 7, 46]", "(a > (now() + INTERVAL (2 + x) MiNuTe))");
-      parse_and_assert_expr("a between 1 and 2", 
+      parse_and_assert_expr("a between 1 and 2",
         "[19, 10, 21, 2, 21]", "a BETWEEN 1 AND 2");
-      parse_and_assert_expr("a not between 1 and 2", 
+      parse_and_assert_expr("a not between 1 and 2",
         "[19, 1, 10, 21, 2, 21]", "NOT ( a BETWEEN 1 AND 2)");
-      parse_and_assert_expr("a in (1,2,a.b(3),4,5,x)", 
+      parse_and_assert_expr("a in (1,2,a.b(3),4,5,x)",
         "[19, 14, 6, 21, 24, 21, 24, 19, 22, 19, 6, 21, 7, 24, 21, 24, 21, 24, 19, 7]", "a IN (1, 2, b(3), 4, 5, x)");
-      parse_and_assert_expr("a not in (1,2,3,4,5,@x)", 
+      parse_and_assert_expr("a not in (1,2,3,4,5,@x)",
         "[19, 1, 14, 6, 21, 24, 21, 24, 21, 24, 21, 24, 21, 24, 23, 19, 7]", "NOT ( a IN (1, 2, 3, 4, 5, @x))");
-      parse_and_assert_expr("a like b escape c", 
+      parse_and_assert_expr("a like b escape c",
         "[19, 15, 19, 18, 19]", "a LIKE b ESCAPE c");
-      parse_and_assert_expr("a not like b escape c", 
+      parse_and_assert_expr("a not like b escape c",
         "[19, 1, 15, 19, 18, 19]", "NOT ( a LIKE b ESCAPE c)");
-      parse_and_assert_expr("(1 + 3) in (3, 4, 5)", 
+      parse_and_assert_expr("(1 + 3) in (3, 4, 5)",
         "[6, 21, 36, 21, 7, 14, 6, 21, 24, 21, 24, 21, 7]", "(1 + 3) IN (3, 4, 5)");
-      parse_and_assert_expr("`a crazy \"function\"``'name'`(1 + 3) in (3, 4, 5)", 
+      parse_and_assert_expr("`a crazy \"function\"``'name'`(1 + 3) in (3, 4, 5)",
         "[19, 6, 21, 36, 21, 7, 14, 6, 21, 24, 21, 24, 21, 7]", "`a crazy \"function\"``'name'`((1 + 3)) IN (3, 4, 5)");
-      parse_and_assert_expr("`a crazy \"function\"``'name'`(1 + 3) in (3, 4, 5)", 
+      parse_and_assert_expr("`a crazy \"function\"``'name'`(1 + 3) in (3, 4, 5)",
         "[19, 6, 21, 36, 21, 7, 14, 6, 21, 24, 21, 24, 21, 7]", "`a crazy \"function\"``'name'`((1 + 3)) IN (3, 4, 5)");
-      parse_and_assert_expr("a@.b", 
+      parse_and_assert_expr("a@.b",
         "[19, 23, 22, 19]", "a@.b");
-      parse_and_assert_expr("a@.b[0][0].c**.d.\"a weird\\\"key name\"", 
+      parse_and_assert_expr("a@.b[0][0].c**.d.\"a weird\\\"key name\"",
         "[19, 23, 22, 19, 8, 21, 9, 8, 21, 9, 22, 19, 54, 22, 19, 22, 20]", "a@.b[0][0].c**.d.a weird\"key name");
-      parse_and_assert_expr("a@.*", 
+      parse_and_assert_expr("a@.*",
         "[19, 23, 22, 38]", "a@.*");
-      parse_and_assert_expr("a@[0].*", 
+      parse_and_assert_expr("a@[0].*",
         "[19, 23, 8, 21, 9, 22, 38]", "a@[0].*");
-      parse_and_assert_expr("a@**[0].*", 
+      parse_and_assert_expr("a@**[0].*",
         "[19, 23, 54, 8, 21, 9, 22, 38]", "a@**[0].*");
-      parse_and_assert_expr("a + 314.1592e-2", 
+      parse_and_assert_expr("a + 314.1592e-2",
         "[19, 36, 21]", "(a + 3.141592)");
-      parse_and_assert_expr("a + 0.0271e+2", 
+      parse_and_assert_expr("a + 0.0271e+2",
         "[19, 36, 21]", "(a + 2.710000)");
-      parse_and_assert_expr("a + 0.0271e2", 
+      parse_and_assert_expr("a + 0.0271e2",
         "[19, 36, 21]", "(a + 2.710000)");
       EXPECT_ANY_THROW(parse_and_assert_expr("`ident\\``", "", ""));
     }
   };
-};
+};
\ No newline at end of file
diff --git a/unittest/mod_mysql_t.cc b/unittest/mod_mysql_t.cc
deleted file mode 100644
index bb53809faad6c2e4919aaf02217beec131cc8d19..0000000000000000000000000000000000000000
--- a/unittest/mod_mysql_t.cc
+++ /dev/null
@@ -1,524 +0,0 @@
-/* Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
-
- This program is free software; you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by
- the Free Software Foundation; version 2 of the License.
-
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License
- along with this program; if not, write to the Free Software
- Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA */
-
-#include <cstdio>
-#include <cstdlib>
-#include <fstream>
-#include <string>
-#include <boost/shared_ptr.hpp>
-#include <boost/lexical_cast.hpp>
-
-#include <gtest/gtest.h>
-#include "shellcore/types.h"
-#include "shellcore/types_cpp.h"
-
-#include "../modules/mod_mysql.h"
-
-namespace shcore
-{
-  namespace tests
-  {
-    class Mysql_test : public ::testing::Test
-    {
-    public:
-      const char *uri;
-      const char *pwd;
-      const char *port;
-      std::string x_uri;
-      boost::shared_ptr<mysh::Mysql_connection> db;
-
-    protected:
-      virtual void SetUp()
-      {
-        uri = getenv("MYSQL_URI");
-        pwd = getenv("MYSQL_PWD");
-        port = getenv("MYSQL_PORT");
-
-        if (uri)
-        {
-          x_uri.assign(uri);
-          x_uri = "mysql://" + x_uri;
-        }
-        else
-          x_uri = "mysql://root@localhost";
-
-        if (port)
-        {
-          x_uri.append(":");
-          x_uri.append(port);
-        }
-        db.reset(new mysh::Mysql_connection(x_uri, pwd ? pwd : NULL));
-      }
-    };
-
-    //-------------------------- Connection Tests --------------------------
-    TEST_F(Mysql_test, connect_errors)
-    {
-      Argument_list args;
-      std::string mysql_uri;
-
-      if (uri)
-      {
-        mysql_uri.assign(uri);
-        mysql_uri = "mysql://" + mysql_uri;
-      }
-      else
-        mysql_uri = "mysql://root@localhost";
-
-      mysh::Mysql_connection *conn;
-      std::string temp_uri;
-
-      // Error parsing URI
-      temp_uri = mysql_uri + ":fake_port"; // Fake non numeric port will made URI invalid
-      EXPECT_THROW(conn = new mysh::Mysql_connection(temp_uri, NULL), shcore::Exception);
-
-      // Connection Error (using invalid port)
-      temp_uri = mysql_uri + ":4563"; // Fake invalid port will made connection fail
-      EXPECT_THROW(conn = new mysh::Mysql_connection(temp_uri, NULL), shcore::Exception);
-
-      // Connection Error (using invalid password)
-      EXPECT_THROW(conn = new mysh::Mysql_connection(mysql_uri, "fake_pwd"), shcore::Exception);
-    }
-
-    TEST_F(Mysql_test, sql_no_results_drop_unexisting_schema)
-    {
-      Value result;
-      boost::shared_ptr<Object_bridge> result_ptr;
-      Value data;
-
-      // Cleanup to ensure next tests succeed
-      result = db->sql("drop schema if exists shell_tests", Value());
-
-      // Database does not exist to a warning will be generated
-      result = db->sql("drop schema if exists shell_tests", Value());
-      result_ptr = result.as_object<Object_bridge>();
-      data = result_ptr->get_member("warning_count");
-      EXPECT_EQ(1, data.as_int());
-
-      data = result_ptr->get_member("affected_rows");
-      EXPECT_EQ(0, data.as_int());
-    }
-
-    TEST_F(Mysql_test, sql_no_results_drop_existing_schema)
-    {
-      Value result;
-      boost::shared_ptr<Object_bridge> result_ptr;
-      Value data;
-
-      // Now creates the database
-      result = db->sql("create schema shell_tests", Value());
-      result_ptr = result.as_object<Object_bridge>();
-      data = result_ptr->get_member("warning_count");
-      EXPECT_EQ(0, data.as_int());
-
-      data = result_ptr->get_member("affected_rows");
-      EXPECT_EQ(1, data.as_int());
-
-      // Database does not exist to a warning will be generated
-      result = db->sql("drop schema if exists shell_tests", Value());
-      result_ptr = result.as_object<Object_bridge>();
-      data = result_ptr->get_member("warning_count");
-      EXPECT_EQ(0, data.as_int());
-
-      data = result_ptr->get_member("affected_rows");
-      EXPECT_EQ(0, data.as_int());
-    }
-
-    TEST_F(Mysql_test, sql_invalid_query)
-    {
-      // Creates the test database
-      EXPECT_THROW(db->sql("select * from hopefully.unexisting", Value()), shcore::Exception);
-
-      // Creates the test database
-      EXPECT_THROW(db->sql_one("select * from hopefully.unexisting"), shcore::Exception);
-    }
-
-    TEST_F(Mysql_test, sql_single_result)
-    {
-      Value result;
-      boost::shared_ptr<Object_bridge> result_ptr;
-      Value data;
-
-      // Creates the test database
-      result = db->sql("show databases", Value());
-      result_ptr = result.as_object<Object_bridge>();
-      mysh::Mysql_resultset *real_result = dynamic_cast<mysh::Mysql_resultset *>(result_ptr.get());
-
-      // The unique result should be returned and ready to be read
-      if (!real_result)
-        FAIL();
-
-      // There should NOT be a second result
-      EXPECT_FALSE(db->next_result(real_result));
-    }
-
-    TEST_F(Mysql_test, sql_multiple_results)
-    {
-      Value result;
-      boost::shared_ptr<Object_bridge> result_ptr;
-      Value data;
-
-      std::string sp =
-        "create procedure `shell_tests`.`sp`()\n"
-        "begin\n"
-        "  select 1 as 'whatever';\n"
-        "  show databases;\n"
-        "end\n";
-
-      result = db->sql("create schema shell_tests", Value());
-      result_ptr = result.as_object<Object_bridge>();
-      data = result_ptr->get_member("affected_rows");
-      EXPECT_EQ(1, data.as_int());
-
-      result = db->sql(sp, Value());
-      result_ptr = result.as_object<Object_bridge>();
-      data = result_ptr->get_member("affected_rows");
-      EXPECT_EQ(0, data.as_int());
-
-      result = db->sql("call shell_tests.sp()", Value());
-      result_ptr = result.as_object<Object_bridge>();
-      mysh::Mysql_resultset *real_result = dynamic_cast<mysh::Mysql_resultset *>(result_ptr.get());
-
-      // First result returned by the sp
-      if (!real_result)
-        FAIL();
-
-      // Second result returned by the sp
-      EXPECT_TRUE(db->next_result(real_result));
-
-      // The result of processing the actual sp
-      EXPECT_TRUE(db->next_result(real_result));
-
-      // There should NOT be any additional result
-      EXPECT_FALSE(db->next_result(real_result));
-
-      // We drop the test schema
-      result = db->sql("drop schema shell_tests", Value());
-      data = result_ptr->get_member("affected_rows");
-      EXPECT_EQ(0, data.as_int());
-    }
-
-    TEST_F(Mysql_test, sql_one)
-    {
-      Value result = db->sql_one("select 1 as a");
-      EXPECT_EQ("{\"a\": 1}", result.descr());
-    }
-
-    //-------------------------- Resultset Tests --------------------------
-
-    TEST_F(Mysql_test, sql_metadata_content)
-    {
-      boost::shared_ptr<Object_bridge> result_ptr;
-      mysh::Mysql_resultset *real_result;
-      Value data;
-
-      Value result = db->sql("show databases", shcore::Value());
-      result_ptr = result.as_object<Object_bridge>();
-      real_result = dynamic_cast<mysh::Mysql_resultset *>(result_ptr.get());
-
-      // This query only has 1 column
-      EXPECT_EQ(1, real_result->fetch_metadata());
-
-      data = real_result->call("getColumnMetadata", shcore::Argument_list());
-      boost::shared_ptr<shcore::Value::Array_type> array = data.as_array();
-      EXPECT_EQ(1, array->size());
-      boost::shared_ptr<shcore::Value::Map_type> map = (*array)[0].as_map();
-
-      // Validates the content of a field metadata
-      EXPECT_EQ(11, map->size());
-      EXPECT_EQ(1, map->count("catalog"));
-      EXPECT_EQ(1, map->count("db"));
-      EXPECT_EQ(1, map->count("table"));
-      EXPECT_EQ(1, map->count("org_table"));
-      EXPECT_EQ(1, map->count("name"));
-      EXPECT_EQ(1, map->count("org_name"));
-      EXPECT_EQ(1, map->count("charset"));
-      EXPECT_EQ(1, map->count("length"));
-      EXPECT_EQ(1, map->count("type"));
-      EXPECT_EQ(1, map->count("flags"));
-      EXPECT_EQ(1, map->count("decimal"));
-    }
-
-    TEST_F(Mysql_test, sql_fetch_table_metadata)
-    {
-      boost::shared_ptr<Object_bridge> result_ptr;
-      mysh::Mysql_resultset *real_result;
-      Value data;
-
-      std::string create_table =
-        "CREATE TABLE `shell_tests`.`alpha` ("
-        "`idalpha` int(11) NOT NULL,"
-        "`alphacol` varchar(45) DEFAULT NULL,"
-        "PRIMARY KEY(`idalpha`)"
-        ") ENGINE = InnoDB DEFAULT CHARSET = utf8";
-
-      Value result = db->sql("create schema shell_tests", shcore::Value());
-      result_ptr = result.as_object<Object_bridge>();
-
-      EXPECT_EQ(1, result_ptr->get_member("affected_rows").as_int());
-
-      result = db->sql(create_table, shcore::Value());
-      result_ptr = result.as_object<Object_bridge>();
-
-      EXPECT_EQ(0, result_ptr->get_member("affected_rows").as_int());
-
-      result = db->sql("select * from shell_tests.alpha", shcore::Value());
-      result_ptr = result.as_object<Object_bridge>();
-      data = result_ptr->call("getColumnMetadata", shcore::Argument_list());
-
-      boost::shared_ptr<shcore::Value::Array_type> array = data.as_array();
-      EXPECT_EQ(2, array->size());
-      boost::shared_ptr<shcore::Value::Map_type> map = (*array)[0].as_map();
-
-      EXPECT_EQ("def", (*map)["catalog"].as_string());
-      EXPECT_EQ("shell_tests", (*map)["db"].as_string());
-      EXPECT_EQ("alpha", (*map)["table"].as_string());
-      EXPECT_EQ("alpha", (*map)["org_table"].as_string());
-      EXPECT_EQ("idalpha", (*map)["name"].as_string());
-      EXPECT_EQ("idalpha", (*map)["org_name"].as_string());
-      EXPECT_EQ(11, (*map)["length"].as_int());
-
-      // TODO: At the moment these values support is not well defined
-      //EXPECT_EQ("", (*map)["charset"]);
-      //EXPECT_EQ("", (*map)["type"]);
-      //EXPECT_EQ("", (*map)["flags"]);
-      //EXPECT_EQ("", (*map)["decimal"]);
-
-      map = (*array)[1].as_map();
-      EXPECT_EQ("def", (*map)["catalog"].as_string());
-      EXPECT_EQ("shell_tests", (*map)["db"].as_string());
-      EXPECT_EQ("alpha", (*map)["table"].as_string());
-      EXPECT_EQ("alpha", (*map)["org_table"].as_string());
-      EXPECT_EQ("alphacol", (*map)["name"].as_string());
-      EXPECT_EQ("alphacol", (*map)["org_name"].as_string());
-      EXPECT_EQ(45, (*map)["length"].as_int());
-    }
-
-    TEST_F(Mysql_test, sql_fetch_one)
-    {
-      boost::shared_ptr<Object_bridge> result_ptr;
-      mysh::Mysql_resultset *real_result;
-      Value data;
-
-      Value result = db->sql("INSERT INTO `shell_tests`.`alpha` VALUES(1, 'first'), (2, 'second'), (3, 'third')", shcore::Value());
-      result_ptr = result.as_object<Object_bridge>();
-
-      EXPECT_EQ(3, result_ptr->get_member("affected_rows").as_int());
-
-      result = db->sql("select * from shell_tests.alpha", shcore::Value());
-      result_ptr = result.as_object<Object_bridge>();
-
-      // Fetches the first record with no arguments
-      // A document is expected
-      shcore::Argument_list args;
-      data = result_ptr->call("next", args);
-      EXPECT_EQ("{\"alphacol\": \"first\", \"idalpha\": 1}", data.descr());
-      EXPECT_EQ(1, result_ptr->get_member("fetched_row_count").as_int());
-
-      // Fetches the second record with the RAW argument set to false
-      // Same format as default is expected
-      args.push_back(shcore::Value(false));
-      data = result_ptr->call("next", args);
-      EXPECT_EQ("{\"alphacol\": \"second\", \"idalpha\": 2}", data.descr());
-      EXPECT_EQ(2, result_ptr->get_member("fetched_row_count").as_int());
-
-      // Fetches the third record as RAW
-      // No document is expected, value array instead
-      args.clear();
-      args.push_back(shcore::Value(true));
-      data = result_ptr->call("next", args);
-      EXPECT_EQ("[3,\"third\"]", data.descr());
-      EXPECT_EQ(3, result_ptr->get_member("fetched_row_count").as_int());
-
-      // Next attempt to fetch anything should return null
-      data = result_ptr->call("next", args);
-      EXPECT_EQ("null", data.descr());
-
-      EXPECT_EQ(3, result_ptr->get_member("fetched_row_count").as_int());
-    }
-
-    TEST_F(Mysql_test, sql_fetch_all)
-    {
-      boost::shared_ptr<Object_bridge> result_ptr;
-      mysh::Mysql_resultset *real_result;
-      Value data;
-
-      Value result = db->sql("select * from shell_tests.alpha", shcore::Value());
-      result_ptr = result.as_object<Object_bridge>();
-
-      // Fetches all the records with no arguments
-      // A list of documents is expected
-      shcore::Argument_list args;
-      data = result_ptr->call("all", args);
-      std::string expected =
-        "["
-        "{\"alphacol\": \"first\", \"idalpha\": 1},"
-        "{\"alphacol\": \"second\", \"idalpha\": 2},"
-        "{\"alphacol\": \"third\", \"idalpha\": 3}"
-        "]";
-
-      EXPECT_EQ(expected, data.descr());
-      EXPECT_EQ(3, result_ptr->get_member("fetched_row_count").as_int());
-
-      result = db->sql("select * from shell_tests.alpha", shcore::Value());
-      result_ptr = result.as_object<Object_bridge>();
-
-      // Fetches the records with the RAW argument set to false
-      // Same format as default is expected
-      args.push_back(shcore::Value(false));
-      data = result_ptr->call("all", args);
-      EXPECT_EQ(expected, data.descr());
-      EXPECT_EQ(3, result_ptr->get_member("fetched_row_count").as_int());
-
-      result = db->sql("select * from shell_tests.alpha", shcore::Value());
-      result_ptr = result.as_object<Object_bridge>();
-
-      // Fetches the records with the RAW argument set to true
-      // A list of lists is expected
-      args.clear();
-      args.push_back(shcore::Value(true));
-      data = result_ptr->call("all", args);
-
-      expected =
-        "["
-        "[1,\"first\"],"
-        "[2,\"second\"],"
-        "[3,\"third\"]"
-        "]";
-      EXPECT_EQ(expected, data.descr());
-      EXPECT_EQ(3, result_ptr->get_member("fetched_row_count").as_int());
-    }
-
-    TEST_F(Mysql_test, sql_single_result_next)
-    {
-      Value result;
-      boost::shared_ptr<Object_bridge> result_ptr;
-      Value data;
-
-      // Creates the test database
-      result = db->sql("show databases", Value());
-      result_ptr = result.as_object<Object_bridge>();
-      mysh::Mysql_resultset *real_result = dynamic_cast<mysh::Mysql_resultset *>(result_ptr.get());
-
-      // The unique result should be returned and ready to be read
-      if (!real_result)
-        FAIL();
-
-      // There should NOT be a second result
-      EXPECT_FALSE(result_ptr->call("nextResult", shcore::Argument_list()).as_bool());
-    }
-
-    TEST_F(Mysql_test, sql_multiple_results_next)
-    {
-      Value result;
-      boost::shared_ptr<Object_bridge> result_ptr;
-      Value data;
-
-      std::string sp =
-        "create procedure `shell_tests`.`sp`()\n"
-        "begin\n"
-        "  select 1 as 'whatever';\n"
-        "  show databases;\n"
-        "end\n";
-
-      result = db->sql(sp, Value());
-      result_ptr = result.as_object<Object_bridge>();
-      data = result_ptr->get_member("affected_rows");
-      EXPECT_EQ(0, data.as_int());
-
-      result = db->sql("call shell_tests.sp()", Value());
-      result_ptr = result.as_object<Object_bridge>();
-      mysh::Mysql_resultset *real_result = dynamic_cast<mysh::Mysql_resultset *>(result_ptr.get());
-
-      // First result returned by the sp
-      if (!real_result)
-        FAIL();
-
-      // Second result returned by the sp
-      EXPECT_TRUE(result_ptr->call("nextResult", shcore::Argument_list()).as_bool());
-
-      // The result of processing the actual sp
-      EXPECT_TRUE(result_ptr->call("nextResult", shcore::Argument_list()).as_bool());
-
-      // There should NOT be any additional result
-      EXPECT_FALSE(result_ptr->call("nextResult", shcore::Argument_list()).as_bool());
-
-      // We drop the test schema
-      result = db->sql("drop schema shell_tests", Value());
-      data = result_ptr->get_member("affected_rows");
-      EXPECT_EQ(0, data.as_int());
-    }
-
-    /* not implemented yet
-    TEST(MySQL, query_with_binds_int)
-    {
-    {
-    Argument_list args;
-    args.push_back(Value("select ? as a, ? as b"));
-    Value params(Value::new_array());
-    params.as_array()->push_back(Value(42));
-    params.as_array()->push_back(Value(43));
-    args.push_back(params);
-
-    Value result = env.db->sql(args);
-    Value row = result.as_object<Object_bridge>()->call("next", Argument_list());
-    EXPECT_EQ("{\"a\": 42, \"b\": 43}", row.descr());
-    }
-
-    {
-    Argument_list args;
-    args.push_back(Value("select :first as a, :second as b"));
-    Value params(Value::new_map());
-    (*params.as_map())["first"] = Value(42);
-    (*params.as_map())["second"] = Value(43);
-    args.push_back(params);
-
-    Value result = env.db->sql(args);
-    Value row = result.as_object<Object_bridge>()->call("next", Argument_list());
-    EXPECT_EQ("{\"a\": 42, \"b\": 43}", row.descr());
-    }
-    }
-
-    TEST(MySQL, query_with_binds_date)
-    {
-    {
-    Argument_list args;
-    args.push_back(Value("select ? as a, ? as b"));
-    Value params(Value::new_array());
-    params.as_array()->push_back(Value(42));
-    params.as_array()->push_back(Value(43));
-    args.push_back(params);
-
-    Value result = env.db->sql(args);
-    Value row = result.as_object<Object_bridge>()->call("next", Argument_list());
-    EXPECT_EQ("{\"a\": 42, \"b\": 43}", row.descr());
-    }
-
-    {
-    Argument_list args;
-    args.push_back(Value("select :first as 1, :second as b"));
-    Value params(Value::new_map());
-    (*params.as_map())["first"] = Value(42);
-    (*params.as_map())["second"] = Value(43);
-    args.push_back(params);
-
-    Value result = env.db->sql(args);
-    Value row = result.as_object<Object_bridge>()->call("next", Argument_list());
-    EXPECT_EQ("{\"a\": 42, \"b\": 43}", row.descr());
-    }
-    }
-    */
-  }
-}
\ No newline at end of file
diff --git a/unittest/mod_mysqlx_t.cc b/unittest/mod_mysqlx_t.cc
deleted file mode 100644
index 9697a91eec7a3cacb8f0a384714d401a9bc59fcb..0000000000000000000000000000000000000000
--- a/unittest/mod_mysqlx_t.cc
+++ /dev/null
@@ -1,517 +0,0 @@
-/* Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
-
- This program is free software; you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by
- the Free Software Foundation; version 2 of the License.
-
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License
- along with this program; if not, write to the Free Software
- Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA */
-
-#include <cstdio>
-#include <cstdlib>
-#include <fstream>
-#include <string>
-#include <boost/shared_ptr.hpp>
-#include <boost/lexical_cast.hpp>
-
-#include <gtest/gtest.h>
-#include "shellcore/types.h"
-#include "shellcore/types_cpp.h"
-
-#include "../modules/mod_mysqlx.h"
-#include "../modules/mod_result.h"
-
-namespace shcore
-{
-  namespace tests
-  {
-    class Mysqlx_test : public ::testing::Test
-    {
-    public:
-      const char *uri;
-      const char *pwd;
-      std::string x_uri;
-      boost::shared_ptr<mysh::X_connection> db;
-
-    protected:
-      virtual void SetUp()
-      {
-        uri = getenv("MYSQL_URI");
-        pwd = getenv("MYSQL_PWD");
-
-        if (uri)
-        {
-          x_uri.assign(uri);
-          x_uri = "mysqlx://" + x_uri;
-        }
-        else
-          x_uri = "mysqlx://root@localhost";
-
-        db.reset(new mysh::X_connection(uri, pwd ? pwd : NULL));
-      }
-    };
-
-    //-------------------------- Connection Tests --------------------------
-
-    TEST_F(Mysqlx_test, connect_errors)
-    {
-      Argument_list args;
-      std::string x_uri;
-
-      if (uri)
-      {
-        x_uri.assign(uri);
-        x_uri = "mysqlx://" + x_uri;
-      }
-      else
-        x_uri = "mysqlx://root@localhost";
-
-      mysh::X_connection *conn;
-      std::string temp_uri;
-
-      // Error parsing URI
-      temp_uri = x_uri + ":fake_port"; // Fake non numeric port will made URI invalid
-      EXPECT_THROW(conn = new mysh::X_connection(temp_uri, NULL), shcore::Exception);
-
-      // Connection Error (using invalid port)
-      temp_uri = x_uri + ":4563"; // Fake invalid port will made connection fail
-      EXPECT_THROW(conn = new mysh::X_connection(temp_uri, NULL), shcore::Exception);
-
-      // Connection Error (using invalid password)
-      EXPECT_THROW(conn = new mysh::X_connection(x_uri, "fake_pwd"), shcore::Exception);
-    }
-
-    TEST_F(Mysqlx_test, sql_no_results_drop_unexisting_schema)
-    {
-      Value result;
-      boost::shared_ptr<Object_bridge> result_ptr;
-      Value data;
-
-      // Cleanup to ensure next tests succeed
-      result = db->sql("drop schema if exists shell_tests", Value());
-
-      // Database does not exist to a warning will be generated
-      result = db->sql("drop schema if exists shell_tests", Value());
-      result_ptr = result.as_object<Object_bridge>();
-
-      // TODO: Warning count is not available on the X Protocol yet
-      //data = result_ptr->get_member("warning_count");
-      //EXPECT_EQ(1, data.as_int());
-
-      data = result_ptr->get_member("affected_rows");
-      EXPECT_EQ(0, data.as_int());
-    }
-
-    TEST_F(Mysqlx_test, sql_no_results_drop_existing_schema)
-    {
-      Value result;
-      boost::shared_ptr<Object_bridge> result_ptr;
-      Value data;
-
-      // Now creates the database
-      result = db->sql("create schema shell_tests", Value());
-      result_ptr = result.as_object<Object_bridge>();
-      data = result_ptr->get_member("warning_count");
-      EXPECT_EQ(0, data.as_int());
-
-      data = result_ptr->get_member("affected_rows");
-      EXPECT_EQ(1, data.as_int());
-
-      // Database does not exist to a warning will be generated
-      result = db->sql("drop schema if exists shell_tests", Value());
-      result_ptr = result.as_object<Object_bridge>();
-      data = result_ptr->get_member("warning_count");
-      EXPECT_EQ(0, data.as_int());
-
-      data = result_ptr->get_member("affected_rows");
-      EXPECT_EQ(0, data.as_int());
-    }
-
-    TEST_F(Mysqlx_test, sql_single_result)
-    {
-      Value result;
-      boost::shared_ptr<Object_bridge> result_ptr;
-      Value data;
-
-      // Creates the test database
-      result = db->sql("show databases", Value());
-      result_ptr = result.as_object<Object_bridge>();
-      mysh::X_resultset *real_result = dynamic_cast<mysh::X_resultset *>(result_ptr.get());
-
-      // The unique result should be returned and ready to be read
-      if (!real_result)
-        FAIL();
-
-      // There should NOT be a second result
-      EXPECT_FALSE(db->next_result(real_result));
-    }
-
-    TEST_F(Mysqlx_test, DISABLED_sql_multiple_results)
-    {
-      Value result;
-      boost::shared_ptr<Object_bridge> result_ptr;
-      Value data;
-
-      std::string sp =
-        "create procedure `shell_tests`.`sp`()\n"
-        "begin\n"
-        "  select 1 as 'whatever';\n"
-        "  show databases;\n"
-        "end\n";
-
-      result = db->sql("create schema shell_tests", Value());
-      result_ptr = result.as_object<Object_bridge>();
-      data = result_ptr->get_member("affected_rows");
-      EXPECT_EQ(1, data.as_int());
-
-      result = db->sql(sp, Value());
-      result_ptr = result.as_object<Object_bridge>();
-      data = result_ptr->get_member("affected_rows");
-      EXPECT_EQ(0, data.as_int());
-
-      result = db->sql("call shell_tests.sp()", Value());
-      result_ptr = result.as_object<Object_bridge>();
-      mysh::X_resultset *real_result = dynamic_cast<mysh::X_resultset *>(result_ptr.get());
-
-      // First result returned by the sp
-      if (!real_result)
-        FAIL();
-
-      // Second result returned by the sp
-      EXPECT_TRUE(db->next_result(real_result));
-
-      // The result of processing the actual sp
-      EXPECT_TRUE(db->next_result(real_result));
-
-      // There should NOT be any additional result
-      EXPECT_FALSE(db->next_result(real_result));
-
-      // We drop the test schema
-      result = db->sql("drop schema shell_tests", Value());
-      data = result_ptr->get_member("affected_rows");
-      EXPECT_EQ(0, data.as_int());
-    }
-
-    TEST_F(Mysqlx_test, sql_invalid_query)
-    {
-      // Creates the test database
-      EXPECT_THROW(db->sql("select * from hopefully.unexisting", Value()), shcore::Exception);
-
-      // Creates the test database
-      EXPECT_THROW(db->sql_one("select * from hopefully.unexisting"), shcore::Exception);
-    }
-
-    TEST_F(Mysqlx_test, sql_one)
-    {
-      Value result = db->sql_one("select 1 as sample");
-      EXPECT_EQ("{\"sample\": 1}", result.descr());
-    }
-
-    //-------------------------- Resultset Tests --------------------------
-
-    TEST_F(Mysqlx_test, sql_metadata_content)
-    {
-      boost::shared_ptr<Object_bridge> result_ptr;
-      mysh::X_resultset *real_result;
-      Value data;
-
-      Value result = db->sql("show databases", shcore::Value());
-      result_ptr = result.as_object<Object_bridge>();
-      real_result = dynamic_cast<mysh::X_resultset *>(result_ptr.get());
-
-      data = real_result->call("getColumnMetadata", shcore::Argument_list());
-      boost::shared_ptr<shcore::Value::Array_type> array = data.as_array();
-      EXPECT_EQ(1, array->size());
-      boost::shared_ptr<shcore::Value::Map_type> map = (*array)[0].as_map();
-
-      // Validates the content of a field metadata
-      EXPECT_EQ(11, map->size());
-      EXPECT_EQ(1, map->count("catalog"));
-      EXPECT_EQ(1, map->count("db"));
-      EXPECT_EQ(1, map->count("table"));
-      EXPECT_EQ(1, map->count("org_table"));
-      EXPECT_EQ(1, map->count("name"));
-      EXPECT_EQ(1, map->count("org_name"));
-      EXPECT_EQ(1, map->count("charset"));
-      EXPECT_EQ(1, map->count("length"));
-      EXPECT_EQ(1, map->count("type"));
-      EXPECT_EQ(1, map->count("flags"));
-      EXPECT_EQ(1, map->count("decimal"));
-    }
-
-    TEST_F(Mysqlx_test, sql_fetch_table_metadata)
-    {
-      boost::shared_ptr<Object_bridge> result_ptr;
-      mysh::X_resultset *real_result;
-      Value data;
-
-      std::string create_table =
-        "CREATE TABLE `shell_tests`.`alpha` ("
-        "`idalpha` int(11) NOT NULL,"
-        "`alphacol` varchar(45) DEFAULT NULL,"
-        "PRIMARY KEY(`idalpha`)"
-        ") ENGINE = InnoDB DEFAULT CHARSET = utf8";
-
-      Value result = db->sql("create schema shell_tests", shcore::Value());
-      result_ptr = result.as_object<Object_bridge>();
-
-      EXPECT_EQ(1, result_ptr->get_member("affected_rows").as_int());
-
-      result = db->sql(create_table, shcore::Value());
-      result_ptr = result.as_object<Object_bridge>();
-
-      EXPECT_EQ(0, result_ptr->get_member("affected_rows").as_int());
-
-      result = db->sql("select * from shell_tests.alpha", shcore::Value());
-      result_ptr = result.as_object<Object_bridge>();
-      data = result_ptr->call("getColumnMetadata", shcore::Argument_list());
-
-      boost::shared_ptr<shcore::Value::Array_type> array = data.as_array();
-      EXPECT_EQ(2, array->size());
-      boost::shared_ptr<shcore::Value::Map_type> map = (*array)[0].as_map();
-
-      EXPECT_EQ("def", (*map)["catalog"].as_string());
-      EXPECT_EQ("shell_tests", (*map)["db"].as_string());
-      EXPECT_EQ("alpha", (*map)["table"].as_string());
-      EXPECT_EQ("alpha", (*map)["org_table"].as_string());
-      EXPECT_EQ("idalpha", (*map)["name"].as_string());
-      EXPECT_EQ("idalpha", (*map)["org_name"].as_string());
-
-      // TODO: At the moment these values support is not well defined
-      // EXPECT_EQ(11, (*map)["length"].as_int());
-      //EXPECT_EQ("", (*map)["charset"]);
-      //EXPECT_EQ("", (*map)["type"]);
-      //EXPECT_EQ("", (*map)["flags"]);
-      //EXPECT_EQ("", (*map)["decimal"]);
-
-      map = (*array)[1].as_map();
-      EXPECT_EQ("def", (*map)["catalog"].as_string());
-      EXPECT_EQ("shell_tests", (*map)["db"].as_string());
-      EXPECT_EQ("alpha", (*map)["table"].as_string());
-      EXPECT_EQ("alpha", (*map)["org_table"].as_string());
-      EXPECT_EQ("alphacol", (*map)["name"].as_string());
-      EXPECT_EQ("alphacol", (*map)["org_name"].as_string());
-    }
-
-    TEST_F(Mysqlx_test, sql_fetch_one)
-    {
-      boost::shared_ptr<Object_bridge> result_ptr;
-      mysh::X_resultset *real_result;
-      Value data;
-
-      Value result = db->sql("INSERT INTO `shell_tests`.`alpha` VALUES(1, 'first'), (2, 'second'), (3, 'third')", shcore::Value());
-      result_ptr = result.as_object<Object_bridge>();
-
-      EXPECT_EQ(3, result_ptr->get_member("affected_rows").as_int());
-
-      result = db->sql("select * from shell_tests.alpha", shcore::Value());
-      result_ptr = result.as_object<Object_bridge>();
-
-      // Fetches the first record with no arguments
-      // A document is expected
-      shcore::Argument_list args;
-      data = result_ptr->call("next", args);
-      EXPECT_EQ("{\"alphacol\": \"first\", \"idalpha\": 1}", data.descr());
-      EXPECT_EQ(1, result_ptr->get_member("fetched_row_count").as_int());
-
-      // Fetches the second record with the RAW argument set to false
-      // Same format as default is expected
-      args.push_back(shcore::Value(false));
-      data = result_ptr->call("next", args);
-      EXPECT_EQ("{\"alphacol\": \"second\", \"idalpha\": 2}", data.descr());
-      EXPECT_EQ(2, result_ptr->get_member("fetched_row_count").as_int());
-
-      // Fetches the third record as RAW
-      // No document is expected, value array instead
-      args.clear();
-      args.push_back(shcore::Value(true));
-      data = result_ptr->call("next", args);
-      EXPECT_EQ("[3,\"third\"]", data.descr());
-      EXPECT_EQ(3, result_ptr->get_member("fetched_row_count").as_int());
-
-      // Next attempt to fetch anything should return null
-      data = result_ptr->call("next", args);
-      EXPECT_EQ("null", data.descr());
-
-      EXPECT_EQ(3, result_ptr->get_member("fetched_row_count").as_int());
-    }
-
-    TEST_F(Mysqlx_test, sql_fetch_all)
-    {
-      boost::shared_ptr<Object_bridge> result_ptr;
-      mysh::X_resultset *real_result;
-      Value data;
-
-      Value result = db->sql("select * from shell_tests.alpha", shcore::Value());
-      result_ptr = result.as_object<Object_bridge>();
-
-      // Fetches all the records with no arguments
-      // A list of documents is expected
-      shcore::Argument_list args;
-      data = result_ptr->call("all", args);
-      std::string expected =
-        "["
-        "{\"alphacol\": \"first\", \"idalpha\": 1},"
-        "{\"alphacol\": \"second\", \"idalpha\": 2},"
-        "{\"alphacol\": \"third\", \"idalpha\": 3}"
-        "]";
-
-      EXPECT_EQ(expected, data.descr());
-      EXPECT_EQ(3, result_ptr->get_member("fetched_row_count").as_int());
-
-      result = db->sql("select * from shell_tests.alpha", shcore::Value());
-      result_ptr = result.as_object<Object_bridge>();
-
-      // Fetches the records with the RAW argument set to false
-      // Same format as default is expected
-      args.push_back(shcore::Value(false));
-      data = result_ptr->call("all", args);
-      EXPECT_EQ(expected, data.descr());
-      EXPECT_EQ(3, result_ptr->get_member("fetched_row_count").as_int());
-
-      result = db->sql("select * from shell_tests.alpha", shcore::Value());
-      result_ptr = result.as_object<Object_bridge>();
-
-      // Fetches the records with the RAW argument set to true
-      // A list of lists is expected
-      args.clear();
-      args.push_back(shcore::Value(true));
-      data = result_ptr->call("all", args);
-
-      expected =
-        "["
-        "[1,\"first\"],"
-        "[2,\"second\"],"
-        "[3,\"third\"]"
-        "]";
-      EXPECT_EQ(expected, data.descr());
-      EXPECT_EQ(3, result_ptr->get_member("fetched_row_count").as_int());
-    }
-
-    TEST_F(Mysqlx_test, sql_single_result_next)
-    {
-      Value result;
-      boost::shared_ptr<Object_bridge> result_ptr;
-      Value data;
-
-      // Creates the test database
-      result = db->sql("show databases", Value());
-      result_ptr = result.as_object<Object_bridge>();
-      mysh::X_resultset *real_result = dynamic_cast<mysh::X_resultset *>(result_ptr.get());
-
-      // The unique result should be returned and ready to be read
-      if (!real_result)
-        FAIL();
-
-      // There should NOT be a second result
-      EXPECT_FALSE(result_ptr->call("nextResult", shcore::Argument_list()).as_bool());
-    }
-
-    TEST_F(Mysqlx_test, DISABLED_sql_multiple_results_next)
-    {
-      Value result;
-      boost::shared_ptr<Object_bridge> result_ptr;
-      Value data;
-
-      std::string sp =
-        "create procedure `shell_tests`.`sp`()\n"
-        "begin\n"
-        "  select 1 as 'whatever';\n"
-        "  show databases;\n"
-        "end\n";
-
-      result = db->sql(sp, Value());
-      result_ptr = result.as_object<Object_bridge>();
-      data = result_ptr->get_member("affected_rows");
-      EXPECT_EQ(0, data.as_int());
-
-      result = db->sql("call shell_tests.sp()", Value());
-      result_ptr = result.as_object<Object_bridge>();
-      mysh::X_resultset *real_result = dynamic_cast<mysh::X_resultset *>(result_ptr.get());
-
-      // First result returned by the sp
-      if (!real_result)
-        FAIL();
-
-      // Second result returned by the sp
-      EXPECT_TRUE(result_ptr->call("nextResult", shcore::Argument_list()).as_bool());
-
-      // The result of processing the actual sp
-      EXPECT_TRUE(result_ptr->call("nextResult", shcore::Argument_list()).as_bool());
-
-      // There should NOT be any additional result
-      EXPECT_FALSE(result_ptr->call("nextResult", shcore::Argument_list()).as_bool());
-
-      // We drop the test schema
-      result = db->sql("drop schema shell_tests", Value());
-      data = result_ptr->get_member("affected_rows");
-      EXPECT_EQ(0, data.as_int());
-    }
-
-    /* not implemented yet
-    TEST_F(MySQL, query_with_binds_int)
-    {
-    {
-    Argument_list args;
-    args.push_back(Value("select ? as a, ? as b"));
-    Value params(Value::new_array());
-    params.as_array()->push_back(Value(42));
-    params.as_array()->push_back(Value(43));
-    args.push_back(params);
-
-    Value result = db->sql(args);
-    Value row = result.as_object<Object_bridge>()->call("next", Argument_list());
-    EXPECT_EQ("{\"a\": 42, \"b\": 43}", row.descr());
-    }
-
-    {
-    Argument_list args;
-    args.push_back(Value("select :first as a, :second as b"));
-    Value params(Value::new_map());
-    (*params.as_map())["first"] = Value(42);
-    (*params.as_map())["second"] = Value(43);
-    args.push_back(params);
-
-    Value result = db->sql(args);
-    Value row = result.as_object<Object_bridge>()->call("next", Argument_list());
-    EXPECT_EQ("{\"a\": 42, \"b\": 43}", row.descr());
-    }
-    }
-
-    TEST_F(MySQL, query_with_binds_date)
-    {
-    {
-    Argument_list args;
-    args.push_back(Value("select ? as a, ? as b"));
-    Value params(Value::new_array());
-    params.as_array()->push_back(Value(42));
-    params.as_array()->push_back(Value(43));
-    args.push_back(params);
-
-    Value result = db->sql(args);
-    Value row = result.as_object<Object_bridge>()->call("next", Argument_list());
-    EXPECT_EQ("{\"a\": 42, \"b\": 43}", row.descr());
-    }
-
-    {
-    Argument_list args;
-    args.push_back(Value("select :first as 1, :second as b"));
-    Value params(Value::new_map());
-    (*params.as_map())["first"] = Value(42);
-    (*params.as_map())["second"] = Value(43);
-    args.push_back(params);
-
-    Value result = db->sql(args);
-    Value row = result.as_object<Object_bridge>()->call("next", Argument_list());
-    EXPECT_EQ("{\"a\": 42, \"b\": 43}", row.descr());
-    }
-    }
-    */
-  }
-}
\ No newline at end of file
diff --git a/unittest/proj_parser_t.cc b/unittest/proj_parser_t.cc
index cfb168532dc8fc2c63365e3191386bb460ea7b90..7c1ded06fb290aba39478e45e9c287655f1e4d99 100644
--- a/unittest/proj_parser_t.cc
+++ b/unittest/proj_parser_t.cc
@@ -13,6 +13,7 @@
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA */
 
+#include "proj_parser.h"
 #include <cstdio>
 #include <cstdlib>
 #include <fstream>
@@ -51,33 +52,27 @@ namespace shcore
       out << "]";
     }
 
-    class DummyColumnContainer
-    {
-    public:
-      DummyColumnContainer(std::vector<Mysqlx::Crud::Column*>& columns) :
-      _columns(columns){}
-
-      Mysqlx::Crud::Column* Add()
-      {
-        Mysqlx::Crud::Column* new_col = new Mysqlx::Crud::Column();
-        _columns.push_back(new_col);
-        return new_col;
-      }
-
-    private:
-      std::vector<Mysqlx::Crud::Column*>& _columns;
-    };
-
     void parse_and_assert_expr(const std::string& input, const std::string& token_list, const std::string& unparsed, bool document_mode = false, bool allow_alias = true)
     {
+      struct Wrap
+      {
+        std::vector<Mysqlx::Crud::Column*> &cols;
+        Wrap(std::vector<Mysqlx::Crud::Column*> &c) : cols(c) {}
+        Mysqlx::Crud::Column *Add()
+        {
+          Mysqlx::Crud::Column *tmp = new Mysqlx::Crud::Column();
+          cols.push_back(tmp);
+          return tmp;
+        };
+      };
       std::stringstream out, out_tokens;
       Proj_parser p(input, document_mode, allow_alias);
       print_tokens(p, out_tokens);
       std::string token_list2 = out_tokens.str();
       ASSERT_TRUE(token_list == token_list2);
       std::vector<Mysqlx::Crud::Column*> cols;
-      DummyColumnContainer container(cols);
-      p.parse(container);
+      Wrap wrapped_cols(cols);
+      p.parse(wrapped_cols);
       std::string s = Expr_unparser::column_list_to_string(cols);
       out << s;
       std::string outstr = out.str();
diff --git a/unittest/shell_command_handler_t.cc b/unittest/shell_command_handler_t.cc
index 3ce99629180d78d62dca84681c993bd82b807af0..e1f3c0c55fc7bae916eb05f737da1d529fc7374d 100644
--- a/unittest/shell_command_handler_t.cc
+++ b/unittest/shell_command_handler_t.cc
@@ -1,4 +1,3 @@
-
 /* Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
 
  This program is free software; you can redistribute it and/or modify
@@ -14,7 +13,6 @@
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA */
 
-
 #include <cstdio>
 #include <cstdlib>
 #include <fstream>
@@ -26,16 +24,10 @@
 #include "shellcore/lang_base.h"
 #include "shellcore/types_cpp.h"
 
-
 #include "shellcore/shell_core.h"
 #include "shellcore/shell_sql.h"
-#include "../modules/mod_session.h"
-#include "../modules/mod_db.h"
-
 
 namespace shcore {
-
-
   namespace command_handler_tests {
     class Environment
     {
@@ -47,10 +39,9 @@ namespace shcore {
       ~Environment()
       {
       }
-
     };
 
-    class Command_handler_tests: public ::testing::Test
+    class Command_handler_tests : public ::testing::Test
     {
     public:
       Command_handler_tests()
@@ -66,7 +57,6 @@ namespace shcore {
       std::vector<std::string> _params;
       Environment env;
 
-
       void cmd_one(const std::vector<std::string>& params)
       {
         _function = "cmd_one";
@@ -133,7 +123,6 @@ namespace shcore {
       EXPECT_EQ("parameters", _params[3]);
     }
 
-
     TEST_F(Command_handler_tests, printing_commands)
     {
       std::stringstream my_stdout;
@@ -221,4 +210,4 @@ namespace shcore {
       std::cout.rdbuf(stdout_backup);
     }
   }
-}
+}
\ No newline at end of file
diff --git a/unittest/shell_core_t.cc b/unittest/shell_core_t.cc
index 9f1726851a2948332e55a0e56d96ebbec744b13d..bfdcf727410e8b0a6792008d22ae4445469b1e37 100644
--- a/unittest/shell_core_t.cc
+++ b/unittest/shell_core_t.cc
@@ -28,8 +28,7 @@
 
 #include "shellcore/shell_core.h"
 #include "shellcore/shell_sql.h"
-#include "../modules/mod_session.h"
-#include "../modules/mod_db.h"
+#include "../modules/base_session.h"
 #include "test_utils.h"
 #include "utils_file.h"
 
@@ -38,7 +37,6 @@ namespace shcore {
     class Shell_core_test : public Shell_core_test_wrapper
     {
     protected:
-      boost::shared_ptr<mysh::Session> _session;
       std::string _file_name;
       int _ret_val;
 
@@ -48,9 +46,6 @@ namespace shcore {
 
         bool initilaized(false);
         _shell_core->switch_mode(Shell_core::Mode_SQL, initilaized);
-
-        _session.reset(new mysh::Session(_shell_core.get()));
-        _shell_core->set_global("session", Value(boost::static_pointer_cast<Object_bridge>(_session)));
       }
 
       void connect()
@@ -68,7 +63,9 @@ namespace shcore {
         if (!_pwd.empty())
           args.push_back(Value(_pwd));
 
-        _session->connect(args);
+        boost::shared_ptr<mysh::BaseSession> session(mysh::connect_session(args));
+
+        _shell_core->set_global("session", Value(boost::static_pointer_cast<Object_bridge>(session)));
       }
 
       void process(const std::string& path, bool continue_on_error)
diff --git a/unittest/shell_js_crud_collection_add_t.cc b/unittest/shell_js_crud_collection_add_t.cc
index 22978447e477bbbb5666bcc2bae5ee74cc2750c3..d0198c9c8dffb23e5749443f3b8e3d15fa6066eb 100644
--- a/unittest/shell_js_crud_collection_add_t.cc
+++ b/unittest/shell_js_crud_collection_add_t.cc
@@ -32,7 +32,7 @@
 #include "../modules/mod_crud_collection_add.h"
 
 namespace shcore {
-  class Shell_js_crud_collection_add_tests : public Crud_test_wrapper
+  class DISABLED_Shell_js_crud_collection_add_tests : public Crud_test_wrapper
   {
   protected:
     // You can define per-test set-up and tear-down logic as usual.
@@ -48,50 +48,39 @@ namespace shcore {
     }
   };
 
-  TEST_F(Shell_js_crud_collection_add_tests, chain_combinations)
+  TEST_F(DISABLED_Shell_js_crud_collection_add_tests, initialization)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
+
+    exec_and_out_equals("session.executeSql('drop schema if exists js_shell_test;')");
+    exec_and_out_equals("session.executeSql('create schema js_shell_test;')");
+    exec_and_out_equals("session.executeSql('use js_shell_test;')");
+    exec_and_out_equals("session.executeSql(\"create table `collection1`(`doc` JSON, `_id` VARBINARY(16) GENERATED ALWAYS AS(unhex(json_unquote(json_extract(doc, '$._id')))) stored PRIMARY KEY)\")");
+  }
+
+  TEST_F(DISABLED_Shell_js_crud_collection_add_tests, chain_combinations)
   {
     // NOTE: No data validation is done on this test, only tests
     //       different combinations of chained methods.
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
 
-    // Creates a connection object
-    exec_and_out_equals("var conn = _F.mysqlx.Connection('" + _uri + "');");
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
 
-    // Creates the collection add object
-    exec_and_out_equals("var crud = _F.mysqlx.CollectionAdd(conn, 'schema', 'collection');");
+    exec_and_out_equals("var collection = session.js_shell_test.getCollection('collection1');");
+
+    // Creates the collection find object
+    exec_and_out_equals("var crud = collection.add([]);");
 
     //-------- ---------------------Test 1------------------------//
     // Initial validation, any new CollectionAdd object only has
     // the add function available upon creation
     //-------------------------------------------------------------
-    ensure_available_functions("add");
-
-    //-------- ---------------------Test 2-------------------------
-    // Tests the happy path validating only the right functions
-    // are available following the chained call
-    // this is ColumnAdd.add([]).bind([]).execute()
-    //-------------------------------------------------------------
-    exec_and_out_equals("crud.add([])");
-    ensure_available_functions("bind execute");
-
-    // Now executes bind and the only available method will be execute
-    exec_and_out_equals("crud.bind([])");
     ensure_available_functions("execute");
-
-    //-------- ---------------------Test 3-------------------------
-    // Tests an alternative where add is called with no parameters
-    // on this case bind is not optional but mandatory so after add
-    // execute should not be available
-    //-------------------------------------------------------------
-
-    // Creates the collection add object
-    exec_and_out_equals("var crud = _F.mysqlx.CollectionAdd(conn, 'schema', 'collection');");
-
-    // Executes insert + bind, values  only execute should be available after
-    exec_and_out_equals("crud.add()");
-    ensure_available_functions("bind");
   }
 
-  TEST_F(Shell_js_crud_collection_add_tests, add_validations)
+  TEST_F(DISABLED_Shell_js_crud_collection_add_tests, add_validations)
   {
     exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
     exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
diff --git a/unittest/shell_js_crud_collection_find_t.cc b/unittest/shell_js_crud_collection_find_t.cc
index 6dac0eba952b84e37ff3ab3acbeb8cc88837e9b7..20a0a0818d47ec8ad56a6d2152b487cbff08a2b9 100644
--- a/unittest/shell_js_crud_collection_find_t.cc
+++ b/unittest/shell_js_crud_collection_find_t.cc
@@ -32,7 +32,7 @@
 #include "../modules/mod_crud_collection_find.h"
 
 namespace shcore {
-  class Shell_js_crud_collection_find_tests : public Crud_test_wrapper
+  class DISABLED_Shell_js_crud_collection_find_tests : public Crud_test_wrapper
   {
   protected:
     // You can define per-test set-up and tear-down logic as usual.
@@ -48,16 +48,30 @@ namespace shcore {
     }
   };
 
-  TEST_F(Shell_js_crud_collection_find_tests, chain_combinations)
+  TEST_F(DISABLED_Shell_js_crud_collection_find_tests, initialization)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
+
+    exec_and_out_equals("session.executeSql('drop schema if exists js_shell_test;')");
+    exec_and_out_equals("session.executeSql('create schema js_shell_test;')");
+    exec_and_out_equals("session.executeSql('use js_shell_test;')");
+    exec_and_out_equals("session.executeSql(\"create table `collection1`(`doc` JSON, `_id` VARBINARY(16) GENERATED ALWAYS AS(unhex(json_unquote(json_extract(doc, '$._id')))) stored PRIMARY KEY)\")");
+  }
+
+  TEST_F(DISABLED_Shell_js_crud_collection_find_tests, chain_combinations)
   {
     // NOTE: No data validation is done on this test, only tests
     //       different combinations of chained methods.
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
 
-    // Creates a connection object
-    exec_and_out_equals("var conn = _F.mysqlx.Connection('" + _uri + "');");
+    exec_and_out_equals("var collection = session.js_shell_test.getCollection('collection1');");
 
-    // Creates the collection add object
-    exec_and_out_equals("var crud = _F.mysqlx.CollectionFind(conn, 'schema', 'collection');");
+    // Creates the collection find object
+    exec_and_out_equals("var crud = collection.find();");
 
     //-------- ---------------------Test 1------------------------//
     // Initial validation, any new CollectionFind object only has
@@ -96,7 +110,7 @@ namespace shcore {
     }
   }
 
-  TEST_F(Shell_js_crud_collection_find_tests, find_validations)
+  TEST_F(DISABLED_Shell_js_crud_collection_find_tests, find_validations)
   {
     exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
     exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
@@ -155,7 +169,7 @@ namespace shcore {
     exec_and_out_contains("collection.find().bind();", "", "CollectionFind::bind: not yet implemented.");
   }
 
-  TEST_F(Shell_js_crud_collection_find_tests, find_execution)
+  TEST_F(DISABLED_Shell_js_crud_collection_find_tests, find_execution)
   {
     exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
     exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
diff --git a/unittest/shell_js_crud_collection_remove_t.cc b/unittest/shell_js_crud_collection_remove_t.cc
index e8fb5e216be2682d95f140e4b96f81474fff675f..f5cef526599ff8d37d73e5494390acfec11783b5 100644
--- a/unittest/shell_js_crud_collection_remove_t.cc
+++ b/unittest/shell_js_crud_collection_remove_t.cc
@@ -32,7 +32,7 @@
 #include "../modules/mod_crud_collection_remove.h"
 
 namespace shcore {
-  class Shell_js_crud_collection_remove_tests : public Crud_test_wrapper
+  class DISABLED_Shell_js_crud_collection_remove_tests : public Crud_test_wrapper
   {
   protected:
     // You can define per-test set-up and tear-down logic as usual.
@@ -48,7 +48,7 @@ namespace shcore {
     }
   };
 
-  TEST_F(Shell_js_crud_collection_remove_tests, DISABLED_chain_combinations)
+  TEST_F(DISABLED_Shell_js_crud_collection_remove_tests, DISABLED_chain_combinations)
   {
     // NOTE: No data validation is done on this test, only tests
     //       different combinations of chained methods.
@@ -89,7 +89,7 @@ namespace shcore {
     }
   }
 
-  TEST_F(Shell_js_crud_collection_remove_tests, remove_validations)
+  TEST_F(DISABLED_Shell_js_crud_collection_remove_tests, remove_validations)
   {
     exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
     exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
@@ -127,7 +127,7 @@ namespace shcore {
     exec_and_out_contains("collection.remove().bind();", "", "CollectionRemove::bind: not yet implemented.");
   }
 
-  TEST_F(Shell_js_crud_collection_remove_tests, remove_execution)
+  TEST_F(DISABLED_Shell_js_crud_collection_remove_tests, remove_execution)
   {
     exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
     exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
diff --git a/unittest/shell_js_crud_table_insert_t.cc b/unittest/shell_js_crud_table_insert_t.cc
index 57ec66557b02ff8501338650a11ef28eb666327b..49b89a61ae268b0399393662763ff958006760fa 100644
--- a/unittest/shell_js_crud_table_insert_t.cc
+++ b/unittest/shell_js_crud_table_insert_t.cc
@@ -30,7 +30,7 @@
 #include "test_utils.h"
 
 namespace shcore {
-  class Shell_js_crud_table_insert_tests : public Crud_test_wrapper
+  class DISABLED_Shell_js_crud_table_insert_tests : public Crud_test_wrapper
   {
   protected:
     // You can define per-test set-up and tear-down logic as usual.
@@ -45,7 +45,7 @@ namespace shcore {
     }
   };
 
-  TEST_F(Shell_js_crud_table_insert_tests, chain_combinations)
+  TEST_F(DISABLED_Shell_js_crud_table_insert_tests, chain_combinations)
   {
     // Creates a connection object
     exec_and_out_equals("var conn = _F.mysqlx.Connection('" + _uri + "');");
diff --git a/unittest/shell_js_mysql_resultset_t.cc b/unittest/shell_js_mysql_resultset_t.cc
new file mode 100644
index 0000000000000000000000000000000000000000..0e75d27a486f17537daed1fab2d9c9516d4872a7
--- /dev/null
+++ b/unittest/shell_js_mysql_resultset_t.cc
@@ -0,0 +1,110 @@
+/*
+* Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation; version 2 of the
+* License.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+* 02110-1301  USA
+*/
+
+#include <cstdio>
+#include <cstdlib>
+#include <fstream>
+#include <string>
+
+#include "gtest/gtest.h"
+#include "test_utils.h"
+#include "base_session.h"
+
+namespace shcore {
+  class Shell_js_mysql_resultset_tests : public Shell_core_test_wrapper
+  {
+  protected:
+    // You can define per-test set-up and tear-down logic as usual.
+    virtual void SetUp()
+    {
+      Shell_core_test_wrapper::SetUp();
+
+      bool initilaized(false);
+      _shell_core->switch_mode(Shell_core::Mode_JScript, initilaized);
+    }
+  };
+
+  TEST_F(Shell_js_mysql_resultset_tests, initialization)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("session.executeSql('drop schema if exists js_shell_test;')");
+    exec_and_out_equals("session.executeSql('create schema js_shell_test;')");
+    exec_and_out_equals("session.executeSql('use js_shell_test;')");
+    exec_and_out_equals("session.executeSql('create table table1 (id int auto_increment primary key, name varchar(50));')");
+
+    // TODO: should be enabled once collection crud is available
+    //exec_and_out_equals("session.executeSql(\"create table `collection1`(`doc` JSON, `_id` VARBINARY(16) GENERATED ALWAYS AS(unhex(json_unquote(json_extract(doc, '$._id')))) stored PRIMARY KEY)\")");
+
+    exec_and_out_equals("session.executeSql('insert into table1 (`name`) values(\"one\");')");
+    exec_and_out_equals("session.executeSql('insert into table1 (`name`) values(\"two\");')");
+    exec_and_out_equals("session.executeSql('insert into table1 (`name`) values(\"three\");')");
+  }
+
+  // Tests resultset.hasData and resultset.getHasData()
+  TEST_F(Shell_js_mysql_resultset_tests, mysql_resultset_has_data)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var result = session.executeSql('use js_shell_test;');");
+
+    exec_and_out_equals("print(result.hasData);", "false");
+    exec_and_out_equals("print(result.getHasData());", "false");
+
+    exec_and_out_equals("var result = session.executeSql('select * from table1;');");
+
+    exec_and_out_equals("print(result.hasData);", "true");
+    exec_and_out_equals("print(result.getHasData());", "true");
+  }
+
+  // Tests resultset.columnMetadata and resultset.getColumnMetadata()
+  TEST_F(Shell_js_mysql_resultset_tests, mysql_resultset_column_metadata)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var result = session.executeSql('select * from js_shell_test.table1;');");
+
+    exec_and_out_equals("var metadata = result.getColumnMetadata()");
+
+    exec_and_out_equals("print(metadata[0].name)", "id");
+
+    exec_and_out_equals("var metadata = result.columnMetadata");
+
+    exec_and_out_equals("print(metadata[0].name)", "id");
+  }
+
+  // Tests resultset.lastInsertId and resultset.getLastInsertId()
+  TEST_F(Shell_js_mysql_resultset_tests, DISABLED_mysql_resultset_last_insert_id)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var result = session.executeSql('insert into js_shell_test.table1 (`name`) values(\"four\");');");
+
+    exec_and_out_equals("print(result.lastInsertId)", "4");
+    exec_and_out_equals("print(result.getLastInsertId())", "4");
+  }
+}
\ No newline at end of file
diff --git a/unittest/shell_js_mysql_schema_t.cc b/unittest/shell_js_mysql_schema_t.cc
new file mode 100644
index 0000000000000000000000000000000000000000..95c0753cdd70fd771bebbfec2859fd51e0108cd1
--- /dev/null
+++ b/unittest/shell_js_mysql_schema_t.cc
@@ -0,0 +1,214 @@
+/*
+* Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation; version 2 of the
+* License.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+* 02110-1301  USA
+*/
+
+#include <cstdio>
+#include <cstdlib>
+#include <fstream>
+#include <string>
+
+#include "gtest/gtest.h"
+#include "test_utils.h"
+#include "base_session.h"
+
+namespace shcore {
+  class Shell_js_mysql_schema_tests : public Shell_core_test_wrapper
+  {
+  protected:
+    // You can define per-test set-up and tear-down logic as usual.
+    virtual void SetUp()
+    {
+      Shell_core_test_wrapper::SetUp();
+
+      bool initilaized(false);
+      _shell_core->switch_mode(Shell_core::Mode_JScript, initilaized);
+    }
+  };
+
+  TEST_F(Shell_js_mysql_schema_tests, initialization)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("session.executeSql('drop schema if exists js_shell_test;')");
+    exec_and_out_equals("session.executeSql('create schema js_shell_test;')");
+    exec_and_out_equals("session.executeSql('use js_shell_test;')");
+    exec_and_out_equals("var result = session.executeSql('create table table1 (name varchar(50));')");
+    exec_and_out_equals("session.executeSql('create view view1 (my_name) as select name from table1;')");
+  }
+
+  // Tests schema.getName()
+  TEST_F(Shell_js_mysql_schema_tests, mysql_schema_get_name)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("print(session.mysql.getName());", "mysql");
+  }
+
+  // Tests schema.name
+  TEST_F(Shell_js_mysql_schema_tests, mysql_schema_name)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("print(session.mysql.name);", "mysql");
+  }
+
+  // Tests schema.getSession()
+  TEST_F(Shell_js_mysql_schema_tests, mysql_schema_get_session)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var schema = session.mysql;");
+
+    exec_and_out_equals("var schema_session = schema.getSession();");
+
+    exec_and_out_equals("print(schema_session)", "<Session:" + uri + ">");
+  }
+
+  // Tests schema.session
+  TEST_F(Shell_js_mysql_schema_tests, mysql_schema_session)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var schema = session.mysql;");
+
+    exec_and_out_equals("print(schema.session)", "<Session:" + uri + ">");
+  }
+
+  // Tests schema.getSchema()
+  TEST_F(Shell_js_mysql_schema_tests, mysql_schema_get_schema)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var schema = session.mysql;");
+
+    exec_and_out_equals("var schema_schema = schema.getSchema();");
+
+    exec_and_out_equals("print(schema_schema)", "null");
+  }
+
+  // Tests schema.schema
+  TEST_F(Shell_js_mysql_schema_tests, mysql_schema_schema)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var schema = session.mysql;");
+
+    exec_and_out_equals("print(schema.schema)", "null");
+  }
+
+  // Tests schema.getTables()
+  TEST_F(Shell_js_mysql_schema_tests, mysql_schema_get_tables)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var tables = session.js_shell_test.getTables();");
+
+    exec_and_out_equals("print(tables.table1)", "<Table:table1>");
+  }
+
+  // Tests schema.tables
+  TEST_F(Shell_js_mysql_schema_tests, mysql_schema_tables)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("print(session.js_shell_test.tables.table1)", "<Table:table1>");
+  }
+
+  // Tests schema.getViews()
+  TEST_F(Shell_js_mysql_schema_tests, mysql_schema_get_views)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var views = session.js_shell_test.getViews();");
+
+    exec_and_out_equals("print(views.view1)", "<View:view1>");
+  }
+
+  // Tests schema.views
+  TEST_F(Shell_js_mysql_schema_tests, mysql_schema_views)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("print(session.js_shell_test.views.view1)", "<View:view1>");
+  }
+
+  // Tests schema.getTable()
+  TEST_F(Shell_js_mysql_schema_tests, mysql_schema_get_table)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var table = session.js_shell_test.getTable('table1');");
+
+    exec_and_out_equals("print(table)", "<Table:table1>");
+  }
+
+  // Tests schema.getView()
+  TEST_F(Shell_js_mysql_schema_tests, mysql_schema_get_view)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var view = session.js_shell_test.getView('view1');");
+
+    exec_and_out_equals("print(view)", "<View:view1>");
+  }
+
+  // Tests schema.<object>
+  TEST_F(Shell_js_mysql_schema_tests, mysql_schema_object)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("print(session.js_shell_test.table1)", "<Table:table1>");
+    exec_and_out_equals("print(session.js_shell_test.view1)", "<View:view1>");
+  }
+}
\ No newline at end of file
diff --git a/unittest/shell_js_mysql_session_t.cc b/unittest/shell_js_mysql_session_t.cc
new file mode 100644
index 0000000000000000000000000000000000000000..8e86563c84ba92fb14734d34f4bb2103e8563a40
--- /dev/null
+++ b/unittest/shell_js_mysql_session_t.cc
@@ -0,0 +1,194 @@
+/*
+* Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation; version 2 of the
+* License.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+* 02110-1301  USA
+*/
+
+#include <cstdio>
+#include <cstdlib>
+#include <fstream>
+#include <string>
+
+#include "gtest/gtest.h"
+#include "test_utils.h"
+#include "base_session.h"
+
+namespace shcore {
+  class Shell_js_mysql_session_tests : public Shell_core_test_wrapper
+  {
+  protected:
+    // You can define per-test set-up and tear-down logic as usual.
+    virtual void SetUp()
+    {
+      Shell_core_test_wrapper::SetUp();
+
+      bool initilaized(false);
+      _shell_core->switch_mode(Shell_core::Mode_JScript, initilaized);
+    }
+  };
+
+  // Tests session.getDefaultSchema()
+  TEST_F(Shell_js_mysql_session_tests, mysql_base_session_get_uri)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("print(session.getUri());", uri);
+  }
+
+  // Tests session.getDefaultSchema()
+  TEST_F(Shell_js_mysql_session_tests, mysql_base_session_uri)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("print(session.uri);", uri);
+  }
+
+  // Tests session.getDefaultSchema()
+  TEST_F(Shell_js_mysql_session_tests, mysql_base_session_get_default_schema)
+  {
+    {
+      SCOPED_TRACE("retrieving the default schema for first time");
+      exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+      exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+      // Attempts to get the default schema
+      exec_and_out_equals("var schema = session.getDefaultSchema();");
+
+      exec_and_out_equals("print(schema);", "null");
+    };
+
+    {
+      SCOPED_TRACE("Setting/getting default schema.");
+      exec_and_out_equals("session.setDefaultSchema('mysql');");
+
+      // Now uses the formal method
+      exec_and_out_equals("var schema = session.getDefaultSchema();");
+      exec_and_out_equals("print(schema);", "<Schema:mysql>");
+    };
+
+    {
+      // Sets a different default database
+      exec_and_out_equals("session.setDefaultSchema('information_schema');");
+
+      // Now uses the formal method
+      exec_and_out_equals("var schema = session.getDefaultSchema();");
+      exec_and_out_equals("print(schema);", "<Schema:information_schema>");
+    };
+  }
+
+  // Tests session.defaultSchema
+  TEST_F(Shell_js_mysql_session_tests, mysql_base_session_default_schema)
+  {
+    {
+      SCOPED_TRACE("retrieving the default schema for first time");
+      exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+      exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+      // Attempts to get the default schema
+      exec_and_out_equals("print(session.defaultSchema);", "null");
+    };
+
+    {
+      SCOPED_TRACE("Setting/getting default schema.");
+      exec_and_out_equals("session.setDefaultSchema('mysql');");
+
+      // Now uses the formal method
+      exec_and_out_equals("print(session.defaultSchema);", "<Schema:mysql>");
+    };
+
+    {
+      // Sets a different default database
+      exec_and_out_equals("session.setDefaultSchema('information_schema');");
+
+      // Now uses the formal method
+      exec_and_out_equals("print(session.defaultSchema);", "<Schema:information_schema>");
+    };
+  }
+
+  // Tests session.getSchemas()
+  TEST_F(Shell_js_mysql_session_tests, mysql_base_session_get_schemas)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    // Triggers the schema load
+    exec_and_out_equals("var schemas = session.getSchemas();");
+
+    // Now checks the objects can be accessed directly
+    // because has been already set as a session attributes
+    exec_and_out_equals("print(schemas.mysql);", "<Schema:mysql>");
+    exec_and_out_equals("print(schemas.information_schema);", "<Schema:information_schema>");
+  }
+
+  // Tests session.schemas
+  TEST_F(Shell_js_mysql_session_tests, mysql_base_session_schemas)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    // Ensures the schemas have not been loaded
+    exec_and_out_equals("print(session.schemas.mysql);", "<Schema:mysql>");
+    exec_and_out_equals("print(session.schemas.information_schema)", "<Schema:information_schema>");
+  }
+
+  // Tests session.getSchema()
+  TEST_F(Shell_js_mysql_session_tests, mysql_base_session_get_schema)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    // Checks schema retrieval
+    exec_and_out_equals("var schema = session.getSchema('mysql');");
+    exec_and_out_equals("print(schema);", "<Schema:mysql>");
+
+    exec_and_out_equals("var schema = session.getSchema('information_schema');");
+    exec_and_out_equals("print(schema);", "<Schema:information_schema>");
+
+    // Checks schema retrieval with invalid schema
+    exec_and_out_contains("var schema = session.getSchema('unexisting_schema');", "", "Unknown database 'unexisting_schema'");
+  }
+
+  // Tests session.<schema>
+  TEST_F(Shell_js_mysql_session_tests, mysql_base_session_schema)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    // Now direct and indirect access
+    exec_and_out_equals("print(session.mysql);", "<Schema:mysql>");
+
+    exec_and_out_equals("print(session.information_schema);", "<Schema:information_schema>");
+
+    // TODO: add test case with schema that is named as another property
+
+    // Now direct and indirect access
+    exec_and_out_contains("print(session.unexisting_schema);;", "", "Unknown database 'unexisting_schema'");
+  }
+}
\ No newline at end of file
diff --git a/unittest/shell_js_mysql_table_t.cc b/unittest/shell_js_mysql_table_t.cc
new file mode 100644
index 0000000000000000000000000000000000000000..2ee64e35cde8ca551b9b9202c452a17ce61746d0
--- /dev/null
+++ b/unittest/shell_js_mysql_table_t.cc
@@ -0,0 +1,138 @@
+/*
+* Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation; version 2 of the
+* License.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+* 02110-1301  USA
+*/
+
+#include <cstdio>
+#include <cstdlib>
+#include <fstream>
+#include <string>
+
+#include "gtest/gtest.h"
+#include "test_utils.h"
+#include "base_session.h"
+
+namespace shcore {
+  class Shell_js_mysql_table_tests : public Shell_core_test_wrapper
+  {
+  protected:
+    // You can define per-test set-up and tear-down logic as usual.
+    virtual void SetUp()
+    {
+      Shell_core_test_wrapper::SetUp();
+
+      bool initilaized(false);
+      _shell_core->switch_mode(Shell_core::Mode_JScript, initilaized);
+    }
+  };
+
+  TEST_F(Shell_js_mysql_table_tests, initialization)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("session.executeSql('drop schema if exists js_shell_test;')");
+    exec_and_out_equals("session.executeSql('create schema js_shell_test;')");
+    exec_and_out_equals("session.executeSql('use js_shell_test;')");
+    exec_and_out_equals("session.executeSql('create table table1 (name varchar(50));')");
+  }
+
+  // Tests table.getName()
+  TEST_F(Shell_js_mysql_table_tests, mysql_schema_get_name)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var table = session.js_shell_test.table1;");
+
+    exec_and_out_equals("print(table.getName());", "table1");
+  }
+
+  // Tests table.name
+  TEST_F(Shell_js_mysql_table_tests, mysql_schema_name)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var table = session.js_shell_test.table1;");
+
+    exec_and_out_equals("print(table.name);", "table1");
+  }
+
+  // Tests table.getSession()
+  TEST_F(Shell_js_mysql_table_tests, mysql_schema_get_session)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var table = session.js_shell_test.table1;");
+
+    exec_and_out_equals("var table_session = table.getSession();");
+
+    exec_and_out_equals("print(table_session)", "<Session:" + uri + ">");
+  }
+
+  // Tests table.session
+  TEST_F(Shell_js_mysql_table_tests, mysql_schema_session)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var table = session.js_shell_test.table1;");
+
+    exec_and_out_equals("print(table.session)", "<Session:" + uri + ">");
+  }
+
+  // Tests table.getSchema()
+  TEST_F(Shell_js_mysql_table_tests, mysql_schema_get_schema)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var table = session.js_shell_test.table1;");
+
+    exec_and_out_equals("var table_schema = table.getSchema();");
+
+    exec_and_out_equals("print(table_schema)", "<Schema:js_shell_test>");
+  }
+
+  // Tests table.schema
+  TEST_F(Shell_js_mysql_table_tests, mysql_schema_schema)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var table = session.js_shell_test.table1;");
+
+    exec_and_out_equals("print(table.schema)", "<Schema:js_shell_test>");
+  }
+}
\ No newline at end of file
diff --git a/unittest/shell_js_mysql_view_t.cc b/unittest/shell_js_mysql_view_t.cc
new file mode 100644
index 0000000000000000000000000000000000000000..f225b1cab8b27f9f91ef39b803f02e2a12ee0553
--- /dev/null
+++ b/unittest/shell_js_mysql_view_t.cc
@@ -0,0 +1,139 @@
+/*
+* Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation; version 2 of the
+* License.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+* 02110-1301  USA
+*/
+
+#include <cstdio>
+#include <cstdlib>
+#include <fstream>
+#include <string>
+
+#include "gtest/gtest.h"
+#include "test_utils.h"
+#include "base_session.h"
+
+namespace shcore {
+  class Shell_js_mysql_view_tests : public Shell_core_test_wrapper
+  {
+  protected:
+    // You can define per-test set-up and tear-down logic as usual.
+    virtual void SetUp()
+    {
+      Shell_core_test_wrapper::SetUp();
+
+      bool initilaized(false);
+      _shell_core->switch_mode(Shell_core::Mode_JScript, initilaized);
+    }
+  };
+
+  TEST_F(Shell_js_mysql_view_tests, initialization)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("session.executeSql('drop schema if exists js_shell_test;')");
+    exec_and_out_equals("session.executeSql('create schema js_shell_test;')");
+    exec_and_out_equals("session.executeSql('use js_shell_test;')");
+    exec_and_out_equals("session.executeSql('create table table1 (name varchar(50));')");
+    exec_and_out_equals("session.executeSql('create view view1 (my_name) as select name from table1;')");
+  }
+
+  // Tests view.getName()
+  TEST_F(Shell_js_mysql_view_tests, mysql_view_get_name)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var view = session.js_shell_test.view1;");
+
+    exec_and_out_equals("print(view.getName());", "view1");
+  }
+
+  // Tests view.name
+  TEST_F(Shell_js_mysql_view_tests, mysql_view_name)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var view = session.js_shell_test.view1;");
+
+    exec_and_out_equals("print(view.name);", "view1");
+  }
+
+  // Tests view.getSession()
+  TEST_F(Shell_js_mysql_view_tests, mysql_view_get_session)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var view = session.js_shell_test.view1;");
+
+    exec_and_out_equals("var view_session = view.getSession();");
+
+    exec_and_out_equals("print(view_session)", "<Session:" + uri + ">");
+  }
+
+  // Tests view.session
+  TEST_F(Shell_js_mysql_view_tests, mysql_view_session)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var view = session.js_shell_test.view1;");
+
+    exec_and_out_equals("print(view.session)", "<Session:" + uri + ">");
+  }
+
+  // Tests view.getSchema()
+  TEST_F(Shell_js_mysql_view_tests, mysql_view_get_schema)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var view = session.js_shell_test.view1;");
+
+    exec_and_out_equals("var view_schema = view.getSchema();");
+
+    exec_and_out_equals("print(view_schema)", "<Schema:js_shell_test>");
+  }
+
+  // Tests view.schema
+  TEST_F(Shell_js_mysql_view_tests, mysql_view_schema)
+  {
+    exec_and_out_equals("var mysql = require('mysql').mysql;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysql.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var view = session.js_shell_test.view1;");
+
+    exec_and_out_equals("print(view.schema)", "<Schema:js_shell_test>");
+  }
+}
\ No newline at end of file
diff --git a/unittest/shell_js_mysqlx_collection_t.cc b/unittest/shell_js_mysqlx_collection_t.cc
new file mode 100644
index 0000000000000000000000000000000000000000..35855c2eda69b151a7b4c9efc0d2401490ad85cd
--- /dev/null
+++ b/unittest/shell_js_mysqlx_collection_t.cc
@@ -0,0 +1,138 @@
+/*
+* Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation; version 2 of the
+* License.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+* 02110-1301  USA
+*/
+
+#include <cstdio>
+#include <cstdlib>
+#include <fstream>
+#include <string>
+
+#include "gtest/gtest.h"
+#include "test_utils.h"
+#include "base_session.h"
+
+namespace shcore {
+  class Shell_js_mysqlx_collection_tests : public Shell_core_test_wrapper
+  {
+  protected:
+    // You can define per-test set-up and tear-down logic as usual.
+    virtual void SetUp()
+    {
+      Shell_core_test_wrapper::SetUp();
+
+      bool initilaized(false);
+      _shell_core->switch_mode(Shell_core::Mode_JScript, initilaized);
+    }
+  };
+
+  TEST_F(Shell_js_mysqlx_collection_tests, initialization)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
+
+    exec_and_out_equals("session.executeSql('drop schema if exists js_shell_test;')");
+    exec_and_out_equals("session.executeSql('create schema js_shell_test;')");
+    exec_and_out_equals("session.executeSql('use js_shell_test;')");
+    exec_and_out_equals("session.executeSql(\"create table `collection1`(`doc` JSON, `_id` VARBINARY(16) GENERATED ALWAYS AS(unhex(json_unquote(json_extract(doc, '$._id')))) stored PRIMARY KEY)\")");
+  }
+
+  // Tests collection.getName()
+  TEST_F(Shell_js_mysqlx_collection_tests, mysqlx_collection_get_name)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var collection = session.js_shell_test.getCollection('collection1');");
+
+    exec_and_out_equals("print(collection.getName());", "collection1");
+  }
+
+  // Tests collection.name
+  TEST_F(Shell_js_mysqlx_collection_tests, mysqlx_collection_name)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var collection = session.js_shell_test.getCollection('collection1');");
+
+    exec_and_out_equals("print(collection.name);", "collection1");
+  }
+
+  // Tests collection.getSession()
+  TEST_F(Shell_js_mysqlx_collection_tests, mysqlx_collection_get_session)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var collection = session.js_shell_test.getCollection('collection1');");
+
+    exec_and_out_equals("var collection_session = collection.getSession();");
+
+    exec_and_out_equals("print(collection_session)", "<Session:" + uri + ">");
+  }
+
+  // Tests collection.session
+  TEST_F(Shell_js_mysqlx_collection_tests, mysqlx_collection_session)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var collection = session.js_shell_test.getCollection('collection1');");
+
+    exec_and_out_equals("print(collection.session)", "<Session:" + uri + ">");
+  }
+
+  // Tests collection.getSchema()
+  TEST_F(Shell_js_mysqlx_collection_tests, mysqlx_collection_get_schema)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var collection = session.js_shell_test.getCollection('collection1');");
+
+    exec_and_out_equals("var collection_schema = collection.getSchema();");
+
+    exec_and_out_equals("print(collection_schema)", "<Schema:js_shell_test>");
+  }
+
+  // Tests collection.schema
+  TEST_F(Shell_js_mysqlx_collection_tests, mysqlx_collection_schema)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var collection = session.js_shell_test.getCollection('collection1');");
+
+    exec_and_out_equals("print(collection.schema)", "<Schema:js_shell_test>");
+  }
+}
\ No newline at end of file
diff --git a/unittest/shell_js_mysqlx_resultset_t.cc b/unittest/shell_js_mysqlx_resultset_t.cc
new file mode 100644
index 0000000000000000000000000000000000000000..b31763a597de9633508597311c0df6358891ac9b
--- /dev/null
+++ b/unittest/shell_js_mysqlx_resultset_t.cc
@@ -0,0 +1,110 @@
+/*
+* Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation; version 2 of the
+* License.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+* 02110-1301  USA
+*/
+
+#include <cstdio>
+#include <cstdlib>
+#include <fstream>
+#include <string>
+
+#include "gtest/gtest.h"
+#include "test_utils.h"
+#include "base_session.h"
+
+namespace shcore {
+  class Shell_js_mysqlx_resultset_tests : public Shell_core_test_wrapper
+  {
+  protected:
+    // You can define per-test set-up and tear-down logic as usual.
+    virtual void SetUp()
+    {
+      Shell_core_test_wrapper::SetUp();
+
+      bool initilaized(false);
+      _shell_core->switch_mode(Shell_core::Mode_JScript, initilaized);
+    }
+  };
+
+  TEST_F(Shell_js_mysqlx_resultset_tests, initialization)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
+
+    exec_and_out_equals("session.executeSql('drop schema if exists js_shell_test;')");
+    exec_and_out_equals("session.executeSql('create schema js_shell_test;')");
+    exec_and_out_equals("session.executeSql('use js_shell_test;')");
+    exec_and_out_equals("session.executeSql('create table table1 (id int auto_increment primary key, name varchar(50));')");
+
+    // TODO: should be enabled once collection crud is available
+    //exec_and_out_equals("session.executeSql(\"create table `collection1`(`doc` JSON, `_id` VARBINARY(16) GENERATED ALWAYS AS(unhex(json_unquote(json_extract(doc, '$._id')))) stored PRIMARY KEY)\")");
+
+    exec_and_out_equals("session.executeSql('insert into table1 (`name`) values(\"one\");')");
+    exec_and_out_equals("session.executeSql('insert into table1 (`name`) values(\"two\");')");
+    exec_and_out_equals("session.executeSql('insert into table1 (`name`) values(\"three\");')");
+  }
+
+  // Tests resultset.hasData and resultset.getHasData()
+  TEST_F(Shell_js_mysqlx_resultset_tests, mysqlx_resultset_has_data)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
+
+    exec_and_out_equals("var result = session.executeSql('use js_shell_test;');");
+
+    exec_and_out_equals("print(result.hasData);", "false");
+    exec_and_out_equals("print(result.getHasData());", "false");
+
+    exec_and_out_equals("var result = session.executeSql('select * from table1;');");
+
+    exec_and_out_equals("print(result.hasData);", "true");
+    exec_and_out_equals("print(result.getHasData());", "true");
+  }
+
+  // Tests resultset.columnMetadata and resultset.getColumnMetadata()
+  TEST_F(Shell_js_mysqlx_resultset_tests, mysqlx_resultset_column_metadata)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
+
+    exec_and_out_equals("var result = session.executeSql('select * from js_shell_test.table1;');");
+
+    exec_and_out_equals("var metadata = result.getColumnMetadata()");
+
+    exec_and_out_equals("print(metadata[0].name)", "id");
+
+    exec_and_out_equals("var metadata = result.columnMetadata");
+
+    exec_and_out_equals("print(metadata[0].name)", "id");
+  }
+
+  // Tests resultset.lastInsertId and resultset.getLastInsertId()
+  TEST_F(Shell_js_mysqlx_resultset_tests, DISABLED_mysqlx_resultset_last_insert_id)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
+
+    exec_and_out_equals("var result = session.executeSql('insert into js_shell_test.table1 (`name`) values(\"four\");');");
+
+    exec_and_out_equals("print(result.lastInsertId)", "4");
+    exec_and_out_equals("print(result.getLastInsertId())", "4");
+  }
+}
\ No newline at end of file
diff --git a/unittest/shell_js_mysqlx_schema_t.cc b/unittest/shell_js_mysqlx_schema_t.cc
new file mode 100644
index 0000000000000000000000000000000000000000..bafd98145fd269d65db024259c681967c3fdf383
--- /dev/null
+++ b/unittest/shell_js_mysqlx_schema_t.cc
@@ -0,0 +1,252 @@
+/*
+* Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation; version 2 of the
+* License.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+* 02110-1301  USA
+*/
+
+#include <cstdio>
+#include <cstdlib>
+#include <fstream>
+#include <string>
+
+#include "gtest/gtest.h"
+#include "test_utils.h"
+#include "base_session.h"
+
+namespace shcore {
+  class Shell_js_mysqlx_schema_tests : public Shell_core_test_wrapper
+  {
+  protected:
+    // You can define per-test set-up and tear-down logic as usual.
+    virtual void SetUp()
+    {
+      Shell_core_test_wrapper::SetUp();
+
+      bool initilaized(false);
+      _shell_core->switch_mode(Shell_core::Mode_JScript, initilaized);
+    }
+  };
+
+  TEST_F(Shell_js_mysqlx_schema_tests, initialization)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
+
+    exec_and_out_equals("session.executeSql('drop schema if exists js_shell_test;')");
+    exec_and_out_equals("session.executeSql('create schema js_shell_test;')");
+    exec_and_out_equals("session.executeSql('use js_shell_test;')");
+    exec_and_out_equals("var result = session.executeSql('create table table1 (name varchar(50));')");
+    exec_and_out_equals("session.executeSql('create view view1 (my_name) as select name from table1;')");
+    exec_and_out_equals("session.executeSql(\"create table `collection1`(`doc` JSON, `_id` VARBINARY(16) GENERATED ALWAYS AS(unhex(json_unquote(json_extract(doc, '$._id')))) stored PRIMARY KEY)\")");
+  }
+
+  // Tests schema.getName()
+  TEST_F(Shell_js_mysqlx_schema_tests, mysqlx_schema_get_name)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("print(session.mysql.getName());", "mysql");
+  }
+
+  // Tests schema.name
+  TEST_F(Shell_js_mysqlx_schema_tests, mysqlx_schema_name)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("print(session.mysql.name);", "mysql");
+  }
+
+  // Tests schema.getSession()
+  TEST_F(Shell_js_mysqlx_schema_tests, mysqlx_schema_get_session)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var schema = session.mysql;");
+
+    exec_and_out_equals("var schema_session = schema.getSession();");
+
+    exec_and_out_equals("print(schema_session)", "<Session:" + uri + ">");
+  }
+
+  // Tests schema.session
+  TEST_F(Shell_js_mysqlx_schema_tests, mysqlx_schema_session)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var schema = session.mysql;");
+
+    exec_and_out_equals("print(schema.session)", "<Session:" + uri + ">");
+  }
+
+  // Tests schema.getSchema()
+  TEST_F(Shell_js_mysqlx_schema_tests, mysqlx_schema_get_schema)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var schema = session.mysql;");
+
+    exec_and_out_equals("var schema_schema = schema.getSchema();");
+
+    exec_and_out_equals("print(schema_schema)", "null");
+  }
+
+  // Tests schema.schema
+  TEST_F(Shell_js_mysqlx_schema_tests, mysqlx_schema_schema)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var schema = session.mysql;");
+
+    exec_and_out_equals("print(schema.schema)", "null");
+  }
+
+  // Tests schema.getTables()
+  TEST_F(Shell_js_mysqlx_schema_tests, mysqlx_schema_get_tables)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var tables = session.js_shell_test.getTables();");
+
+    exec_and_out_equals("print(tables.table1)", "<Table:table1>");
+  }
+
+  // Tests schema.tables
+  TEST_F(Shell_js_mysqlx_schema_tests, mysqlx_schema_tables)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("print(session.js_shell_test.tables.table1)", "<Table:table1>");
+  }
+
+  // Tests schema.getViews()
+  TEST_F(Shell_js_mysqlx_schema_tests, mysqlx_schema_get_views)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var views = session.js_shell_test.getViews();");
+
+    exec_and_out_equals("print(views.view1)", "<View:view1>");
+  }
+
+  // Tests schema.views
+  TEST_F(Shell_js_mysqlx_schema_tests, mysqlx_schema_views)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("print(session.js_shell_test.views.view1)", "<View:view1>");
+  }
+
+  // Tests schema.getCollections()
+  TEST_F(Shell_js_mysqlx_schema_tests, mysqlx_schema_get_collections)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var collections = session.js_shell_test.getCollections();");
+
+    exec_and_out_equals("print(collections.collection1)", "<Collection:collection1>");
+  }
+
+  // Tests schema.collections
+  TEST_F(Shell_js_mysqlx_schema_tests, mysqlx_schema_collections)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("print(session.js_shell_test.collections.collection1)", "<Collection:collection1>");
+  }
+
+  // Tests schema.getTable()
+  TEST_F(Shell_js_mysqlx_schema_tests, mysqlx_schema_get_table)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var table = session.js_shell_test.getTable('table1');");
+
+    exec_and_out_equals("print(table)", "<Table:table1>");
+  }
+
+  // Tests schema.getView()
+  TEST_F(Shell_js_mysqlx_schema_tests, mysqlx_schema_get_view)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var view = session.js_shell_test.getView('view1');");
+
+    exec_and_out_equals("print(view)", "<View:view1>");
+  }
+
+  // Tests schema.getCollection()
+  TEST_F(Shell_js_mysqlx_schema_tests, mysqlx_schema_get_collection)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var collection = session.js_shell_test.getCollection('collection1');");
+
+    exec_and_out_equals("print(collection)", "<Collection:collection1>");
+  }
+
+  // Tests schema.<object>
+  TEST_F(Shell_js_mysqlx_schema_tests, mysqlx_schema_object)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("print(session.js_shell_test.table1)", "<Table:table1>");
+    exec_and_out_equals("print(session.js_shell_test.view1)", "<View:view1>");
+
+    // TODO: Uncomment once the collections can be retrieved
+    //exec_and_out_equals("print(session.js_shell_test.collection1)", "<Collection:collection1>");
+  }
+}
\ No newline at end of file
diff --git a/unittest/shell_js_mysqlx_session_t.cc b/unittest/shell_js_mysqlx_session_t.cc
new file mode 100644
index 0000000000000000000000000000000000000000..fa0284c2f16dc2cbe7f5dde0de7221aa3aae37b6
--- /dev/null
+++ b/unittest/shell_js_mysqlx_session_t.cc
@@ -0,0 +1,194 @@
+/*
+* Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation; version 2 of the
+* License.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+* 02110-1301  USA
+*/
+
+#include <cstdio>
+#include <cstdlib>
+#include <fstream>
+#include <string>
+
+#include "gtest/gtest.h"
+#include "test_utils.h"
+#include "base_session.h"
+
+namespace shcore {
+  class Shell_js_mysqlx_session_tests : public Shell_core_test_wrapper
+  {
+  protected:
+    // You can define per-test set-up and tear-down logic as usual.
+    virtual void SetUp()
+    {
+      Shell_core_test_wrapper::SetUp();
+
+      bool initilaized(false);
+      _shell_core->switch_mode(Shell_core::Mode_JScript, initilaized);
+    }
+  };
+
+  // Tests session.getDefaultSchema()
+  TEST_F(Shell_js_mysqlx_session_tests, mysqlx_base_session_get_uri)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("print(session.getUri());", uri);
+  }
+
+  // Tests session.getDefaultSchema()
+  TEST_F(Shell_js_mysqlx_session_tests, mysqlx_base_session_uri)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("print(session.uri);", uri);
+  }
+
+  // Tests session.getDefaultSchema()
+  TEST_F(Shell_js_mysqlx_session_tests, mysqlx_base_session_get_default_schema)
+  {
+    {
+      SCOPED_TRACE("retrieving the default schema for first time");
+      exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+      exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
+
+      // Attempts to get the default schema
+      exec_and_out_equals("var schema = session.getDefaultSchema();");
+
+      exec_and_out_equals("print(schema);", "null");
+    };
+
+    {
+      SCOPED_TRACE("Setting/getting default schema.");
+      exec_and_out_equals("session.setDefaultSchema('mysql');");
+
+      // Now uses the formal method
+      exec_and_out_equals("var schema = session.getDefaultSchema();");
+      exec_and_out_equals("print(schema);", "<Schema:mysql>");
+    };
+
+    {
+      // Sets a different default database
+      exec_and_out_equals("session.setDefaultSchema('information_schema');");
+
+      // Now uses the formal method
+      exec_and_out_equals("var schema = session.getDefaultSchema();");
+      exec_and_out_equals("print(schema);", "<Schema:information_schema>");
+    };
+  }
+
+  // Tests session.defaultSchema
+  TEST_F(Shell_js_mysqlx_session_tests, mysqlx_base_session_default_schema)
+  {
+    {
+      SCOPED_TRACE("retrieving the default schema for first time");
+      exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+      exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
+
+      // Attempts to get the default schema
+      exec_and_out_equals("print(session.defaultSchema);", "null");
+    };
+
+    {
+      SCOPED_TRACE("Setting/getting default schema.");
+      exec_and_out_equals("session.setDefaultSchema('mysql');");
+
+      // Now uses the formal method
+      exec_and_out_equals("print(session.defaultSchema);", "<Schema:mysql>");
+    };
+
+    {
+      // Sets a different default database
+      exec_and_out_equals("session.setDefaultSchema('information_schema');");
+
+      // Now uses the formal method
+      exec_and_out_equals("print(session.defaultSchema);", "<Schema:information_schema>");
+    };
+  }
+
+  // Tests session.getSchemas()
+  TEST_F(Shell_js_mysqlx_session_tests, mysqlx_base_session_get_schemas)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
+
+    // Triggers the schema load
+    exec_and_out_equals("var schemas = session.getSchemas();");
+
+    // Now checks the objects can be accessed directly
+    // because has been already set as a session attributes
+    exec_and_out_equals("print(schemas.mysql);", "<Schema:mysql>");
+    exec_and_out_equals("print(schemas.information_schema);", "<Schema:information_schema>");
+  }
+
+  // Tests session.schemas
+  TEST_F(Shell_js_mysqlx_session_tests, mysqlx_base_session_schemas)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
+
+    // Ensures the schemas have not been loaded
+    exec_and_out_equals("print(session.schemas.mysql);", "<Schema:mysql>");
+    exec_and_out_equals("print(session.schemas.information_schema)", "<Schema:information_schema>");
+  }
+
+  // Tests session.getSchema()
+  TEST_F(Shell_js_mysqlx_session_tests, mysqlx_base_session_get_schema)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    // Checks schema retrieval
+    exec_and_out_equals("var schema = session.getSchema('mysql');");
+    exec_and_out_equals("print(schema);", "<Schema:mysql>");
+
+    exec_and_out_equals("var schema = session.getSchema('information_schema');");
+    exec_and_out_equals("print(schema);", "<Schema:information_schema>");
+
+    // Checks schema retrieval with invalid schema
+    exec_and_out_contains("var schema = session.getSchema('unexisting_schema');", "", "Unknown database 'unexisting_schema'");
+  }
+
+  // Tests session.<schema>
+  TEST_F(Shell_js_mysqlx_session_tests, mysqlx_base_session_schema)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    // Now direct and indirect access
+    exec_and_out_equals("print(session.mysql);", "<Schema:mysql>");
+
+    exec_and_out_equals("print(session.information_schema);", "<Schema:information_schema>");
+
+    // TODO: add test case with schema that is named as another property
+
+    // Now direct and indirect access
+    exec_and_out_contains("print(session.unexisting_schema);;", "", "Unknown database 'unexisting_schema'");
+  }
+}
\ No newline at end of file
diff --git a/unittest/shell_js_mysqlx_t.cc b/unittest/shell_js_mysqlx_t.cc
index 251d189eb234be67cb774d690e52f9c7af5a878c..9a484b97001c9e7f160a3aad02788ceaeb1a7bfb 100644
--- a/unittest/shell_js_mysqlx_t.cc
+++ b/unittest/shell_js_mysqlx_t.cc
@@ -1,17 +1,21 @@
-/* Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; version 2 of the License.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA */
+/*
+* Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation; version 2 of the
+* License.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+* 02110-1301  USA
+*/
 
 #include <cstdio>
 #include <cstdlib>
@@ -20,6 +24,7 @@ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA */
 
 #include "gtest/gtest.h"
 #include "test_utils.h"
+#include "base_session.h"
 
 namespace shcore {
   class Shell_js_mysqlx_tests : public Shell_core_test_wrapper
@@ -41,16 +46,10 @@ namespace shcore {
     wipe_all();
     exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
     exec_and_out_equals("var exports = dir(mysqlx);");
-    exec_and_out_equals("print(exports.length);", "8");
+    exec_and_out_equals("print(exports.length);", "2");
 
     exec_and_out_equals("print(typeof mysqlx.openSession);", "function");
     exec_and_out_equals("print(typeof mysqlx.openNodeSession);", "function");
-    exec_and_out_equals("print(typeof mysqlx.Session);", "function");
-    exec_and_out_equals("print(typeof mysqlx.NodeSession);", "function");
-    exec_and_out_equals("print(typeof mysqlx.Schema);", "function");
-    exec_and_out_equals("print(typeof mysqlx.Table);", "function");
-    exec_and_out_equals("print(typeof mysqlx.Collection);", "function");
-    exec_and_out_equals("print(typeof mysqlx.View);", "function");
   }
 
   TEST_F(Shell_js_mysqlx_tests, mysqlx_open_session)
@@ -58,18 +57,22 @@ namespace shcore {
     exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
 
     // Assuming _uri is in the format user:password@host
+    std::string uri = mysh::strip_password(_uri);
+
     exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
-    exec_and_out_equals("print(session instanceof mysqlx.Session);", "true");
-    exec_and_out_equals("print(session instanceof mysqlx.NodeSession);", "false");
+    exec_and_out_equals("print(session);", "<Session:" + uri + ">");
 
     // Ensures the right members exist
     exec_and_out_equals("var members = dir(session);");
-    exec_and_out_equals("print(members.length)", "6");
-    exec_and_out_equals("print(typeof session.getSchema);", "function");
-    exec_and_out_equals("print(typeof session.getSchemas);", "function");
-    exec_and_out_equals("print(typeof session.getDefaultSchema);", "function");
-
-    exec_and_out_equals("print(typeof session.executeSql);", "undefined");
+    exec_and_out_equals("print(members.length >= 8)", "true");
+    exec_and_out_equals("print(members[0] == 'getDefaultSchema');", "true");
+    exec_and_out_equals("print(members[1] == 'getSchema');", "true");
+    exec_and_out_equals("print(members[2] == 'getSchemas');", "true");
+    exec_and_out_equals("print(members[3] == 'getUri');", "true");
+    exec_and_out_equals("print(members[4] == 'setDefaultSchema');", "true");
+    exec_and_out_equals("print(members[5] == 'defaultSchema');", "true");
+    exec_and_out_equals("print(members[6] == 'schemas');", "true");
+    exec_and_out_equals("print(members[7] == 'uri');", "true");
   }
 
   TEST_F(Shell_js_mysqlx_tests, mysqlx_open_node_session)
@@ -77,391 +80,21 @@ namespace shcore {
     exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
 
     // Assuming _uri is in the format user:password@host
+    std::string uri = mysh::strip_password(_uri);
     exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
-    exec_and_out_equals("print(session instanceof mysqlx.Session);", "false");
-    exec_and_out_equals("print(session instanceof mysqlx.NodeSession);", "true");
+    exec_and_out_equals("print(session);", "<NodeSession:" + uri + ">");
 
     // Ensures the right members exist
     exec_and_out_equals("var members = dir(session);");
-    exec_and_out_equals("print(members.length)", "7");
-    exec_and_out_equals("print(typeof session.getSchema);", "function");
-    exec_and_out_equals("print(typeof session.getSchemas);", "function");
-    exec_and_out_equals("print(typeof session.getDefaultSchema);", "function");
-
-    exec_and_out_equals("print(typeof session.executeSql);", "function");
-  }
-
-  TEST_F(Shell_js_mysqlx_tests, mysqlx_base_session_get_default_schema)
-  {
-    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
-
-    // Assuming _uri is in the format user:password@host
-    exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
-
-    // Attempts to get the default schema
-    exec_and_out_equals("var schema = session.getDefaultSchema();");
-
-    // TODO: This is returning a null object and is threated as object in JS
-    //       should it be a null value??
-    exec_and_out_equals("print(schema);", "null");
-
-    // Sets a default database
-    exec_and_out_equals("session.executeSql('use mysql;');");
-
-    // Attempts accessing the default database by name
-    exec_and_out_equals("print(session.mysql)", "undefined");
-
-    // Now uses the formal method
-    exec_and_out_equals("var schema = session.getDefaultSchema();");
-    exec_and_out_equals("print(typeof schema);", "object");
-    exec_and_out_equals("print(schema instanceof mysqlx.Schema);", "true");
-    exec_and_out_equals("print(schema.name);", "mysql");
-
-    // Now checks the object can be accessed directly
-    // because has been already set as a session attribute
-    exec_and_out_equals("print(typeof session.mysql);", "object");
-    exec_and_out_equals("print(session.mysql instanceof mysqlx.Schema);", "true");
-    exec_and_out_equals("print(session.mysql.name);", "mysql");
-
-    // Sets a different default database
-    exec_and_out_equals("session.executeSql('use information_schema;');");
-
-    // Now uses the formal method
-    exec_and_out_equals("var schema = session.getDefaultSchema();");
-    exec_and_out_equals("print(typeof schema);", "object");
-    exec_and_out_equals("print(schema instanceof mysqlx.Schema);", "true");
-    exec_and_out_equals("print(schema.name);", "information_schema");
-
-    // Now checks the object can be accessed directly
-    // because has been already set as a session attribute
-    exec_and_out_equals("print(typeof session.information_schema);", "object");
-    exec_and_out_equals("print(session.information_schema instanceof mysqlx.Schema);", "true");
-    exec_and_out_equals("print(session.information_schema.name);", "information_schema");
-  }
-
-  TEST_F(Shell_js_mysqlx_tests, mysqlx_base_session_default_schema)
-  {
-    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
-
-    // Assuming _uri is in the format user:password@host
-    exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
-
-    // Attempts to get the default schema
-    exec_and_out_equals("var schema = session.default_schema;");
-
-    // TODO: This is returning a null object and is threated as object in JS
-    //       should it be a null value??
-    exec_and_out_equals("print(schema);", "null");
-
-    // Sets a default database
-    exec_and_out_equals("session.executeSql('use mysql;');");
-
-    // Attempts accessing the default database by name
-    exec_and_out_equals("print(session.mysql)", "undefined");
-
-    // Now uses the formal method
-    exec_and_out_equals("var schema = session.default_schema;");
-    exec_and_out_equals("print(typeof schema);", "object");
-    exec_and_out_equals("print(schema instanceof mysqlx.Schema);", "true");
-    exec_and_out_equals("print(schema.name);", "mysql");
-
-    // Now checks the object can be accessed directly
-    // because has been already set as a session attribute
-    exec_and_out_equals("print(typeof session.mysql);", "object");
-    exec_and_out_equals("print(session.mysql instanceof mysqlx.Schema);", "true");
-    exec_and_out_equals("print(session.mysql.name);", "mysql");
-
-    // Sets a different default database
-    exec_and_out_equals("session.executeSql('use information_schema;');");
-
-    // Now uses the formal method
-    exec_and_out_equals("var schema = session.default_schema;");
-    exec_and_out_equals("print(typeof schema);", "object");
-    exec_and_out_equals("print(schema instanceof mysqlx.Schema);", "true");
-    exec_and_out_equals("print(schema.name);", "information_schema");
-
-    // Now checks the object can be accessed directly
-    // because has been already set as a session attribute
-    exec_and_out_equals("print(typeof session.information_schema);", "object");
-    exec_and_out_equals("print(session.information_schema instanceof mysqlx.Schema);", "true");
-    exec_and_out_equals("print(session.information_schema.name);", "information_schema");
-  }
-
-  TEST_F(Shell_js_mysqlx_tests, mysqlx_base_session_get_schema)
-  {
-    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
-
-    // Assuming _uri is in the format user:password@host
-    exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
-
-    // Attempts accessing a database directly as session attribute
-    exec_and_out_equals("print(session.information_schema)", "undefined");
-
-    // Now uses the formal method
-    exec_and_out_equals("var schema = session.getSchema('information_schema');");
-    exec_and_out_equals("print(typeof schema);", "object");
-    exec_and_out_equals("print(schema instanceof mysqlx.Schema);", "true");
-    exec_and_out_equals("print(schema.name);", "information_schema");
-
-    // Now checks the object can be accessed directly
-    // because has been already set as a session attribute
-    exec_and_out_equals("print(typeof session.information_schema);", "object");
-    exec_and_out_equals("print(session.information_schema instanceof mysqlx.Schema);", "true");
-    exec_and_out_equals("print(session.information_schema.name);", "information_schema");
-  }
-
-  TEST_F(Shell_js_mysqlx_tests, mysqlx_base_session_get_schemas)
-  {
-    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
-
-    // Assuming _uri is in the format user:password@host
-    exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
-
-    // Ensures the schemas have not been loaded
-    exec_and_out_equals("print(session._loaded);", "false");
-    exec_and_out_equals("print(session.mysql)", "undefined");
-    exec_and_out_equals("print(session.information_schema)", "undefined");
-
-    // Triggers the schema load
-    exec_and_out_equals("var schemas = session.getSchemas();");
-
-    // Validates schemas were loaded
-    exec_and_out_equals("print(session._loaded);", "true");
-
-    // Now checks the objects can be accessed directly
-    // because has been already set as a session attributes
-    exec_and_out_equals("print(typeof session.mysql);", "object");
-    exec_and_out_equals("print(session.mysql instanceof mysqlx.Schema);", "true");
-    exec_and_out_equals("print(session.mysql.name);", "mysql");
-
-    exec_and_out_equals("print(typeof session.information_schema);", "object");
-    exec_and_out_equals("print(session.information_schema instanceof mysqlx.Schema);", "true");
-    exec_and_out_equals("print(session.information_schema.name);", "information_schema");
-  }
-
-  TEST_F(Shell_js_mysqlx_tests, mysqlx_base_session_schemas)
-  {
-    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
-
-    // Assuming _uri is in the format user:password@host
-    exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
-
-    // Ensures the schemas have not been loaded
-    exec_and_out_equals("print(session._loaded);", "false");
-    exec_and_out_equals("print(session.mysql)", "undefined");
-    exec_and_out_equals("print(session.information_schema)", "undefined");
-
-    // Triggers the schema load
-    exec_and_out_equals("var schemas = session.schemas;");
-
-    // Validates schemas were loaded
-    exec_and_out_equals("print(session._loaded);", "true");
-
-    // Now checks the objects can be accessed directly
-    // because has been already set as a session attributes
-    exec_and_out_equals("print(typeof session.mysql);", "object");
-    exec_and_out_equals("print(session.mysql instanceof mysqlx.Schema);", "true");
-    exec_and_out_equals("print(session.mysql.name);", "mysql");
-
-    exec_and_out_equals("print(typeof session.information_schema);", "object");
-    exec_and_out_equals("print(session.information_schema instanceof mysqlx.Schema);", "true");
-    exec_and_out_equals("print(session.information_schema.name);", "information_schema");
-  }
-
-  TEST_F(Shell_js_mysqlx_tests, mysqlx_session_object_structure)
-  {
-    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
-
-    // Assuming _uri is in the format user:password@host
-    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
-
-    // Ensures the schemas have not been loaded
-    exec_and_out_equals("var schema = session.getSchema('mysql')");
-    exec_and_out_equals("var members = dir(schema);");
-    exec_and_out_equals("print(members.length);", "17");
-
-    // Review the DatabaseObject members are present
-    exec_and_out_equals("print(typeof schema.session);", "object");
-    exec_and_out_equals("print(typeof schema.schema);", "object");
-    exec_and_out_equals("print(typeof schema.name);", "string");
-    exec_and_out_equals("print(typeof schema.in_database);", "boolean");
-    exec_and_out_equals("print(typeof schema.getSession);", "function");
-    exec_and_out_equals("print(typeof schema.getSchema);", "function");
-    exec_and_out_equals("print(typeof schema.getName);", "function");
-    exec_and_out_equals("print(typeof schema.existsInDatabase);", "function");
-
-    // Review the Schema members are present
-    exec_and_out_equals("print(typeof schema.getTable);", "function");
-    exec_and_out_equals("print(typeof schema.getView);", "function");
-    exec_and_out_equals("print(typeof schema.getCollection);", "function");
-    exec_and_out_equals("print(typeof schema.getTables);", "function");
-    exec_and_out_equals("print(typeof schema.getViews);", "function");
-    exec_and_out_equals("print(typeof schema.getCollections);", "function");
-
-    exec_and_out_equals("print(schema.session instanceof mysqlx.Session)", "true");
-    exec_and_out_equals("print(schema.schema instanceof mysqlx.Schema)", "true");
-    exec_and_out_equals("print(schema.name)", "mysql");
-    exec_and_out_equals("print(schema.in_database)", "true");
-
-    // Ensures the properties are non writable
-    exec_and_out_equals("schema.session = null;");
-    exec_and_out_equals("schema.schema = null;");
-    exec_and_out_equals("schema.name = 'fake'");
-
-    exec_and_out_equals("print(schema.session instanceof mysqlx.Session)", "true");
-    exec_and_out_equals("print(schema.schema instanceof mysqlx.Schema)", "true");
-    exec_and_out_equals("print(schema.name)", "mysql");
-
-    // Now compares the getFunctions on DatabaseObject against the attributes
-    exec_and_out_equals("print(schema.session === schema.getSession())", "true");
-    exec_and_out_equals("print(schema.schema === schema.getSchema())", "true");
-    exec_and_out_equals("print(schema.name === schema.getName())", "true");
-    exec_and_out_equals("print(schema.in_database=== schema.existsInDatabase())", "true");
-  }
-
-  TEST_F(Shell_js_mysqlx_tests, mysqlx_session_items)
-  {
-    // TODO: Include the code for the Collections
-    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
-
-    // Assuming _uri is in the format user:password@host
-    exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
-
-    exec_and_out_equals("session.executeSql('drop schema if exists js_shell_test;')");
-    exec_and_out_equals("session.executeSql('create schema js_shell_test;')");
-    exec_and_out_equals("session.executeSql('use js_shell_test;')");
-    exec_and_out_equals("session.executeSql('create table table1 (name varchar(50));')");
-    exec_and_out_equals("session.executeSql('create view view1 (my_name) as select name from table1;')");
-
-    exec_and_out_equals("var schema = session.getSchema('js_shell_test')");
-
-    // Ensures the table object does not exists before loading
-    exec_and_out_equals("print(typeof schema.table1)", "undefined");
-
-    // Ensures the schemas have not been loaded
-    exec_and_out_equals("var table = schema.getTable('table1');");
-    exec_and_out_equals("print(table instanceof mysqlx.Table)", "true");
-
-    // Ensures the table object now exists on the schema
-    exec_and_out_equals("print(schema.table1 instanceof mysqlx.Table)", "true");
-  }
-
-  TEST_F(Shell_js_mysqlx_tests, mysqlx_session_full_loading)
-  {
-    // TODO: Include the code for the Collections
-    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
-
-    std::vector<std::string> full_load_triggers;
-    full_load_triggers.push_back("var tables = schema.getTables()");
-    full_load_triggers.push_back("var tables = schema.tables");
-    full_load_triggers.push_back("var views = schema.getViews()");
-    full_load_triggers.push_back("var views = schema.views");
-    full_load_triggers.push_back("var views = schema.getCollections()");
-    full_load_triggers.push_back("var views = schema.collections");
-
-    for (size_t index = 0; index < full_load_triggers.size(); index++)
-    {
-      // Assuming _uri is in the format user:password@host
-      exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
-
-      exec_and_out_equals("session.executeSql('drop schema if exists js_shell_test;')");
-      exec_and_out_equals("session.executeSql('create schema js_shell_test;')");
-      exec_and_out_equals("session.executeSql('use js_shell_test;')");
-      exec_and_out_equals("session.executeSql('create table table1 (name varchar(50));')");
-      exec_and_out_equals("session.executeSql('create view view1 (my_name) as select name from table1;')");
-
-      exec_and_out_equals("var schema = session.getSchema('js_shell_test')");
-
-      // Ensures the table object does not exists before loading
-      exec_and_out_equals("print(schema._loaded)", "false");
-
-      // Triggers all object loading
-      exec_and_out_equals(full_load_triggers[index]);
-
-      // Ensures all the objects have been loaded
-      exec_and_out_equals("print(schema._loaded)", "true");
-      exec_and_out_equals("print(schema.table1 instanceof mysqlx.Table)", "true");
-      exec_and_out_equals("print(schema.view1 instanceof mysqlx.View)", "true");
-    }
-  }
-
-  TEST_F(Shell_js_mysqlx_tests, mysqlx_table_object_structure)
-  {
-    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
-
-    // Assuming _uri is in the format user:password@host
-    exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
-
-    exec_and_out_equals("session.executeSql('drop schema if exists js_shell_test;')");
-    exec_and_out_equals("session.executeSql('create schema js_shell_test;')");
-    exec_and_out_equals("session.executeSql('use js_shell_test;')");
-    exec_and_out_equals("session.executeSql('create table table1 (name varchar(50));')");
-    exec_and_out_equals("session.executeSql('create view view1 (my_name) as select name from table1;')");
-
-    exec_and_out_equals("var schema = session.getSchema('js_shell_test')");
-
-    // Ensures the schemas have not been loaded
-    exec_and_out_equals("var table = schema.getTable('table1')");
-    exec_and_out_equals("var members = dir(table);");
-    exec_and_out_equals("print(members.length);", "9");
-
-    // Review the DatabaseObject members are present
-    exec_and_out_equals("print(typeof table.session);", "object");
-    exec_and_out_equals("print(typeof table.schema);", "object");
-    exec_and_out_equals("print(typeof table.name);", "string");
-    exec_and_out_equals("print(typeof table.in_database);", "boolean");
-    exec_and_out_equals("print(typeof table.getSession);", "function");
-    exec_and_out_equals("print(typeof table.getSchema);", "function");
-    exec_and_out_equals("print(typeof table.getName);", "function");
-    exec_and_out_equals("print(typeof table.existsInDatabase);", "function");
-
-    // TODO Review the Schema members are present
-
-    // Ensures the properties are non writable
-    exec_and_out_equals("table.session = null;");
-    exec_and_out_equals("table.schema = null;");
-    exec_and_out_equals("table.name = 'fake'");
-
-    exec_and_out_equals("print(table.session instanceof mysqlx.NodeSession)", "true");
-    exec_and_out_equals("print(table.schema instanceof mysqlx.Schema)", "true");
-    exec_and_out_equals("print(table.name)", "table1");
-
-    // Now compares the getFunctions on DatabaseObject against the attributes
-    exec_and_out_equals("print(table.session === table.getSession())", "true");
-    exec_and_out_equals("print(table.schema === table.getSchema())", "true");
-    exec_and_out_equals("print(table.name === table.getName())", "true");
-    exec_and_out_equals("print(table.in_database=== table.existsInDatabase())", "true");
-
-    // Ensures the schemas have not been loaded
-    exec_and_out_equals("var view = schema.getView('view1')");
-    exec_and_out_equals("var members = dir(view);");
-    exec_and_out_equals("print(members.length);", "8");
-
-    // Review the DatabaseObject members are present
-    exec_and_out_equals("print(typeof view.session);", "object");
-    exec_and_out_equals("print(typeof view.schema);", "object");
-    exec_and_out_equals("print(typeof view.name);", "string");
-    exec_and_out_equals("print(typeof view.in_database);", "boolean");
-    exec_and_out_equals("print(typeof view.getSession);", "function");
-    exec_and_out_equals("print(typeof view.getSchema);", "function");
-    exec_and_out_equals("print(typeof view.getName);", "function");
-    exec_and_out_equals("print(typeof view.existsInDatabase);", "function");
-
-    // TODO Review the Schema members are present
-
-    // Ensures the properties are non writable
-    exec_and_out_equals("view.session = null;");
-    exec_and_out_equals("view.schema = null;");
-    exec_and_out_equals("view.name = 'fake'");
-
-    exec_and_out_equals("print(view.session instanceof mysqlx.NodeSession)", "true");
-    exec_and_out_equals("print(view.schema instanceof mysqlx.Schema)", "true");
-    exec_and_out_equals("print(view.name)", "view1");
-
-    // Now compares the getFunctions on DatabaseObject against the attributes
-    exec_and_out_equals("print(view.session === view.getSession())", "true");
-    exec_and_out_equals("print(view.schema === view.getSchema())", "true");
-    exec_and_out_equals("print(view.name === view.getName())", "true");
-    exec_and_out_equals("print(view.in_database=== view.existsInDatabase())", "true");
+    exec_and_out_equals("print(members.length >= 9)", "true");
+    exec_and_out_equals("print(members[0] == 'executeSql');", "true");
+    exec_and_out_equals("print(members[1] == 'getDefaultSchema');", "true");
+    exec_and_out_equals("print(members[2] == 'getSchema');", "true");
+    exec_and_out_equals("print(members[3] == 'getSchemas');", "true");
+    exec_and_out_equals("print(members[4] == 'getUri');", "true");
+    exec_and_out_equals("print(members[5] == 'setDefaultSchema');", "true");
+    exec_and_out_equals("print(members[6] == 'defaultSchema');", "true");
+    exec_and_out_equals("print(members[7] == 'schemas');", "true");
+    exec_and_out_equals("print(members[8] == 'uri');", "true");
   }
 }
\ No newline at end of file
diff --git a/unittest/shell_js_mysqlx_table_t.cc b/unittest/shell_js_mysqlx_table_t.cc
new file mode 100644
index 0000000000000000000000000000000000000000..0568dd21425bd53928283c6e0e80286a8b9f5208
--- /dev/null
+++ b/unittest/shell_js_mysqlx_table_t.cc
@@ -0,0 +1,138 @@
+/*
+* Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation; version 2 of the
+* License.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+* 02110-1301  USA
+*/
+
+#include <cstdio>
+#include <cstdlib>
+#include <fstream>
+#include <string>
+
+#include "gtest/gtest.h"
+#include "test_utils.h"
+#include "base_session.h"
+
+namespace shcore {
+  class Shell_js_mysqlx_table_tests : public Shell_core_test_wrapper
+  {
+  protected:
+    // You can define per-test set-up and tear-down logic as usual.
+    virtual void SetUp()
+    {
+      Shell_core_test_wrapper::SetUp();
+
+      bool initilaized(false);
+      _shell_core->switch_mode(Shell_core::Mode_JScript, initilaized);
+    }
+  };
+
+  TEST_F(Shell_js_mysqlx_table_tests, initialization)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
+
+    exec_and_out_equals("session.executeSql('drop schema if exists js_shell_test;')");
+    exec_and_out_equals("session.executeSql('create schema js_shell_test;')");
+    exec_and_out_equals("session.executeSql('use js_shell_test;')");
+    exec_and_out_equals("session.executeSql('create table table1 (name varchar(50));')");
+  }
+
+  // Tests table.getName()
+  TEST_F(Shell_js_mysqlx_table_tests, mysqlx_schema_get_name)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var table = session.js_shell_test.table1;");
+
+    exec_and_out_equals("print(table.getName());", "table1");
+  }
+
+  // Tests table.name
+  TEST_F(Shell_js_mysqlx_table_tests, mysqlx_schema_name)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var table = session.js_shell_test.table1;");
+
+    exec_and_out_equals("print(table.name);", "table1");
+  }
+
+  // Tests table.getSession()
+  TEST_F(Shell_js_mysqlx_table_tests, mysqlx_schema_get_session)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var table = session.js_shell_test.table1;");
+
+    exec_and_out_equals("var table_session = table.getSession();");
+
+    exec_and_out_equals("print(table_session)", "<Session:" + uri + ">");
+  }
+
+  // Tests table.session
+  TEST_F(Shell_js_mysqlx_table_tests, mysqlx_schema_session)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var table = session.js_shell_test.table1;");
+
+    exec_and_out_equals("print(table.session)", "<Session:" + uri + ">");
+  }
+
+  // Tests table.getSchema()
+  TEST_F(Shell_js_mysqlx_table_tests, mysqlx_schema_get_schema)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var table = session.js_shell_test.table1;");
+
+    exec_and_out_equals("var table_schema = table.getSchema();");
+
+    exec_and_out_equals("print(table_schema)", "<Schema:js_shell_test>");
+  }
+
+  // Tests table.schema
+  TEST_F(Shell_js_mysqlx_table_tests, mysqlx_schema_schema)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var table = session.js_shell_test.table1;");
+
+    exec_and_out_equals("print(table.schema)", "<Schema:js_shell_test>");
+  }
+}
\ No newline at end of file
diff --git a/unittest/shell_js_mysqlx_view_t.cc b/unittest/shell_js_mysqlx_view_t.cc
new file mode 100644
index 0000000000000000000000000000000000000000..28ec8a2dddeebbfb186428223159e422ee9fe1b4
--- /dev/null
+++ b/unittest/shell_js_mysqlx_view_t.cc
@@ -0,0 +1,139 @@
+/*
+* Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation; version 2 of the
+* License.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+* 02110-1301  USA
+*/
+
+#include <cstdio>
+#include <cstdlib>
+#include <fstream>
+#include <string>
+
+#include "gtest/gtest.h"
+#include "test_utils.h"
+#include "base_session.h"
+
+namespace shcore {
+  class Shell_js_mysqlx_view_tests : public Shell_core_test_wrapper
+  {
+  protected:
+    // You can define per-test set-up and tear-down logic as usual.
+    virtual void SetUp()
+    {
+      Shell_core_test_wrapper::SetUp();
+
+      bool initilaized(false);
+      _shell_core->switch_mode(Shell_core::Mode_JScript, initilaized);
+    }
+  };
+
+  TEST_F(Shell_js_mysqlx_view_tests, initialization)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openNodeSession('" + _uri + "');");
+
+    exec_and_out_equals("session.executeSql('drop schema if exists js_shell_test;')");
+    exec_and_out_equals("session.executeSql('create schema js_shell_test;')");
+    exec_and_out_equals("session.executeSql('use js_shell_test;')");
+    exec_and_out_equals("session.executeSql('create table table1 (name varchar(50));')");
+    exec_and_out_equals("session.executeSql('create view view1 (my_name) as select name from table1;')");
+  }
+
+  // Tests view.getName()
+  TEST_F(Shell_js_mysqlx_view_tests, mysqlx_view_get_name)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var view = session.js_shell_test.view1;");
+
+    exec_and_out_equals("print(view.getName());", "view1");
+  }
+
+  // Tests view.name
+  TEST_F(Shell_js_mysqlx_view_tests, mysqlx_view_name)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var view = session.js_shell_test.view1;");
+
+    exec_and_out_equals("print(view.name);", "view1");
+  }
+
+  // Tests view.getSession()
+  TEST_F(Shell_js_mysqlx_view_tests, mysqlx_view_get_session)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var view = session.js_shell_test.view1;");
+
+    exec_and_out_equals("var view_session = view.getSession();");
+
+    exec_and_out_equals("print(view_session)", "<Session:" + uri + ">");
+  }
+
+  // Tests view.session
+  TEST_F(Shell_js_mysqlx_view_tests, mysqlx_view_session)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var view = session.js_shell_test.view1;");
+
+    exec_and_out_equals("print(view.session)", "<Session:" + uri + ">");
+  }
+
+  // Tests view.getSchema()
+  TEST_F(Shell_js_mysqlx_view_tests, mysqlx_view_get_schema)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var view = session.js_shell_test.view1;");
+
+    exec_and_out_equals("var view_schema = view.getSchema();");
+
+    exec_and_out_equals("print(view_schema)", "<Schema:js_shell_test>");
+  }
+
+  // Tests view.schema
+  TEST_F(Shell_js_mysqlx_view_tests, mysqlx_view_schema)
+  {
+    exec_and_out_equals("var mysqlx = require('mysqlx').mysqlx;");
+
+    std::string uri = mysh::strip_password(_uri);
+
+    exec_and_out_equals("var session = mysqlx.openSession('" + _uri + "');");
+
+    exec_and_out_equals("var view = session.js_shell_test.view1;");
+
+    exec_and_out_equals("print(view.schema)", "<Schema:js_shell_test>");
+  }
+}
\ No newline at end of file
diff --git a/unittest/shell_sql_t.cc b/unittest/shell_sql_t.cc
index 8bd62a0361adff0bfdf63b22a61d9b3c4ba3061e..b4727383763aa9357ef03fded911c6aa02370b20 100644
--- a/unittest/shell_sql_t.cc
+++ b/unittest/shell_sql_t.cc
@@ -1,4 +1,3 @@
-
 /* Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
 
  This program is free software; you can redistribute it and/or modify
@@ -14,7 +13,6 @@
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA */
 
-
 #include <cstdio>
 #include <cstdlib>
 #include <fstream>
@@ -27,19 +25,16 @@
 #include "shellcore/lang_base.h"
 #include "shellcore/types_cpp.h"
 
-
 #include "shellcore/shell_core.h"
 #include "shellcore/shell_sql.h"
-#include "../modules/mod_session.h"
-#include "../modules/mod_db.h"
+#include "../modules/base_session.h"
+//#include "../modules/mod_session.h"
+//#include "../modules/mod_schema.h"
 #include "shellcore/common.h"
 #include "test_utils.h"
 #include "boost/algorithm/string.hpp"
 
-
 namespace shcore {
-
-
   namespace sql_shell_tests {
     class Environment
     {
@@ -48,8 +43,6 @@ namespace shcore {
       {
         shell_core.reset(new Shell_core(&output_handler.deleg));
 
-        session.reset(new mysh::Session(shell_core.get()));
-        shell_core->set_global("session", Value(boost::static_pointer_cast<Object_bridge>(session)));
         shell_sql.reset(new Shell_sql(shell_core.get()));
       }
 
@@ -57,11 +50,9 @@ namespace shcore {
       {
       }
 
-
       Shell_test_output_handler output_handler;
       boost::shared_ptr<Shell_core> shell_core;
       boost::shared_ptr<Shell_sql> shell_sql;
-      boost::shared_ptr<mysh::Session> session;
     };
 
     class Shell_sql_test : public ::testing::Test
@@ -92,7 +83,8 @@ namespace shcore {
         if (pwd)
           args.push_back(Value(pwd));
 
-        env.session->connect(args);
+        boost::shared_ptr<mysh::BaseSession> session(mysh::connect_session(args));
+        env.shell_core->set_global("session", Value(boost::static_pointer_cast<Object_bridge>(session)));
       }
     };
 
@@ -141,7 +133,6 @@ namespace shcore {
       EXPECT_EQ("", env.shell_sql->get_handled_input());
       EXPECT_EQ("        -> ", env.shell_sql->prompt());
 
-      
       query = ";";
       env.shell_sql->handle_input(query, state);
 
@@ -163,7 +154,6 @@ namespace shcore {
       // Prompt changes to multiline mode
       EXPECT_EQ(Input_ok, state);
 
-
       query = "show";
       env.shell_sql->handle_input(query, state);
 
@@ -186,7 +176,6 @@ namespace shcore {
       EXPECT_EQ("", env.shell_sql->get_handled_input());
       EXPECT_EQ("        -> ", env.shell_sql->prompt());
 
-
       query = "%%%";
       env.shell_sql->handle_input(query, state);
 
@@ -252,7 +241,6 @@ namespace shcore {
       EXPECT_EQ("", env.shell_sql->get_handled_input());
       EXPECT_EQ("        -> ", env.shell_sql->prompt());
 
-
       query = "databases;\nshow";
       env.shell_sql->handle_input(query, state);
 
@@ -372,4 +360,4 @@ namespace shcore {
       EXPECT_EQ("TRIGGERS: warnings or \\W", lines[1]);
     }
   }
-}
+}
\ No newline at end of file
