diff --git a/modules/adminapi/mod_dba.cc b/modules/adminapi/mod_dba.cc
index 80b8c5f..2183021 100644
--- a/modules/adminapi/mod_dba.cc
+++ b/modules/adminapi/mod_dba.cc
@@ -40,8 +40,8 @@ using namespace shcore;
 
 #define PASSWORD_LENGHT 16
 
-std::set<std::string> Dba::_deploy_instance_opts = { "portx", "sandboxDir", "password", "dbPassword", "verbose" };
-std::set<std::string> Dba::_validate_instance_opts = { "host", "port", "user", "dbUser", "password", "dbPassword", "socket", "ssl_ca", "ssl_cert", "ssl_key", "ssl_key", "verbose" };
+std::set<std::string> Dba::_deploy_instance_opts = { "portx", "sandboxDir", "password", "dbPassword" };
+std::set<std::string> Dba::_validate_instance_opts = { "host", "port", "user", "dbUser", "password", "dbPassword", "socket", "ssl_ca", "ssl_cert", "ssl_key", "ssl_key" };
 
 Dba::Dba(IShell_core* owner) :
 _shell_core(owner) {
@@ -53,6 +53,8 @@ bool Dba::operator == (const Object_bridge &other) const {
 }
 
 void Dba::init() {
+  add_property("verbose");
+
   // Pure functions
   add_method("resetSession", std::bind(&Dba::reset_session, this, _1), "session", shcore::Object, NULL);
   add_method("createCluster", std::bind(&Dba::create_cluster, this, _1), "clusterName", shcore::String, NULL);
@@ -71,6 +73,29 @@ void Dba::init() {
   _provisioning_interface.reset(new ProvisioningInterface(_shell_core->get_delegate()));
 }
 
+void Dba::set_member(const std::string &prop, Value value) {
+  if (prop == "verbose") {
+    if (value && value.type == shcore::Bool) {
+      _provisioning_interface->set_verbose(value.as_bool());
+    } else
+      throw shcore::Exception::value_error("Invalid value for property 'verbose'");
+  } else {
+    Cpp_object_bridge::set_member(prop, value);
+  }
+}
+
+Value Dba::get_member(const std::string &prop) const {
+  shcore::Value ret_val;
+
+  if (prop == "verbose") {
+    ret_val = shcore::Value(_provisioning_interface->get_verbose());
+  } else {
+    ret_val = Cpp_object_bridge::get_member(prop);
+  }
+
+  return ret_val;
+}
+
 std::string Dba::generate_password(int password_lenght) {
   std::random_device rd;
   std::string pwd;
@@ -244,7 +269,6 @@ shcore::Value Dba::create_cluster(const shcore::Argument_list &args) {
 
   std::string mysql_innodb_cluster_admin_pwd;
   bool multi_master = false; // Default single/primary master
-  bool verbose = false; // Default is false
 
   try {
     std::string cluster_name = args.string_at(0);
@@ -266,7 +290,7 @@ shcore::Value Dba::create_cluster(const shcore::Argument_list &args) {
       shcore::Value::Map_type_ref options = args.map_at(2);
 
       // Verification of invalid attributes on the instance creation options
-      auto invalids = shcore::get_additional_keys(options, { "clusterAdminType", "multiMaster", "verbose" });
+      auto invalids = shcore::get_additional_keys(options, { "clusterAdminType", "multiMaster" });
       if (invalids.size()) {
         std::string error = "The instance options contain the following invalid attributes: ";
         error += shcore::join_strings(invalids, ", ");
@@ -285,9 +309,6 @@ shcore::Value Dba::create_cluster(const shcore::Argument_list &args) {
           cluster_admin_type != "ssh") {
         throw shcore::Exception::argument_error("Cluster Administration Type invalid. Valid types are: 'local', 'guided', 'manual', 'ssh'");
       }
-
-      if (options->has_key("verbose"))
-        verbose = options->get_bool("verbose");
     }
     /*
      * For V1.0 we only support one single Cluster. That one shall be the default Cluster.
@@ -336,9 +357,7 @@ shcore::Value Dba::create_cluster(const shcore::Argument_list &args) {
 
     Value::Map_type_ref options(new shcore::Value::Map_type);
     shcore::Argument_list args;
-
     options = get_connection_data(session->uri(), false);
-    (*options)["verbose"] = shcore::Value(verbose);
     args.push_back(shcore::Value(options));
 
     //args.push_back(shcore::Value(session->uri()));
@@ -496,7 +515,7 @@ shcore::Value Dba::validate_instance(const shcore::Argument_list &args) {
     std::string errors;
 
     // Verbose is mandatory for validateInstance
-    if (_provisioning_interface->check(user, host, port, password, errors, true) == 0) {
+    if (_provisioning_interface->check(user, host, port, password, errors) == 0) {
       std::string s_out = "The instance: " + host + ":" + std::to_string(port) + " is valid for Cluster usage\n";
       ret_val = shcore::Value(s_out);
     } else
@@ -515,7 +534,6 @@ shcore::Value Dba::exec_instance_op(const std::string &function, const shcore::A
 
   int port = args.int_at(0);
   int portx = 0;
-  bool verbose = false;
   std::string password;
   std::string sandbox_dir;
 
@@ -550,9 +568,6 @@ shcore::Value Dba::exec_instance_op(const std::string &function, const shcore::A
     if (options->has_key("sandboxDir"))
       sandbox_dir = options->get_string("sandboxDir");
 
-    if (options->has_key("verbose"))
-      verbose = options->get_bool("verbose");
-
     if (options->has_key("options"))
       mycnf_options = (*options)["options"];
   } else {
@@ -566,16 +581,16 @@ shcore::Value Dba::exec_instance_op(const std::string &function, const shcore::A
     throw shcore::Exception::argument_error("Please use a valid TCP port number");
 
   if (function == "deploy") {
-    if (_provisioning_interface->deploy_sandbox(port, portx, sandbox_dir, password, mycnf_options, errors, verbose) != 0)
+    if (_provisioning_interface->deploy_sandbox(port, portx, sandbox_dir, password, mycnf_options, errors) != 0)
       throw shcore::Exception::logic_error(errors);
   } else if (function == "delete") {
-    if (_provisioning_interface->delete_sandbox(port, sandbox_dir, errors, verbose) != 0)
+    if (_provisioning_interface->delete_sandbox(port, sandbox_dir, errors) != 0)
       throw shcore::Exception::logic_error(errors);
   } else if (function == "kill") {
-    if (_provisioning_interface->kill_sandbox(port, sandbox_dir, errors, verbose) != 0)
+    if (_provisioning_interface->kill_sandbox(port, sandbox_dir, errors) != 0)
       throw shcore::Exception::logic_error(errors);
   } else if (function == "stop") {
-    if (_provisioning_interface->stop_sandbox(port, sandbox_dir, errors, verbose) != 0)
+    if (_provisioning_interface->stop_sandbox(port, sandbox_dir, errors) != 0)
       throw shcore::Exception::logic_error(errors);
   }
   return ret_val;
diff --git a/modules/adminapi/mod_dba.h b/modules/adminapi/mod_dba.h
index dfe7617..09254bc 100644
--- a/modules/adminapi/mod_dba.h
+++ b/modules/adminapi/mod_dba.h
@@ -53,6 +53,9 @@ public:
 
   virtual bool operator == (const Object_bridge &other) const;
 
+  virtual void set_member(const std::string &prop, shcore::Value value);
+  virtual shcore::Value get_member(const std::string &prop) const;
+
   std::shared_ptr<ShellDevelopmentSession> get_active_session() const;
   virtual int get_default_port() { return 33060; };
   int get_default_instance_port() { return 3306; }
diff --git a/modules/adminapi/mod_dba_cluster.cc b/modules/adminapi/mod_dba_cluster.cc
index b83a714..5472f1f 100644
--- a/modules/adminapi/mod_dba_cluster.cc
+++ b/modules/adminapi/mod_dba_cluster.cc
@@ -458,7 +458,7 @@ shcore::Value Cluster::dissolve(const shcore::Argument_list &args) {
 
     if (options) {
       // Verification of invalid attributes on the instance creation options
-      auto invalids = shcore::get_additional_keys(options, { "force", "verbose", });
+      auto invalids = shcore::get_additional_keys(options, { "force", });
       if (invalids.size()) {
         std::string error = "The options contain the following invalid attributes: ";
         error += shcore::join_strings(invalids, ", ");
diff --git a/modules/adminapi/mod_dba_provisioning_interface.cc b/modules/adminapi/mod_dba_provisioning_interface.cc
index 61248d7..a6c0c30 100644
--- a/modules/adminapi/mod_dba_provisioning_interface.cc
+++ b/modules/adminapi/mod_dba_provisioning_interface.cc
@@ -32,8 +32,7 @@ using namespace mysh::dba;
 using namespace shcore;
 
 ProvisioningInterface::ProvisioningInterface(shcore::Interpreter_delegate* deleg) :
-_delegate(deleg) {
-}
+_verbose(false), _delegate(deleg) {}
 
 ProvisioningInterface::~ProvisioningInterface() {}
 
@@ -69,8 +68,6 @@ int ProvisioningInterface::execute_mysqlprovision(const std::string &cmd, const
     // If is not set, we have to assume that it's located on the PATH
     if (_local_mysqlprovision_path.empty())
       _local_mysqlprovision_path = "mysqlprovision";
-
-
   }
 
   if (_local_mysqlprovision_path.find(".py") == _local_mysqlprovision_path.size() - 3)
@@ -204,7 +201,7 @@ int ProvisioningInterface::execute_mysqlprovision(const std::string &cmd, const
 }
 
 int ProvisioningInterface::check(const std::string &user, const std::string &host, int port,
-                                 const std::string &password, std::string &errors, bool verbose) {
+                                 const std::string &password, std::string &errors) {
   std::string instance_param = "--instance=" + user + "@" + host + ":" + std::to_string(port);
   std::vector<std::string> passwords;
   std::string pwd = password;
@@ -217,13 +214,13 @@ int ProvisioningInterface::check(const std::string &user, const std::string &hos
   args.push_back("--stdin");
   args.push_back(NULL);
 
-  return execute_mysqlprovision("check", args, passwords, errors, verbose);
+  return execute_mysqlprovision("check", args, passwords, errors, true);
 }
 
 int ProvisioningInterface::exec_sandbox_op(const std::string &op, int port, int portx, const std::string &sandbox_dir,
                                            const std::string &password,
                                            const std::vector<std::string> &extra_args,
-                                           std::string &errors, bool verbose) {
+                                           std::string &errors) {
   std::vector<std::string> sandbox_args, passwords;
   std::string arg, pwd = password;
 
@@ -270,13 +267,13 @@ int ProvisioningInterface::exec_sandbox_op(const std::string &op, int port, int
     args.push_back("--stdin");
   args.push_back(NULL);
 
-  return execute_mysqlprovision("sandbox", args, passwords, errors, verbose);
+  return execute_mysqlprovision("sandbox", args, passwords, errors, _verbose);
 }
 
 int ProvisioningInterface::deploy_sandbox(int port, int portx, const std::string &sandbox_dir,
                                           const std::string &password,
                                           const shcore::Value &mycnf_options,
-                                          std::string &errors, bool verbose) {
+                                          std::string &errors) {
   std::vector<std::string> extra_args;
   if (mycnf_options) {
     for (auto s : *mycnf_options.as_array()) {
@@ -284,31 +281,31 @@ int ProvisioningInterface::deploy_sandbox(int port, int portx, const std::string
     }
   }
   return exec_sandbox_op("start", port, portx, sandbox_dir, password,
-                         extra_args, errors, verbose);
+                         extra_args, errors);
 }
 
 int ProvisioningInterface::delete_sandbox(int port, const std::string &sandbox_dir,
-                                          std::string &errors, bool verbose) {
+                                          std::string &errors) {
   return exec_sandbox_op("delete", port, 0, sandbox_dir, "",
-                         std::vector<std::string>(), errors, verbose);
+                         std::vector<std::string>(), errors);
 }
 
 int ProvisioningInterface::kill_sandbox(int port, const std::string &sandbox_dir,
-                                        std::string &errors, bool verbose) {
+                                        std::string &errors) {
   return exec_sandbox_op("kill", port, 0, sandbox_dir, "",
-                         std::vector<std::string>(), errors, verbose);
+                         std::vector<std::string>(), errors);
 }
 
 int ProvisioningInterface::stop_sandbox(int port, const std::string &sandbox_dir,
-                                        std::string &errors, bool verbose) {
+                                        std::string &errors) {
   return exec_sandbox_op("stop", port, 0, sandbox_dir, "",
-                         std::vector<std::string>(), errors, verbose);
+                         std::vector<std::string>(), errors);
 }
 
 int ProvisioningInterface::start_replicaset(const std::string &instance_url, const std::string &repl_user,
                                       const std::string &super_user_password, const std::string &repl_user_password,
                                       bool multi_master,
-                                      std::string &errors, bool verbose) {
+                                      std::string &errors) {
   std::vector<std::string> passwords;
   std::string instance_args, repl_user_args;
   std::string super_user_pwd = super_user_password;
@@ -331,14 +328,14 @@ int ProvisioningInterface::start_replicaset(const std::string &instance_url, con
   args.push_back("--stdin");
   args.push_back(NULL);
 
-  return execute_mysqlprovision("start-replicaset", args, passwords, errors, verbose);
+  return execute_mysqlprovision("start-replicaset", args, passwords, errors, _verbose);
 }
 
 int ProvisioningInterface::join_replicaset(const std::string &instance_url, const std::string &repl_user,
                                       const std::string &peer_instance_url, const std::string &super_user_password,
                                       const std::string &repl_user_password,
                                       bool multi_master,
-                                      std::string &errors, bool verbose) {
+                                      std::string &errors) {
   std::vector<std::string> passwords;
   std::string instance_args, peer_instance_args, repl_user_args;
   std::string super_user_pwd = super_user_password;
@@ -366,11 +363,11 @@ int ProvisioningInterface::join_replicaset(const std::string &instance_url, cons
   args.push_back("--stdin");
   args.push_back(NULL);
 
-  return execute_mysqlprovision("join-replicaset", args, passwords, errors, verbose);
+  return execute_mysqlprovision("join-replicaset", args, passwords, errors, _verbose);
 }
 
 int ProvisioningInterface::leave_replicaset(const std::string &instance_url, const std::string &super_user_password,
-                                            std::string &errors, bool verbose) {
+                                            std::string &errors) {
   std::vector<std::string> passwords;
   std::string instance_args, repl_user_args;
   std::string super_user_pwd = super_user_password;
@@ -386,5 +383,5 @@ int ProvisioningInterface::leave_replicaset(const std::string &instance_url, con
   args.push_back("--stdin");
   args.push_back(NULL);
 
-  return execute_mysqlprovision("leave-replicaset", args, passwords, errors, verbose);
+  return execute_mysqlprovision("leave-replicaset", args, passwords, errors, _verbose);
 }
diff --git a/modules/adminapi/mod_dba_provisioning_interface.h b/modules/adminapi/mod_dba_provisioning_interface.h
index dd4455f..336e070 100644
--- a/modules/adminapi/mod_dba_provisioning_interface.h
+++ b/modules/adminapi/mod_dba_provisioning_interface.h
@@ -41,36 +41,40 @@ public:
   ~ProvisioningInterface();
 
   int check(const std::string &user, const std::string &host, int port, const std::string &password,
-            std::string &errors, bool verbose);
+            std::string &errors);
 
   int deploy_sandbox(int port, int portx, const std::string &sandbox_dir,
                      const std::string &password,
                      const shcore::Value &mycnf_options,
-                     std::string &errors, bool verbose);
+                     std::string &errors);
 
   //int stop_sandbox(int port, int portx, const std::string &sandbox_dir,
-  //                 const std::string &password, std::string &errors, bool verbose);
+  //                 const std::string &password, std::string &errors);
 
   int delete_sandbox(int port, const std::string &sandbox_dir,
-                     std::string &errors, bool verbose);
+                     std::string &errors);
   int kill_sandbox(int port, const std::string &sandbox_dir,
-                   std::string &errors, bool verbose);
+                   std::string &errors);
   int stop_sandbox(int port, const std::string &sandbox_dir,
-                   std::string &errors, bool verbose);
+                   std::string &errors);
   int start_replicaset(const std::string &instance_url, const std::string &repl_user,
                  const std::string &super_user_password, const std::string &repl_user_password,
                  bool multi_master,
-                 std::string &errors, bool verbose);
+                 std::string &errors);
   int join_replicaset(const std::string &instance_url, const std::string &repl_user,
                  const std::string &peer_instance_url, const std::string &super_user_password,
                  const std::string &repl_user_password,
                  bool multi_master,
-                 std::string &errors, bool verbose);
+                 std::string &errors);
 
   int leave_replicaset(const std::string &instance_url, const std::string &super_user_password,
-                       std::string &errors, bool verbose);
+                       std::string &errors);
+
+  void set_verbose(bool verbose) { _verbose = verbose; }
+  bool get_verbose() { return _verbose; }
 
 private:
+  bool _verbose;
   shcore::Interpreter_delegate *_delegate;
   std::string _local_mysqlprovision_path;
 
@@ -80,7 +84,7 @@ private:
   int exec_sandbox_op(const std::string &op, int port, int portx, const std::string &sandbox_dir,
                      const std::string &password,
                      const std::vector<std::string> &extra_args,
-                     std::string &errors, bool verbose);
+                     std::string &errors);
 };
 }  // namespace mysqlx
 }  // namespace mysh
diff --git a/modules/adminapi/mod_dba_replicaset.cc b/modules/adminapi/mod_dba_replicaset.cc
index 5409cd9..e93d55f 100644
--- a/modules/adminapi/mod_dba_replicaset.cc
+++ b/modules/adminapi/mod_dba_replicaset.cc
@@ -42,8 +42,8 @@ using namespace mysh;
 using namespace mysh::dba;
 using namespace shcore;
 
-std::set<std::string> ReplicaSet::_add_instance_opts = { "name", "host", "port", "user", "dbUser", "password", "dbPassword", "socket", "ssl_ca", "ssl_cert", "ssl_key", "ssl_key", "verbose" };
-std::set<std::string> ReplicaSet::_remove_instance_opts = { "name", "host", "port", "socket", "ssl_ca", "ssl_cert", "ssl_key", "ssl_key", "verbose" };
+std::set<std::string> ReplicaSet::_add_instance_opts = { "name", "host", "port", "user", "dbUser", "password", "dbPassword", "socket", "ssl_ca", "ssl_cert", "ssl_key", "ssl_key" };
+std::set<std::string> ReplicaSet::_remove_instance_opts = { "name", "host", "port", "socket", "ssl_ca", "ssl_cert", "ssl_key", "ssl_key" };
 
 char const *ReplicaSet::kTopologyPrimaryMaster = "pm";
 char const *ReplicaSet::kTopologyMultiMaster = "mm";
@@ -322,7 +322,6 @@ shcore::Value ReplicaSet::add_instance(const shcore::Argument_list &args) {
   std::string super_user_password;
   std::string host;
   int port = 0;
-  bool verbose = false;
 
   // NOTE: This function is called from either the add_instance_ on this class
   //       or the add_instance in Cluster class, hence this just throws exceptions
@@ -391,9 +390,6 @@ shcore::Value ReplicaSet::add_instance(const shcore::Argument_list &args) {
   } else
     throw shcore::Exception::argument_error("Missing password for " + build_connection_string(options, false));
 
-  if (options->has_key("verbose"))
-    verbose = options->get_bool("verbose");
-
   // Check if the instance was already added
   std::string instance_address = options->get_string("host") + ":" + std::to_string(options->get_int("port"));
 
@@ -472,8 +468,7 @@ shcore::Value ReplicaSet::add_instance(const shcore::Argument_list &args) {
     do_join_replicaset(user + "@" + host + ":" + std::to_string(port),
         "",
         super_user_password,
-        replication_user, replication_user_password,
-        verbose);
+        replication_user, replication_user_password);
   } else {
     // We need to retrieve a peer instance, so let's use the Seed one
     std::string peer_instance = _metadata_storage->get_seed_instance(get_id());
@@ -482,8 +477,7 @@ shcore::Value ReplicaSet::add_instance(const shcore::Argument_list &args) {
     do_join_replicaset(user + "@" + host + ":" + std::to_string(port),
         user + "@" + peer_instance,
         super_user_password,
-        replication_user, replication_user_password,
-        verbose);
+        replication_user, replication_user_password);
   }
 
   // OK, if we reached here without errors we can update the metadata with the host
@@ -519,8 +513,7 @@ shcore::Value ReplicaSet::add_instance(const shcore::Argument_list &args) {
 bool ReplicaSet::do_join_replicaset(const std::string &instance_url,
     const std::string &peer_instance_url,
     const std::string &super_user_password,
-    const std::string &repl_user, const std::string &repl_user_password,
-    bool verbose) {
+    const std::string &repl_user, const std::string &repl_user_password) {
   shcore::Value ret_val;
   int exit_code = -1;
 
@@ -533,13 +526,13 @@ bool ReplicaSet::do_join_replicaset(const std::string &instance_url,
                       repl_user, super_user_password,
                       repl_user_password,
                       _topology_type == kTopologyMultiMaster,
-                      errors, verbose);
+                      errors);
   } else {
     exit_code = _provisioning_interface->join_replicaset(instance_url,
                       repl_user, peer_instance_url,
                       super_user_password, repl_user_password,
                       _topology_type == kTopologyMultiMaster,
-                      errors, verbose);
+                      errors);
   }
 
   if (exit_code == 0) {
@@ -638,8 +631,7 @@ shcore::Value ReplicaSet::rejoin_instance(const shcore::Argument_list &args) {
     do_join_replicaset(user + "@" + host + ":" + std::to_string(port),
         user + "@" + peer_instance,
         super_user_password,
-        replication_user, replication_user_password,
-        true);
+        replication_user, replication_user_password);
   } CATCH_AND_TRANSLATE_FUNCTION_EXCEPTION(get_function_name("addInstance"));
 
   return ret_val;
@@ -696,7 +688,6 @@ shcore::Value ReplicaSet::remove_instance(const shcore::Argument_list &args) {
   std::string host;
   std::string name;
   int port = 0;
-  bool verbose = false;
 
   // Identify the type of connection data (String or Document)
   if (args[0].type == String) {
@@ -732,9 +723,6 @@ shcore::Value ReplicaSet::remove_instance(const shcore::Argument_list &args) {
 
   host = options->get_string("host");
 
-  if (options->has_key("verbose"))
-    verbose = options->get_bool("verbose");
-
   // Check if the instance exists on the ReplicaSet
   std::string instance_address = options->get_string("host") + ":" + std::to_string(options->get_int("port"));
 
@@ -761,7 +749,7 @@ shcore::Value ReplicaSet::remove_instance(const shcore::Argument_list &args) {
 
   instance_url = instance_admin_user + "@" + host + ":" + std::to_string(port);
 
-  exit_code = _provisioning_interface->leave_replicaset(instance_url, instance_admin_user_password, errors, verbose);
+  exit_code = _provisioning_interface->leave_replicaset(instance_url, instance_admin_user_password, errors);
 
   if (exit_code != 0)
     throw shcore::Exception::logic_error(errors);
@@ -797,43 +785,30 @@ shcore::Value ReplicaSet::dissolve(const shcore::Argument_list &args) {
   args.ensure_count(0, 1, get_function_name("dissolve").c_str());
 
   try {
-    bool verbose = false;
     bool force = false;
     shcore::Value::Map_type_ref options;
 
     if (args.size() == 1)
       options = args.map_at(0);
 
-      if (options) {
-        // Verification of invalid attributes on the instance creation options
-        auto invalids = shcore::get_additional_keys(options, { "verbose", "force" });
-        if (invalids.size()) {
-          std::string error = "The options contain the following invalid attributes: ";
-          error += shcore::join_strings(invalids, ", ");
-          throw shcore::Exception::argument_error(error);
-        }
+    if (options) {
+      // Verification of invalid attributes on the instance creation options
+      auto invalids = shcore::get_additional_keys(options, { "force" });
+      if (invalids.size()) {
+        std::string error = "The options contain the following invalid attributes: ";
+        error += shcore::join_strings(invalids, ", ");
+        throw shcore::Exception::argument_error(error);
+      }
 
       if (options->has_key("force")) {
         if ((*options)["force"].type != shcore::Bool)
           throw shcore::Exception::type_error("Invalid data type for 'force' field, should be a boolean");
         force = options->get_bool("force");
       }
-
-      if (options->has_key("verbose")) {
-        if ((*options)["verbose"].type != shcore::Bool)
-          throw shcore::Exception::type_error("Invalid data type for 'force' field, should be a boolean");
-        verbose = options->get_bool("verbose");
-      }
     }
 
     if (force) {
-      shcore::Argument_list args;
-      Value::Map_type_ref options(new shcore::Value::Map_type);
-      (*options)["verbose"] = shcore::Value(verbose);
-      args.push_back(shcore::Value(options));
-
-      // disable the ReplicaSet
-      disable(args);
+      disable(shcore::Argument_list());
     } else if (_metadata_storage->is_replicaset_active(get_id()))
       throw shcore::Exception::logic_error("Cannot dissolve the ReplicaSet: the ReplicaSet is active.");
 
@@ -864,29 +839,11 @@ shcore::Value ReplicaSet::dissolve(const shcore::Argument_list &args) {
 shcore::Value ReplicaSet::disable(const shcore::Argument_list &args) {
   shcore::Value ret_val;
 
-  args.ensure_count(0, 1, get_function_name("disable").c_str());
+  args.ensure_count(0, get_function_name("disable").c_str());
 
   try {
-    bool verbose = false;
-    shcore::Value::Map_type_ref options;
     MetadataStorage::Transaction tx(_metadata_storage);
 
-    if (args.size() == 1)
-      options = args.map_at(0);
-
-      if (options) {
-        // Verification of invalid attributes on the instance creation options
-        auto invalids = shcore::get_additional_keys(options, { "verbose" });
-        if (invalids.size()) {
-          std::string error = "The options contain the following invalid attributes: ";
-          error += shcore::join_strings(invalids, ", ");
-          throw shcore::Exception::argument_error(error);
-        }
-
-        if (options->has_key("verbose"))
-          verbose = options->get_bool("verbose");
-      }
-
     std::string instance_admin_user = _cluster->get_account_user(ACC_INSTANCE_ADMIN);
     std::string instance_admin_user_password = _cluster->get_account_password(ACC_INSTANCE_ADMIN);
 
@@ -903,7 +860,7 @@ shcore::Value ReplicaSet::disable(const shcore::Argument_list &args) {
 
       // Leave the replicaset
       exit_code = _provisioning_interface->leave_replicaset(instance_url,
-                                            instance_admin_user_password, errors, verbose);
+                                            instance_admin_user_password, errors);
 
       if (exit_code != 0)
         throw shcore::Exception::logic_error(errors);
diff --git a/modules/adminapi/mod_dba_replicaset.h b/modules/adminapi/mod_dba_replicaset.h
index 92578ba..ba566c3 100644
--- a/modules/adminapi/mod_dba_replicaset.h
+++ b/modules/adminapi/mod_dba_replicaset.h
@@ -118,8 +118,7 @@ private:
   bool do_join_replicaset(const std::string &instance_url,
       const std::string &peer_instance_url,
       const std::string &super_user_password,
-      const std::string &repl_user, const std::string &repl_user_password,
-      bool verbose = false);
+      const std::string &repl_user, const std::string &repl_user_password);
 
   std::shared_ptr<Cluster> _cluster;
   std::shared_ptr<MetadataStorage> _metadata_storage;
diff --git a/shellcore/interactive_dba_cluster.cc b/shellcore/interactive_dba_cluster.cc
index 19c1e5c..2280833 100644
--- a/shellcore/interactive_dba_cluster.cc
+++ b/shellcore/interactive_dba_cluster.cc
@@ -264,7 +264,7 @@ shcore::Value Interactive_dba_cluster::dissolve(const shcore::Argument_list &arg
 
     if (options) {
       // Verification of invalid attributes on the instance creation options
-      auto invalids = shcore::get_additional_keys(options, { "force", "verbose", });
+      auto invalids = shcore::get_additional_keys(options, { "force", });
       if (invalids.size()) {
         std::string error = "The options contain the following invalid attributes: ";
         error += shcore::join_strings(invalids, ", ");
diff --git a/shellcore/interactive_global_dba.cc b/shellcore/interactive_global_dba.cc
index 9e94f4c..be22b80 100644
--- a/shellcore/interactive_global_dba.cc
+++ b/shellcore/interactive_global_dba.cc
@@ -106,10 +106,10 @@ shcore::Value Global_dba::deploy_local_instance(const shcore::Argument_list &arg
     auto options = valid_args.map_at(1);
 
     if (options && options->has_key("sandboxDir")) {
-        sandbox_dir = options->get_string("sandboxDir");
+      sandbox_dir = options->get_string("sandboxDir");
     } else {
-        // we get the default value
-        sandbox_dir = (*shcore::Shell_core_options::get())[SHCORE_SANDBOX_DIR].as_string();
+      // we get the default value
+      sandbox_dir = (*shcore::Shell_core_options::get())[SHCORE_SANDBOX_DIR].as_string();
     }
 
     // Verification of required attributes on the instance deployment data
@@ -217,7 +217,6 @@ shcore::Value Global_dba::create_cluster(const shcore::Argument_list &args) {
     std::string cluster_name = args.string_at(0);
     std::string answer, cluster_password;
     shcore::Value::Map_type_ref options;
-    bool verbose = false; // Default is false
     bool multi_master = false;
 
     if (cluster_name.empty())
@@ -238,9 +237,6 @@ shcore::Value Global_dba::create_cluster(const shcore::Argument_list &args) {
         // Check if some option is missing
         // TODO: Validate adminType parameter value
 
-        if (options->has_key("verbose"))
-          verbose = options->get_bool("verbose");
-
         if (options->has_key("multiMaster")) {
           multi_master = true;
         }
@@ -295,10 +291,8 @@ shcore::Value Global_dba::create_cluster(const shcore::Argument_list &args) {
       // This is an instance of the API cluster
       auto raw_cluster = _target->call("createCluster", new_args);
 
-      if (verbose){
-        println();
-        print("Adding Seed Instance...");
-      }
+      print("Adding Seed Instance...");
+      println();
 
       // Returns an interactive wrapper of this instance
       Interactive_dba_cluster* cluster = new Interactive_dba_cluster(this->_shell_core);
